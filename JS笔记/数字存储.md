[JavaScript 浮点数陷阱及解法 - GitHub](https://github.com/camsong/blog/issues/9)

[浮点数的二进制表示 - 阮一峰](https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)

[在线测试 IEEE 754](http://www.binaryconvert.com/result_double.html?decimal=049050051)

[十进制转二进制教程](https://juejin.cn/post/6844903687010123790)

#### JavaScript如何存储数字？

JavaScript 中所有数字包括整数和小数都只有一种类型 — `Number`。它的实现遵循 [IEEE 754](http://grouper.ieee.org/groups/754/) 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零



![64 bit allocation](https://github.com/NoAlligator/pico/blob/main/img/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67?raw=true)

实际数字就可以用以下公式来计算：



![31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c](https://github.com/NoAlligator/pico/blob/main/img/31601584-f65ed43e-b21f-11e7-8755-c99b48e5134c.png?raw=true)

举例说明：

-1020 →  -1 * (10^3) * 1.02



#### 如何转换十进制为二进制？

整数部分：除二取余倒着排

小数部分：乘二取整顺着排

​	举例说明：173.8125

```
173 / 2 = 86 ... 1
86  / 2 = 43 ... 0
43  / 2 = 21 ... 1
21  / 2 = 10 ... 1
10  / 2 = 5  ... 0
5   / 2 = 2  ... 1
2   / 2 = 1  ... 0
1   / 2 = 0  ... 1
Int partial result: 10101101

0.8125 * 2 = 1.625
0.625  * 2 = 1.25   
0.25   * 2 = 0.5
0.5    * 2 = 1
Decimal partial result: 1101

result: 10101101.1101
```

​	举例说明：0.1

```
0.1 * 2 = 0.2

0.2 * 2 = 0.4 // loop 1
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2

0.2 * 2 = 0.4 // loop 2
0.4 * 2 = 0.8
0.8 * 2 = 1.6
0.6 * 2 = 1.2

...			  // endless loop

result: 0.000110011···
```



#### 如何从0.1反推S、E、M？

1. 0.1转换为二进制是0.000110011···，科学计数法表示为1.1001100··· * 2^(-4)
2. 由上述可知E部分的数值减去1023才是最终指数，故进行转换：E - 1023 = -4 → E = 1019 = 01111111011
3. 由上述可知M部分会被自动加上1，所以应当去掉1.1001100的1才是原本的M：1001100···（52bits）
4. S易知是0，因为是正数



#### 0.1 + 0.2？

Js是将数字转换成二进制在进行计算的：

0.1 = 0.00011001100110011001100110011001100110011001100110011010 （末尾会进位）

0.2 =0.0011001100110011001100110011001100110011001100110011010（末尾会进位）

0.1 + 0.2 = 0.0100110011001100110011001100110011001100110011001100111

0.0100110011001100110011001100110011001100110011001100111转换成十进制就是0.30000000000000004

#### JavaScript的最大精度？

2^53=9007199254740992 → 0.9007199254740992

#### 总结：

JS内部不管是小数还是整数都使用**双精度实数**来存储数字，这就导致部分小数并不能够**准确**地被转换为对应的二进制数据（因为在转换后是无限循环的二进制小数），而尾数的位数最长为52，所以会在**末尾进位**，这样导致得到的0.1并不是真正的0.1

JS能够精确进行数字运算的整数范围：±(2^(53)-1)

JS的最大数：±(2 ^ 1024 - 1)



#### 引申

number.toPrecision(precision): string  **VS.**  number.toFixed(digits) **VS.** Math.round(x): number

- Number.toPrecision：处理精度并返回字符串，precision是从左至右第一个不为0的数开始数起
- Number.toFixed： digits从小数点开始数起处理四舍五入并返回字符串（两个API存在陷阱，Number.toFixed(1.005) = 1.00，因为1.005实际上是1.0049999···）
- Math.round：四舍五入为整数

#### 解决精度问题

##### 数据展示类

当你拿到 `1.4000000000000001` 这样的数据要展示时，建议使用 `toPrecision` 凑整并 `parseFloat` 转成数字后再显示，如下：

```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
```

封装成方法就是：

```js
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
```

为什么选择 `12` 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。

##### 数据运算类

对于运算类操作，如 `+-*/`，就不能使用 `toPrecision` 了。正确的做法是把小数转成整数后再运算。以加法为例：

```js
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

以上方法能适用于大部分场景。遇到科学计数法如 `2.3e+1`（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。



#### 番外：JavaScript中的数值进制表示

使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。

- 十进制：没有前导`0`的数值
- 八进制：有前缀`0o`或`0O`的数值，或者有前导`0`、且只用到`0-7`的八个阿拉伯数字的数值。
- 十六进制：有前缀`0x`或`0X`的数值。
- 二进制：有前缀`0b`或`0B`的数值。

默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。

![image-20211116125614973](https://github.com/NoAlligator/pico/blob/main/img/image-20211116125614973.png?raw=true)

