# 树

> 相关术语

- 树：
  - 仅有一个根节点，没有节点则为空树
  - 除根节点外，每个节点都有并仅有唯一一个父节点
  - 节点间不能形成闭环
- 树的层级：以根节点为第`0`层节点
- 根节点
- 内部节点：至少有一个子节点的节点
- 外部节点/叶节点：没有子节点的节 点
- 子树
- 节点的深度：节点所在的层数/节点祖先元素的个数/**从根节点到该节点所经历的边的个数**
- 节点的度：一个节点含有的子节点的个数（类似于图论中度的概念）
- 树的度：树中最大的节点的度被称为树的度
- 祖先节点
- 后代节点
- 父节点
- 子节点
- 树的深度：树的深度等于树的高度
- 树的高度：所有节点深度的最大值/根节点的高度
- 树的宽度：两个最长路径的叶子节点之间节点数
- 节点的高度：节点到叶节点的最长路径
- 键：树相关术语中对节点的代称
- 满二叉树：**除了叶结点外每一个结点都有左右子叶**且**叶子结点都处在最底层**的二叉树
- 完全二叉树：深度为`h`，除第`h`层外，其它各层`(1～h-1)`的结点数都达到最大个数，第`h`层所有的结点都连续集中在最左边

------

# 二叉搜索树（BST）

> 定义：二叉搜索树只允许你在**左侧节点存储比父节点小的值，在右侧节点存储比父节点大的值**
>
> 

## 一、创建`BinarySearchTree`类

> ### 1.创建`Node`类，作为节点

```javascript
export class Node {
    constructor(key) {
        this.key = key
        this.left = null
        this.right = null
    }
}
```

> ### 2.声明比较常量，默认比较函数

```javascript
export const Compare = {
    LESS_THAN: -1,
    BIGGER_THAN: 1,
    EQUALS: 0
};
export function defaultCompare(a, b) {
    if (a === b) {
        return Compare.EQUALS;
    }
    return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
}
```

> ### 3.初始化`BST`树的结构
>

```javascript
import { Compare, defaultCompare } from './utils'
export default class BinarySearchTree{
    root = null	//初始化根节点
    constructor(compareFn = defaultCompare ) {
        this.compareFn = compareFn	//设置默认的比较函数
    }
}
```

## 二、实现`insert(key)`方法，向`BST`实例中插入数据

> ### `insert()`中实现对插入情况的分流：插入位置为根节点/非根节点

```javascript
//以下为BinarySearchTree树内部的insert方法
function insert(key) {
	if(this.root === null){
        this.root = new Node(key)
    } else {
        this.insertNood(this.root, key)
    }
}
```

> ### `insertNode()`中实现将节点添加到根节点以外的位置
>

```javascript
function insertNode(node, key) {
    if (node === null) {
        return new Node(key)
    } else if (Compare.LESS_THAN === this.compareFn(key, node.key)) {
        node.left = this.insertNode(node.left, key)
    } else if (Compare.BIGGER_THAN === this.compareFn(key, node.key)) {
        node.right = this.insertNode(node.right, key)
    } else {        //处理重复的key传入的情况，直接返回原node
        return node
    }
    return node
}
```

> ### `insertArr`中实现批量插入元素

```javascript
insertArr(arr) {
    arr.forEach(e => this.insert(e))
}
```



## 三、实现三种遍历树方法（先序、中序、后序）

> ### 中序遍历
>

```javascript
//中序遍历是一种以上行顺序访问的遍历方式，也就是从小到大的顺序访问所有节点。
//中序遍历就是对树进行排序操作。
function inOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback)
}

function inOrderTraverseNode(node, callback) {
    if (node !== null) {
        this.inOrderTraverseNode(node.left, callback)
        callback(node.key)
        this.inOrderTraverseNode(node.right, callback)
    }
}

const {inOrder} = (function () {
    let stack = []
    let result = []

    function preOrder(node) {
        if (!node) return
        while (stack.length || node) {
            while (node) {
                stack.push(node)
                node = node.left
            }
            node = stack.pop()
            result.push(node.key)
            node = node.right
        }
    }

    function reset() {
        stack = []
        result = []
    }

    return {
        inOrder: (root) => {
            reset()
            preOrder(root)
            return result
        }
    }
})()
```

> ###  先序遍历
>

```javascript
//先序遍历是以优先于后代节点的顺序访问每个节点。
//先序遍历的一种应用是打印一个结构化的文档。
function preOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback)
}

function preOrderTraverseNode(node, callback) {
    if (node !== null) {
        callback(node.key)
        this.inOrderTraverseNode(node.left, callback)
        this.inOrderTraverseNode(node.right, callback)
    }
}

//以下为先序遍历的非递归实现版本
const {preOrder} = (function () {
    let stack = []
    let result = []

    function preOrder(root) {
        stack.push(root)
        while (stack.length !== 0) {
            const node = stack.pop()
            result.push(node.key)
            node.right && stack.push(node.right)
            node.left && stack.push(node.left)
        }
    }

    function reset() {
        stack = []
        result = []
    }

    return {
        preOrder: (root) => {
            reset()
            preOrder(root)
            return result
        }
    }
})()
```

> ### 后序遍历
>

```javascript
//后序节点是先访问节点的后代节点，再访问节点本身。
//后序遍历的一种应用是计算一个目录及其子目录中所有文件所占空间的大小。
function inOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback)
}

function inOrderTraverseNode(node, callback) {
    if (node !== null) {
        this.inOrderTraverseNode(node.left, callback)
        this.inOrderTraverseNode(node.right, callback)
        callback(node.key)
    }
}


const {postOrder} = (function () {
    let stack = []

    function postOrder(node) {
        if (!node) return
        stack.push(node)
        while (stack.length) {
            const node = stack.pop()
            result.push(node.key)
            if (node.left) stack.push(node.left)
            if (node.right) stack.push(node.right)
        }
        result = result.reverse()
    }

    function reset() {
        stack = []
        result = []
    }

    return {
        postOrder: (root) => {
            reset()
            postOrder(root)
            return result
        }
    }
})()

```

> ### 广度优先遍历（BFS）

```javascript
// 递归版本
const {bfs: bfsRecursion} = (function () {
    let stack = []
    let result = []
    let count = 0

    function bfs() {
        const node = stack[count]
        if (node) {
            result.push(node.key)
            if (node.left) stack.push(node.left)
            if (node.right) stack.push(node.right)
            count += 1
            bfs()
        }
    }

    function reset() {
        stack = []
        result = []
        count = 0
    }

    return {
        bfs: (root) => {
            if (!root) return
            reset() //重置栈结构
            stack = [root] //先将根元素推入栈中
            bfs()   //执行遍历
            return result
        }
    }
})()

// 非递归版本
const {bfs} = (function () {
    let queue = []
    let result = []
    let pointer = 0

    function bfs(root) {
        queue.push(root)
        while (pointer < queue.length) {
            const node = queue[pointer]
            result.push(node.key)
            node.left && queue.push(node.left)
            node.right && queue.push(node.right)
            pointer += 1
        }
    }

    function reset() {
        result = []
        queue = []
        pointer = 0
    }

    return {
        bfs: (root) => {
            if (!root) return void 0
            reset()         //重置
            bfs(root)       //执行bfs
            return result   //返回结果
        }
    }
})()
```



## 四、实现`min()`、`max()`，查找树的最小节点和最大节点

```javascript
function minNode(node) {
    let current = node
    //current !== null是为了判断是否传入了null节点
    while(current !== null && current.left !== null){
        current = current.left 
    }
    return current
}
function min() {
    return this.minNode(this.root)
}
```

```javascript
function maxNode(node) {
    let current = node
    //current !== null是为了判断是否传入了null节点
    while(current !== null && current.right !== null){
        current = current.right 
    }
    return current
}
function max() {
    return this.maxNode(this.root)
}
```

## 五、实现`search(key)`方法，查找指定节点是否存在

```javascript
function search(key) {
    return this.searchNode(this.root, key)
}
function searchNode(node, key) {
    if(node === null) return false
    if(key < node.key){
        return this.searchNode(node.left, key)
    } else if(key > node.key){
		return this.searchNode(node.right, key)
    } else {
        return true
    }
}
```

## 五、实现`remove(key)`方法，移除指定节点

> 移除节点时，分为三种情况
>
> - 删除叶节点
> - 删除仅拥有单个子节点的节点
> - 删除拥有两个子节点的节点
>   - 通过`const aux = minNode(node.right)`获取右节点的（值）最小节点
>   - 将最小值赋值给当前待删除的节点
>   - 删除右侧节点为根节点的树中的最小节点及其父节点的引用`node.right = this.removeNode(node.right, aux.value)`

```javascript
function remove(key) {
    this.root = this.removeNode(this.root, key)
}

function removeNode(node, key) {
    if(node === null) return null
    if(compareFn(key, node.key) === Compare.LESS_THAN){
        return node = removeNode(node.left, key)
    } else if(compareFn(key, node.key) === Compare.BIGGER_THAN){
        return node = removeNode(node.right, key)
    } else {
        if(node.left === null && node.right === null){
            return node = null
        }
        if(node.left === null) {
            return node = node.right            
        }
        if(node.right === null) {
            return node = node.left
        }
        const aux = this.minNode(node.right)
        node = aux.key
        node.right = this.removeNode(node.right, aux.key)
        return node
    }
}
```

# 自平衡树

> ## AVL树
>
> 定义：`AVL`是一种自平衡二叉搜索树，`AVL`树的任何一个节点左右两侧子树的高度之差**最多为`1`**。添加或删除节点时，`AVL`树会尝试保持自平衡。
>
> 实现：因为AVL树也是一个`BST`树，那么我们可以扩展`BST`类，只需要覆盖用来维持`AVL`树平衡的方法，也就是`insert()`、`insertNode()`、`removeNode()`、所有其他的BST方法将会被`AVLTree`类所继承。
>
> 平衡因子：在`AVL`树中，需要对每个节点计算**右子树高度`（hr）`**和**左子树高度`（hl）`**，之间的差值，该差值`（hr - hl）`应当为`0, -1, 1`三者之一。如果不是三者之一，则表示需要平衡该`AVL`树。
>
> ## 时间复杂度
>
> ### 查询
>
> 需要按照层级依次查找，平均时间复杂度为：`O(log(n))`
>
> ### 插入
>
> 也是需要按照层级依次查找，平均时间复杂度为：`O(log(n))`
>
> ### 删除
>
> 删除的时候采用递归的方式`O(log(n))`，每一次都要获取节点深度`O(log(n))`，所以时间复杂度是`O((log(n)) ^ 2)`也就是`2log(n)`

## 创建一个`AVLTree`类

> ### 创建`AVL`树的基本结构（继承自`BST`树）

```javascript
import {defaultCompare, Compare} from './utils'
const BinarySearchTree = require('./bst')

class AVLTree extends BinarySearchTree{
    constructor(compareFn = defaultCompare) {
        super(compareFn)	//在BST类中已经完成了根节点的初始化，只需要通过super介入初始化的比较函数
    }
}
```

> ### 定义平衡因子常量表`BalanceFactor`

```javascript
const BalanceFactor = {
    UNBALANCED_LEFT: 1,
    SLIGHTLY_UNBALANCED_LEFT: 2,
    BALANCED: 3,
    SLIGHTLY_UNBALANCED_RIGHT: 2,
    UNBALANCED_RIGHT: 2,
}
```

> ### 定义节点高度的计算方法`getNodeHeight(node, height = -1)`

```javascript
// 默认情况下null节点的高度为-1，因为边界条件是读取到null，所以可以将null节点的高度设置为-1
// 这样可以确保叶子节点高度为0
function getNodeHeight(node, height = -1){
    if(node === null) return height
    return Math.max(this.getNodeHeigt(node.left, height + 1), this.getNodeHeigt(node.right, height + 1))
}
```

> ### 定义计算节点平衡因子的方法`getBlanceFactor(node)`

```javascript
function getBlanceFactor(node){
    if(node === null) return BlanceFactor.BALANCED 
    //平衡因子通过左子节点的平衡因子 - 右子节点的平衡因子获得
    const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right)
    //将平衡因子结果和平衡因子常量表对应起来
    switch(heightDifference) {
        case -2: 
            return BalanceFactor.UNBALANCED_RIGHT
        case -1: 
            return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
        case 1: 
            return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
        case 2: 
            return BalanceFactor.UNBALANCED_LEFT
        default: 
            return BalanceFactor.BALANCED
    }
}
```

> ### 定义节点旋转方法`LL、RR、LR、RL`

```javascript
function rotationLL(node) {
	const temp = node.left
    node.left = temp.right
    temp.right = node
    return temp
}
 /**
   * Left left case: rotate right
   *
   *       b                           a
   *      / \                         / \
   *     a   e -> rotationLL(b) ->   c   b
   *    / \                             / \
   *   c   d                           d   e
   *
   * @param node Node<T>
   */
```

```javascript
function rotationRR(node) { 
	const temp = node.right
    node.right = temp.left
    temp.left = node 
    return temp
}
 /**
   * Right right case: rotate left
   *
   *     a                              b
   *    / \                            / \
   *   c   b   -> rotationRR(a) ->    a   e
   *      / \                        / \
   *     d   e                      c   d
   *
   * @param node Node<T>
   */
```

```javascript
function rotationLR(node){
    node = this.rotationRR(node)
    return this.rotationLL(node.left)
}
```

```javascript
function rotationLR(node){
    node = this.rotationLL(node)
    return this.rotationRR(node.right)
}
```

> ### 定义添加节点的方法`insert(key)，insertNode(node, key)`

```javascript
function insert(key) {
    this.root = this.insertNode(this.root, key)
}
```

```javascript
function insertNode(node, key){
    // 节点为null时，证明此时找到了合适的插入位置，返回新的节点
    if(node === null) return new Node(key)

    const COMPARE_RESULT = this.CompareFn(key, node.key)
    if(COMPARE_RESULT === Compare.LESS_THAN) {
        //节点小于当前节点，则需要进一步往该节点的左子节点继续递归操作，直至找到合适的节点位置（null）
        //插入后务必返回原节点
        node.left = this.insertNode(node.left, key)
    } else if (COMPARE_RESULT === Compare.BIGGER_THAN) {
        //节点大于当前节点，则需要进一步往该节点的右子节点继续递归操作，直至找到合适的节点位置（null）
        // 插入后务必返回原节点
        node.right = this.insertNode(node.right, key)
    } else {
        //处理当重复的key传入的情况，直接返回原node
        return node
    }

    //处理不平衡节点，先获取节点平衡因子
    const balanceFactor = this.getBlanceFactor(node)
    //左侧不平衡
    if(balanceFactor = BalanceFactor.UNBALANCED_LEFT) {
        if(compareFn(key, node.left.key) === Compare.LESS_THAN){
            //插入节点小于目标节点，则证明插入位置在左侧，左子树右侧高度过大，执行LL操作
            return this.rotationLL(node)
        } else {
            //插入节点大于目标节点，则证明插入位置在右侧，左子树右侧高度过大，执行LR操作
            return this.rotationLR(node)
        }
    }
    if(balanceFactor = BalanceFactor.UNBALANCED_RIGHT) {
        if(compareFn(key, node.left.key) === Compare.BIGGER_THAN){
            return this.rotationRR(node)
        } else {
            return this.rotationRL(node)
        }
    }
    return node
}
```

> ### 定义删除节点的方法`remove(key)、removeNode(node, key)`

```javascript
function remove(key) {
    //remove务必遵照移除后返回原节点的规则进行操作
    this.root = this.removeNode(this.root, key)
}
```

```javascript
function removeNode(node, key) {
    // 调用BST的removeNode方法，对节点操作之后返回原节点
    node = super.removeNode(node, key)
    // 如果发现执行完removeNode(node, key)之后返回的node是null，则证明传入的node就是null
    // 则需要直接返回，因为null不会被删除
    if(node === null) return node
    // 生成node的平衡因子
    const balanceFactor = this.getBalanceFactor(node)
    // 判断左子树不平衡
    if(balanceFactor === BlanceFactor.UNBALANCED_LEFT){
        // 通过左子树根节点平衡因子判断使用LL还是LR
        const leftBalanceFactor = this.getBalanceFactor(node.left)
        // 左子树在BALANCED和SLIGHTLY_UNBALANCED_LEFT的情况下都执行LL
        if(leftBalanceFactor === BlanceFactor.BALANCED || leftBalanceFactor === BlanceFactor.SLIGHTLY_UNBALANCED_LEFT){
            return this.rotationLL(node)
        } else {
            // 左子树在的SLIGHTLY_UNBALANCED_RIGHT情况下都执行LL
            return this.rotationLR(node)
        }
    }
    if(balanceFactor === BlanceFactor.UNBALANCED_RIGHT){
        const rightBalanceFactor = this.getBalanceFactor(node.right)
        if(leftBalanceFactor === BlanceFactor.BALANCED || leftBalanceFactor === BlanceFactor.SLIGHTLY_UNBALANCED_RIGHT){
            return this.rotationRR(node)
        } else {
            return this.rotationRL(node)
        }
    }
    return node
}
```



# 红黑树

> ### 定义：
>
> 红黑树是一个自平衡二叉树。
>
> ### 效率：
>
> 红黑树保证了最坏情形下在 `O(logn)`时间复杂度内完成**查找、插入及删除**操作；
>
> ### 对比：
>
> 如果包含多次插入和删除的自平衡树，红黑树性能比较好的。如果插入和删除频率比较低，需要多次进行搜索操作，`AVL`树比红黑树更好。
>
> ### 红黑树遵循规则：
>
> 1. 每个节点不是红色就是黑色（红或黑）
> 2. 树的根节点必定是黑色（根为黑）
> 3. 所有的叶子节点都是空节点（即`null`），并且是黑色（叶子为黑）
> 4. 如果一个节点是红色，那么它的两个子节点都是黑色（遇红变黑）
> 5. 从**任一节点**到其**子树中每个叶子节点的路径**都**包含相同数量的黑色节点**（黑高一致）
>
> 性质`4`和性质`5`确保了任意节点到其每个叶子节点路径中最长路径不会超过最短路径的`2`倍，即一颗树是黑红节点相间的树，另一颗全是黑节点的树；也就是红黑树是相对黑色节点的平衡二叉树
>
> ### 术语：
>
> 黑色高度：如果我们从根节点出发到每个叶子节点的路径都**包含相同数量的黑色节点**，这个黑色节点的数量被称为**树的黑色高度**。**树的黑色高度**和**节点的黑色高度**是不一样的。

> ### 定义`Colors`对象管理两种颜色

```javascript
//utils.js
const Colors = {
	RED: {
		isRed: () => true,
        isBlack: () => false,
        color: 'red'
	},
	BLACK: {
		isRed: () => false,
        isBlack: () => true,
        color: 'black'
	}
}
module.exports = {
    Colors
} 
```

> ### 定义`RedBlackNode`类作为节点

```javascript
//redBlackNode.js
const { Colors } = require('./utils')
module.exports = class RedBlackNode {
    key = null
	parent = null		// 存储对父类的引用
	color = Colors.RED	// 存储节点颜色颜色
	constructor(key) {
        this.key = key	//键值
    }
}
```

> ### 定义`RedBlackTree`类的基本结构

```javascript
const RedBlackNode = require('./redBlackNode')
const { Colors, Compare, defaultCompare } = require('./utils')
class RedBlackTree {
    root = null
	compareFn = null
	constructor(compareFn = defaultCompare) {
        this.compareFn = compareFn
    }
}
```

> ### 定义`insert(key)`方法，对插入节点进行分流

```javascript
function insert(key) {
    //如果根节点还没有被插入，直接插入根节点
	if (this.root = null) {
        this.root = new RedBlackNode(key)
        //root节点必须是黑色节点
        this.root.color = Colors.BLACK
        //根节点已经插入的情况下，调用insertNode进行分流
    } else {
        //返回新插入的节点
        const newNode = this.insertNode(this.root)
        //根据返回节点的父节点、叔节点、祖父节点进行调整（变色、旋转）
        this.fixTreeProperties(newNode)
    }
}
```

> ### 定义`insertNode(node, key)`方法，对待插入的节点进行进一步分流

```javascript
function insertNode(node, key) {
    if(compareFn(key, node.key) === Compare.LESS_THAN) {
        if(node.left === null){
			node.left = new RedBlackNode(key)
            node.left.parent = node
            return node.left
        } else {
            return insertNode(node.left, key)
        }
    }
    if(compareFn(key, node.key) === Compare.BIGGER_THAN) {
        if(node.right === null){
            node.right = new RedBlackNode(key)
            node.right.parent = node
            return node.right
        } else {
            return insertNode(node.right, key)
        }
    }
}
```

> ### 定义`fixTreeProperties(node)`以插入节点为起点进行操作

```javascript
function fixTreeProperties(node) {
    while(node && node.parent && node.color.isRed() && node.parent.color.isRed()) {
        let parent = node.parent					//获取父元素
        const grandParent = node.parent.parent		//获取祖父元素
        if (grandParent && grandParent.left === parent) {  //父节点在祖父节点左侧
            const uncle = node.right
            if (uncle && uncle.color.isRed()) {
                grandParent.color = Colors.RED
                parent.color = Colors.Black
                uncle.color = Colors.Black
                node = grandParent
            } else {
                if (parent.right === node) {
                    this.rotationRR(parent)
                    node = parent
                    parent = node.parent
                } else {
                    this.rotationLL(grandParent)
                    parent = Colors.BLACK
                    grandParent = Colors.RED
                    node = parent
                }
            }
        } else {  //父节点在祖父节点右侧
            const uncle = node.left
            if (uncle && uncle.color.isRed()) {
                grandParent.color = Colors.RED
                parent.color = Colors.Black
                uncle.color = Colors.Black
                node = grandParent
            } else {
                if (parent.left === node) {
                    this.rotationLL(parent)
                    node = parent
                    parent = node.parent
                } else {
                    this.rotationRR(grandParent)
                    parent = Colors.BLACK
                    grandParent = Colors.RED
                    node = parent		
                    //完成一次rotationRR(grandParent)操作之后就达到了平衡
                    //设置为parent的目的是在下一次主动退出while循环
                }
            }
        }
    }
}
```

> ### 定义`rotationRR(node)、rotationLL(node)`方法旋转节点

```javascript
function rotationLL(node) {
    const temp = node.left
    node.left = temp.right
    if(temp.right) temp.right.parent = node
    temp.parent = node.parent
    if(!node.parent) {
        this.root = temp
    } else {
        if(node === node.parent.left) {
            node.parent.left = temp
        } else {
            node.parent.right = temp 
        }
    }
    temp.right = node
    node.parent = temp
}

function rotationRR(node) {
    const temp = node.right
    node.right = temp.left
    if(temp.left) temp.left.parent = node
    temp.parent = node.parent
    if(!node.parent) {
        this.root = temp
    } else {
        if(node === node.parent.right) {
            node.parent.right = temp
        } else {
            node.parent.left = temp 
        }
    }
    temp.left = node
    node.parent = temp
}
```

# 链表

> 数组的缺点：（在大多数语言中）数组的大小是固定的，从数组的七点或者中间插入或者移除元素的成本非常高。
>
> 链表：链表存储有序的元素集合，但不同于数组，链表中的元素在内存中不是连续放置的。每个元素由一个存储元素本身的节点和指向下一个元素的引用（指针）组成。
>
> 链表的好处：相对于传统的数组，链表的一个好处在于，添加或者删除元素的时候不需要移动其他元素。
>
> 链表的缺点：在数组中我们可以直接访问任何位置的任何元素，而想要访问链表中间的一个元素，需要从表头开始迭代链表直到找到所需要的元素。

## 普通链表

### 创建元素校验函数

```javascript
const defaultEqual = (a, b) => Object.is(a, b)
```

### 创建节点

```javascript
class Node {
	next = null
	constructor() {
        this.element = element 
    }
}
```

### 创建链表基本结构

```javascript
const {defaultEqual} = require('./utils')
const Node = require('./node')
class LinkedList {
	//用于比较传入element是否与节点elment一致的比较函数，默认使用Object.is(a, b)，可以通过构造函数传入指定方法，这里固定使用了默认方法
    equalFn = defaultEqual
	//指向链首的指针
	head = null
	//计算总的节点个数
	count = 0 
}
```

### 创建插入节点到末尾方法`push`

```javascript
function push(element) {
    //情形A：链头为空
    if (!this.head) {
        this.head = new Node(element)
        this.count += 1
        return this.head
    }

    //情形B：链头不为空
    let cur = this.head
    while (cur.next !== null) {
        cur = cur.next
    }
    cur.next = new Node(element)
    this.count += 1
    return cur.next
}
```

### 获取指定索引位置的元素`getElementAt`

```javascript
function getElementAt(index) {
    //边界条件，索引过小或者索引过大
    if (index < 0 || index >= this.count) return null
    //遍历链表获得指定索引节点
    let cur = this.head
    while (index--) {
        cur = cur.next
    }
    return cur
}
```

### 移除指定索引位置的元素`removeAt`

```javascript
function removeAt() {
    //边界条件，索引过小或过大（大于链尾索引）
    if (index < 0 || index >= this.count) return null

    //情形A：移除链首，考虑变更this.head
    if (index === 0) {
        const cur = this.head
        this.head = this.head.next
        this.count--
        return cur
    }

    //情形B：移除非链首
    const prev = this.getElementAt(index - 1)
    const cur = prev.next
    prev.next = cur.next
    this.count--
    return cur
}
```

### 指定位置插入元素`insert`

```javascript
function insert(element, index) {
    //边界条件，索引过小或过大（不得大于链尾索引 + 1）
    if (index < 0 || index > this.count) return null


    //情形A：插入链首
    if (index === 0) {
        const prev = this.head
        const node = new Node(element)
        this.head = node
        node.next = prev
        this.count++
        return node
    }

    //情形C：插入链中 or 链尾
    const prev = this.getElementAt(index - 1)
    const node = new Node(element)
    const cur = prev.next  //index = this.count的情况下，cur是null
    prev.next = node
    node.next = cur
    this.count++
    return node
}
```

### 获取目标元素的索引`IndexOf`

```javascript
function IndexOf(element) {
    //情形A：元素为空，直接返回-1
    if (!this.count) return -1

    //情形B：元素不为空，需要进行遍历
    let cur = this.head
    let index = 0
    while (index < this.count) {
        //当找到对应元素时返回对应索引
        if (this.equalFn(element, cur.element)) return index
        cur = cur.next
        index += 1
    }
    return -1
}
```

### 移除指定元素`remove`

```javascript
function remove(element) {
    const index = this.indexOf(element)
    if (~index) return this.removeAt(index)
    return null
}
```

### 获取链表长度`size`、获取链表头`getHead`、获取链表是否为空`isEmpty`、获取链表数组`toArr`

```javascript
function toArr() {
    let cur = this.head
    let elements = []
    while (cur !== null) {
        elements.push(cur.element)
        cur = cur.next
    }
    return elements
}

function size() {
    return this.count
}

function isEmpty() {
    return this.count === 0
}

function getHead() {
    return this.head
}
```

## 双向链表

### 创建双向链表节点

```javascript
class DoublyNode {
	prev = null
	next = null
	constructor(element) {
        this.element = element
    }	
}
```

### 创建双向链表基本结构

```javascript
const {defaultEqual} = require('./utils')	//元素查询比较函数
const DoublyNode = require('./doublyNode')	//双向链表节点
const LinkedList = require('./likedlist')	//链表类（不涉及节点增删插的操作可以被继承）

class DoubliLinkedList extends LinkedList {
    head = null
	tail = null
	equalFn = defaultEqual
	push(element){/**/}
	insert(element, index){/**/}
	removeAt(index){/**/}
	//其余方法都可以继承
}
```

### 覆写`push`方法

```javascript
function push(element) {
    const node = new DoublyNode(element) //创建新节点

    //情形A：head为空（链表内不存在任何节点），插入节点并将this.head和this.tail都指向它
    if (!this.head) {
        this.head = node
        node.prev = null
        this.tail = node
        this.count += 1
        return node
    }

    //情形B：head不为空，插入节点到链尾（注意将this.tail指向新的节点）
    let cur = this.head
    while (cur.next !== null) {
        cur = cur.next
    }
    cur.next = node
    node.prev = cur
    this.tail = node
    this.count += 1
    return node
}
```

### 覆写`insert`方法

```javascript
function insert(element, index) {
    //边界条件，索引过小（<0）或索引大于最大可插入索引（最大可插入索引是链尾元素索引 + 1：this.count - 1 + 1）
    if (index < 0 || index > this.count) return null

    //情形A：插入链头，需要额外更新this.head
    if (index === 0) {
        const prevHead = this.head
        const node = new DoublyNode(element)
        this.head = node
        node.prev = null
        node.next = prevHead
        prevHead.prev = node
        this.count++
        return this.head
    }

    //情形B：插入链中/链尾
    const prev = this.getElementAt(index - 1)
    const cur = prev.next	//index = this.count的情况下，cur为null
    const node = new DoublyNode(element)
    prev.next = node
    node.prev = prev
    node.next = cur
    //以下分为两种情况：插入的位置是null节点（相当于插入到链尾节点的next，成为新的链尾节点） & 插入的位置是链中
    if(cur === null) {
        //成为链尾，更新this.tail
        this.tail = node
    } else {
        //插入链中，更新后继节点的前驱指针
        cur.prev = node
    }
    this.count++
    return node
}
```

### 覆写`removeAt`方法

```javascript
removeAt(index) {
    //边界条件：移除元素的索引过小，或者过大（超过链尾索引）
    if (index < 0 || index >= this.count) return null

    //情形A：移除链首元素（还需要考虑是否同时是链尾元素）
    if (index === 0) {
        const cur = this.head
        this.head = this.head.next
        //情形A1：链表仅一个链首元素，还需要将this.tail置空
        if (this.count === 1) {
            this.tail = null
        } else {
            //情形A2：链首还有后继元素，将后继元素的prev置为null即可（代表表头）
            this.head.prev = null
        }
        this.count--
        return cur
    }

    //情形B：移除的元素索引是链尾索引，需要额外处理this.tail
    if (index === this.count - 1) {
        const cur = this.tail
        this.tail = cur.prev
        this.tail.next = null
        this.count--
        return cur
    }

    //情形C：移除的元素是链中索引
    const prev = this.getElementAt(index - 1)
    const cur = prev.next
    prev.next = cur.next
    cur.next.prev = prev
    this.count--
    return cur
}
```

## 循环链表

### 创建循环链表的基本结构

```js
const Node = require('./node')
const {defaultEqual} = require('./utils')
const LinkedList = require('./likedlist')

class CircularLinkedList extends LinkedList{
    equalFn = defaultEqual
    push(element){/**/}
    insert(element, index){/**/}
    removeAt(index){/**/}
//其余方法都可以继承
}
```

### 覆写`push`方法

```javascript
function push(element) {
    //情形A：链头为空
    if (!this.head) {
        this.head = new Node(element)
        //将新插入链尾的节点next指向this.head
        this.head.next = this.head
        this.count += 1
        return this.head
    }

    //情形B：链头不为空
    const node = new Node(element)
    let cur = this.head
    while (cur.next !== this.head) {
        cur = cur.next
    }
    cur.next = node
    //将新插入链尾的节点next指向this.head
    node.next = this.head
    this.count += 1
    return cur.next
}
```

### 覆写`insert`方法

```javascript
function insert(element, index) {
    //边界条件，索引过小或过大（不得大于链尾索引 + 1）
    if (index < 0 || index > this.count) return null

    //情形A：插入链首
    if (index === 0) {
        const tail = this.getElementAt(this.size() - 1)
        const prev = this.head
        this.head = new Node(element)
        tail.next = this.head
        this.head.next = prev
        this.count++
        return true
    }

    //情形B：插入链中/链尾
    const node = new Node(element)
    const prev = this.getElementAt(index - 1)
    const cur = prev.next
    prev.next = node
    if(cur === null){
        //B1:链尾情况
        node.next = this.head
    } else {
        //B2：链中情况
        node.next = cur
    }
    this.count++
    return true
}
```

### 覆写`removeAt`方法

```javascript
function removeAt(index) {
    //边界条件，索引过小或过大（大于链尾索引）
    if (index < 0 || index >= this.count) return null

    //情形A：移除链首，考虑变更this.head
    if (index === 0) {
        const cur = this.head
        this.head = this.head.next
        this.count--
        return cur
    }

    //情形B：移除非链首
    const prev = this.getElementAt(index - 1)
    const cur = prev.next
    //情形B1：移除链尾元素，需要修改链尾的next为this.head
    if (index === this.count - 1) {
        prev.next = this.head
    } else {
        //情形B2：移除元素非链尾
        prev.next = cur.next
    }
    this.count--
    return cur
}
```

## 排序链表

### 创建对比方法和结果表

```javascript
const defaultCompare = (a, b) => a === b ? 0 : a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN
const Compare = {
    LESS_THAN: -1,
    BIGGER_THAN: 1
}
```

### 创建排序链表基本结构

```javascript
const LinkedList = require('./likedlist')
const {Compare, defaultEqual, defaultCompare} = require('./utils')
class SortedLinkedList extends LinkedList {
    comapreFn = defaultCompare
	equalFn = defaultEqual
	push() {/**/}
	insert() {/**/}
	getIndexNextSortedElement() {/**/}
	//其他方法可以复用
}
```

### 创建`getIndexNextSortedElement`用于获取节点插入位置

```javascript
function getIndexNextSortedElement(element) {
    if (this.isEmpty()) return 0
    let cur = this.head
    let index = 0
    for (; index <= this.size() - 1; index++) {
        const comp = this.compareFn(element, cur.element)
        if (comp === Compare.LESS_THAN) {
            return index
        }
        cur = cur.next
    }
    return index
}
```

### 覆写`push`方法

```javascript
function push(element) {
    if (this.isEmpty()) {
        return super.push(element)
    }
    const index = this.getIndexNextSortedElement(element)
    return super.insert(element, index)
}
```

### 覆写`insert`方法

```javascript
function insert(element, index = 0) {
    if (this.isEmpty()) {
        return super.insert(element, 0)
    }
    const pos = this.getIndexNextSortedElement(element)
    return super.insert(element, pos)
}
```

# 集合

> **集合**是由一组无需且唯一（即不能重复）的数据结构组成。

## 创建集合

```javascript
class MySet {
    items = []

    add(element) {
        if (!this.has(element)) this.items.push(element)
    }

    delete(element) {
        for (let i = 0; i < this.items.length; i++) {
            if (Object.is(element, this.items[i])) return this.items.splice(i, 1)
        }
    }

    has(element) {
        return this.items.includes(element)
    }

    clear() {
        this.items = []
    }

    size() {
        return this.items.length
    }

    values() {
        return this.items.slice()
    }
}

```

## `TS`版本（带交、并、补、差集）

```typescript
class MySet {
    items: any[] = []
    duplicated: Symbol = Symbol()
    nodeFound: Symbol = Symbol()

    add<T>(element: T): (Symbol | T) {
        if (!this.has(element)) {
            this.items.push(element)
            return element
        }
        return this.duplicated
    }

    delete<T>(element: T): (T | Symbol) {
        for (let i = 0; i < this.items.length; i++) {
            if (Object.is(element, this.items[i])) {
                return this.items.splice(i, 1)[0]
            }
        }
        return this.nodeFound
    }

    has(element: any): boolean {
        return this.items.includes(element)
    }

    clear(): void {
        this.items = []
    }

    size(): number {
        return this.items.length
    }

    values(): any[] {
        return this.items.slice()
    }

    union(otherSet: MySet): MySet {
        const set = new MySet()
        otherSet.values().forEach(set.add.bind(set))
        this.values().forEach(set.add.bind(set))
        return set
    }

    intersection(otherSet: MySet): MySet {
        const ret = new MySet()
        otherSet.values().forEach(value => {
            if (this.items.includes(value)) ret.add(value)
        })
        return ret
    }

    difference(otherSet: MySet): MySet {
        const ret = new MySet()
        this.values().forEach(value => {
            if (!otherSet.values().includes(value)) ret.add(value)
        })
        return ret
    }

    antiIntersection(otherSet: MySet): MySet {
        return otherSet.union(this).difference(otherSet.intersection(this))
    }

    isSubsetOf(otherSet: MySet): boolean {
        return this.difference(otherSet).size() === 0
    }
}
```

## 使用`ES6-Set`

```javascript
Set.prototype.union = function (otherSet) {
    if (!(otherSet instanceof Set)) throw new TypeError('must union the Set type')
    return new Set([...this, ...otherSet])
}

Set.prototype.intersection = function (otherSet) {
    const ret = new Set()
    this.forEach(value => {
        if (otherSet.has(value)) ret.add(value)
    })
    return ret
}

Set.prototype.difference = function (otherSet) {
    const ret = new Set()
    this.forEach(value => {
        if (!otherSet.has(value)) ret.add(value)
    })
    return ret
}

Set.prototype.antiIntersection = function (otherSet) {
    return this.union(otherSet).difference(this.intersection(otherSet))
}

Set.prototype.isSubsetOf = function (otherSet) {
    return [...this.difference(otherSet)].length === 0
}
```

# 字典

> 字典是以`[键， 值]`的形式来存储元素，字典也称作映射、符号表或关联数组。
>
> 目前`ES2015`的`Map`类原生实现了字典的数据结构。

# 散列表

> `HashTable`类（也叫做`HashMap`类），它是`Dictionary`类的一种散列表实现方式。
>
> 散列算法的作用是尽可能快地在数据结构中找到一个值。散列表无需进行迭代来获取某个具体数据，而是使用散列函数获取值的具体位置并快速检索到该值（散列函数的作用是给定一个键值，然后返回值在表中的地址）。

# 二叉堆

> 二叉堆是一种特殊的完全二叉树，有以下两个特性：
>
> - 结构特性：它是一颗完全二叉树，表示树的**每一层有左侧和右侧子节点**（除了最后一层的叶节点），并且**最后一层的叶节点尽可能都是左侧子节点**。
> - 堆特性：二叉堆**不是最小堆就是最大堆**。最小堆允许你快速导出堆的最小值，最大堆允许你快速导出堆的最大值。所有的节点都大于等于（最大堆）或小于等于每个它的子节点。
>
> 二叉堆与二叉搜索树的区别与联系：
>
> 尽管二叉堆是二叉树，但并不一定是二叉搜索树（BST）。在二叉堆中，每个子节点都要大于等于父节点或小于（最小堆）等于父节点（最大堆）。然而在二叉搜索树中，左侧子节点总是比父节点小，右侧子节点也总是更大。
>
> ### 时间复杂度：
>
> 大小为`K`的堆中插入元素的时间复杂度为`O(logK)`
>
> 大小为`K`的堆中删除元素的时间复杂度为`O(logK)`
>
> 最大（小）堆中获取最大（小）值的时间复杂度为`O(1)`

## 二叉堆类

```javascript
const defaultCompare = (a, b) => a - b > 0 ? Compare.BIGGER_THAN : a - b < 0 ? Compare.LESS_THAN : Compare.EQUALS

const Compare = {
    LESS_THAN: -1,
    BIGGER_THAN: 1,
    EQUALS: 0
}
```

```javascript
const {Compare, defaultCompare} = require('./utils')

class MaxHeap {
    heap = []

    constructor(compareFn = defaultCompare) {
        this.compareFn = compareFn
    }

    swap(arr, i1, i2) {
        const temp = arr[i1]
        arr[i1] = arr[i2]
        arr[i2] = temp
    }

    getLeftIndex(index) {
        return 2 * index + 1
    }

    getRightIndex(index) {
        return 2 * index + 2
    }

    getParentIndex(index) {
        return (index - 1) >> 1
    }

    insert(value) {
        if (value ?? false) {
            this.heap.push(value)
            this.shiftUp(this.heap.length - 1)
            return true
        }
        return false
    }

    shiftUp(index) {
        if (index <= 0) return
        let parent = this.getParentIndex(index)
        //这里使用while来提升性能，也可以使用递归
        while (index > 0 && this.compareFn(this.heap[index], this.heap[parent]) === Compare.BIGGER_THAN) {
            this.swap(this.heap, index, parent)
            index = parent
            parent = this.getParentIndex(parent)
        }
    }

    shiftDown(index) {
        let left = this.getLeftIndex(index)
        let right = this.getRightIndex(index)
        const size = this.size()
        if (left < size && this.compareFn(this.heap[index], this.heap[left]) === Compare.LESS_THAN) {
            this.swap(this.heap, index, left)
            this.shiftDown(left)
        }
        if (right < size && this.compareFn(this.heap[index], this.heap[right]) === Compare.LESS_THAN) {
            this.swap(this.heap, index, right)
            this.shiftDown(right)
        }
    }

    extract() {
        if (this.isEmpty()) return undefined
        if (this.size() === 1) return this.heap.unshift()
        const removedVal = this.heap[0]
        this.heap[0] = this.heap.pop()
        this.shiftDown(0)
        return removedVal
    }

    findMinimum() {
        return this.heap[0]
    }

    size() {
        return this.heap.length
    }

    isEmpty() {
        return this.heap.length === 0
    }
}
```

## 数组二叉堆化

```javascript
MaxHeap.buildMaxHeapOnOrigin = (array, compareFn = defaultCompare) => {
    for (let index = Math.floor(array.length / 2 - 1); index >= 0; index--) {
        MaxHeap.heapify(array, index, compareFn)
    }
    return array
}

MaxHeap.heapify = (array, index, compareFn = defaultCompare) => {
    const length = array.length
    const left = (2 * index) + 1
    const right = (2 * index) + 2
    if (left < length && compareFn(array[index], array[left]) === Compare.LESS_THAN) {
        MaxHeap.swapElement(array, index, left)
        MaxHeap.heapify(array, left, compareFn)
    }
    if (right < length && compareFn(array[index], array[right]) === Compare.LESS_THAN) {
        MaxHeap.swapElement(array, index, right)
        MaxHeap.heapify(array, right, compareFn)
    }
}

MaxHeap.swapElement = (array, i1, i2) => void ([array[i1], array[i2]] = [array[i2], array[i1]])
```

## 堆排序

```javascript
const {defaultCompare} = require('./utils')
const {buildMaxHeapOnOrigin, swapElement, heapify} = require('./maxHeap')
function heapSort(array, compareFn = defaultCompare) {
    let heapSize = array.length
    buildMaxHeapOnOrigin(array, compareFn)
    while (heapSize > 1) {
        heapSize -= 1
        swapElement(array, 0, heapSize)
        heapify(array, 0, compareFn)
    }
}
```



# 图

> ### 术语
>
> - 相邻顶点
>   - 由一条边连接在一起的顶点
> - 顶点的度
>   - 顶点的相邻顶点的数量
> - 路径
>   - 顶点v1，v2，··· 的一个连续序列
> - 简单路径
>   - 路径不包含重复的顶点
> - 无环图
> - 连通图
>   - 如果图中每两个顶点之间都存在路径，则该图是连通的
> - 有向图和无向图
> - 强连通图
>   - 不同两点之间必定存在双向的路径
> - 加权图

> ### 图的表示方式
>
> - 邻接矩阵
>   - 不适合非强连通图
>   - 找出两节点是否相邻非常方便
>   - 每一列代表点，每一行也代表点
> - 邻接表
>   - 找出节点的所有相邻节点非常方便
> - 关联矩阵
>   - 通常用于点的数量比边的数量多的情况，以节省内存
>   - 每一行代表一个点，每一列代表一个行

> ### 图的广度优先搜索
>
> 图的广度优先搜索会从指定源顶点开始逐层遍历整个图，故其优先访问顶点的**<u>所有</u>**的邻接点。（使用队列）
>
> ### 图的深度优先搜索
>
> 图的深度优先搜索会从指定源顶点开始优先深度访问遍历整个图，故其优先访问**<u>更深层次</u>**的节点。（使用栈/递归）
>
> ### 拓扑排序
>
> 使用深度优先搜索标记节点的到访和探索完毕顺序，并根据到访完毕顺序进行降序排序得到<u>**执行顺序**</u>
>
> ### Dijkstra算法
>
> Dijkstra是一种计算**单个源**到**所有其他源的最短路径**的贪心算法
>
> ### Floyd-Warshall算法
>
> Floyd-Warshall算法是一种计算机图中**所有顶点到其他顶点的最短路径**的动态规划算法
>
> ### Prim(点)
>
> 一种求解**加权无向连通图**的最小生成树算法，适合**点少边多**的情况，`Prim`算法以某顶点为起点，逐步找各顶点上最小权值的边构建最小生成树，同时其邻接点纳入生成树的顶点中，只要保证顶点不重复添加即可。
>
> ### Kruskal(边)
>
> 一种求解**加权无向连通图**的最小生成树算法，适合**点多边少**的情况，`Kruskal`遍历所有的边，按权值从小到大排序，每次选取当前权值最小的边，只要不构成回环，则加入生成树。

# 排序算法 

## 参考资料

[排序算法](https://juejin.cn/post/6844903444365443080)

## 术语

### 稳定性：

稳定：如果`A`原本在`B`前面，而`A === B`，排序之后`A`仍然在`b`的前面； 

不稳定：如果A原本在B的前面，而`A === B`，排序之后`A`可能会出现在`B`的后面；

### 排序方式：

内排序：所有排序操作都在内存中完成；

外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

### 时间复杂度

### 空间复杂度

## 排序算法比较

| 排序算法                                                | 平均时间复杂度 | 最好情况       | 最坏情况     | 空间复杂度               | 排序方式                  | 稳定性 |
| ------------------------------------------------------- | -------------- | -------------- | ------------ | ------------------------ | ------------------------- | ------ |
| 冒泡排序                                                | O(n^2)         | 优化之后为O(n) | O(n^2)       | O(1)                     | 内排序                    | 稳定   |
| 选择排序                                                | O(n^2)         | O(n^2)         | O(n^2)       | O(1)                     | 内排序                    | 不稳定 |
| 插入排序                                                | O(n^2)         | O(n)           | O(n^2)       | O(1)                     | 内排序                    | 稳定   |
| 归并排序                                                | O(nlogn)       | O(nlogn)       | O(nlogn)     | O(n)                     | 外排序                    | 稳定   |
| 快速排序                                                | O(nlogn)       | O(nlogn)       | O(n^2)       | O(1) ~ O(logn)           | 内排序/外排序             | 不稳定 |
| 计数排序                                                | O(n+k)         | O(n+k)         | O(n+k)       | O(k)                     | 外排序                    | 稳定   |
| 桶排序                                                  | O(n+k)         | O(n)           | O(n^2)       | O(n+m)                   | 外排序                    | 稳定   |
| [基数排序](https://segmentfault.com/a/1190000013986116) | O(n*k)         | O(n*k)         | O(n*k)       | O(n+k)                   | 外排序                    | 稳定   |
| 堆排序                                                  | O(nlogn)       | O(nlogn)       | O(nlogn)     | O(1) **(in-place heap)** | 内排序**(in-place heap)** | 不稳定 |
| 希尔排序                                                | O(nlogn)       | O(n(logn)^2)   | O(n(logn)^2) | O(1)                     | 内排序                    | 不稳定 |

## 冒泡排序

```javascript
function bubble_sort(array) {
    const { length } = array
    for(let i = 0; i < length; i++) {
        let swapped = false 
        for(let j = 0; j < length - 1 - i; j++) {
            if(array[j] > array[j + 1]) {
                [array[j], array[j + 1]] = [array[j + 1], array[j]]
                swapped = true
            }
        }
        if(!swapped) return array
    }
}
```

## 选择排序

Q:选择排序为什么是不稳定的？

A:选择排序的交换破坏了稳定性。考虑：`[2, 2, 1] -> [1, 2, 2]`，这里的`2`和`2`之间的原有顺序被打破。

Q:选择排序为什么最好的情况下也是`O(n^2)`？

A:因为选择排序每一轮必须将剩余元素进行完整的比较并选择最小（最大）元素进入固定位置。如果发现`array[i]`没有交换的必要，也只代表原`array[i]`所在的位置已经是剩余子数组最小的元素，其余元素无法确定有序性。

```javascript
function selectionSort(array) {
    const { length } = array
    for(let i = 0; i < length - 1; i++){
        let min = array[i]
        let minIndex = i
        for(let j = i + 1; j < length; j++) {
            if(array[j] < min) {
                min = array[j]
                minIndex = j
            }
        }
        minIndex !== i && [array[minIndex], array[i]] = [array[i], array[minIndex]]
    }
    return array
}
```

## 插入排序

Q:为什么插入排序的最好时间复杂度是`O(n)`？

A:因为进入`while`的条件是固定位元素比有序元素大（无需进行插入），而当数组已经是有序的情况下，永远不会进入`while`循环，这就导致了时间复杂度成为`O(n)`。

Q:为什么插入排序是稳定的排序？

A:因为相同的元素在进行插入排序的时候，顺序还是会被保持，先访问到的元素先插入，后者则被插入在后方，这样顺序就没有产生变化。

```javascript
function insertingSort(array) {
    const {length} = array
    for(let i = 1; i < length; i++) {
        let j = i
        const temp = array[i]
        while(j > 0 && temp < array[j - 1]) {
			array[j] = array[j - 1]
			j -= 1
		}
        array[j] = temp
    }
    return array
}
```

## 归并排序

Q:归并排序为什么是稳定排序？

A:见注释

```javascript
function mergeSort(array) {
    const { length } = array
    function merge(left, right) {
        let l = 0
        let r = 0
        const ret = []
        while(l < left.length && r < right.length) {
            //稳定性的关键位置：
            //如果left[l] <= right[r]就将left[l++]加入合并数组，确保了左侧的优先进入数组
            //这样遵循了在拆分数组的时元素的分布位置
            //如果使用left[l] < right[r]则会破坏稳定性
            ret.push(left[l] <= right[r] ? left[l++] : right[r++]) 
        }
        ret.push(...(l < left.length ? left.slice(l) : right.slice(r)))
        return ret
    }
    if(length > 1) {
        const mid = Math.floor(length / 2)
        const left = mergeSort(array.slice(0, mid))
        const right = mergeSort(array.slice(mid, length))
        array = merge(left, right)
    }
    return array
}
```

## 快速排序

Q:为什么快速排序是不稳定的排序？

A:快速排序的交换机制并不能保证相同元素的位置在交换之后保持一致。

```javascript
function fastSort(array) {

    function quick(array, left, right) {
        if (array.length > 1) {
            const j = partition(array, left, right)
            const i = j - 1
            if (left < i) quick(array, left, i)
            if (right > j) quick(array, j, right)
        }
        return array
    }

    function partition(array, left, right) {
        const pivot = array[Math.floor((left + right) / 2)]
        while (left <= right) {
            while (array[left] < pivot) {
                left++
            }
            while (array[right] > pivot) {
                right--
            }
            if (left <= right) {
                array.swap(left, right)
                left++
                right--
            }
        }
        return left
    }

    return quick(array, 0, array.length - 1)
}
```

## 堆排序

```javascript
function heapSort(array) {
    const getParentIndex = index => Math.floor((index - 1) / 2)
    const getLeftIndex = index => index * 2 + 1
    const getRightIndex = index => index * 2 + 2
    //shiftUp的时间复杂度为log(n)
    const shiftUp = (array, index) => {
        //索引所在为位置为根节点时无需替换
        if (index === 0) return
        let parent = getParentIndex(index)
        while (true) {
            if (array[index] < array[parent]) {
                //需要和父元素进行交换
                [array[index], array[parent]] = [array[parent], array[index]]
                index = parent
                if (index === 0) return void 0
                parent = getParentIndex(index)
            } else {
                //无需和父元素进行交换
                return void 0
            }
        }
    }
    //shiftDown的时间复杂度为log(n)
    const shiftDown = (array, index) => {
        const {length} = array
        let left = getLeftIndex(index)
        let right = getRightIndex(index)
        if (left < length && array[index] > array[left]) {
            [array[index], array[left]] = [array[left], array[index]]
            shiftDown(array, left)
        }
        if (right < length && array[index] > array[right]) {
            [array[index], array[right]] = [array[right], array[index]]
            shiftDown(array, right)
        }
        return array
    }

    function buildHeap(array) {
        const heap = []
        array.forEach((e) => {
            heap.push(e)
            shiftUp(heap, heap.length - 1)
        })
        return heap
    }

    function getRoot(heap) {
        //易错点：忘记heap.length === 1的情况下应当:
        //直接移除堆顶元素而不再将heap.pop()赋值给heap[0]进入shiftDown操作
        if (heap.length === 1) return heap.shift()
        const ret = heap[0]
        heap[0] = heap.pop()
        shiftDown(heap, 0)
        return ret
    }

    const heap = buildHeap(array)
    const ret = []
    //每次取出堆顶的最小元素，时间复杂度为n
    while (heap.length) {
        ret.push(getRoot(heap))
    }
    return ret
}
```

## 计数排序

[计数排序及稳定性](https://zhuanlan.zhihu.com/p/26595385)

Q:计数排序的时间复杂度`O(n+k)`是什么含义？空间复杂度为什么是`O(k)`？

A:`n`代表数据的规模，`K`代表数据中的最大值，`n`次用于遍历数据数组生成计数数组，`k`次用于遍历计数数组生成排序结果。`k`是生成的计数数组的大小，所以其空间复杂度是`O(K)`。

```javascript
//不稳定版本，不使用原数组元素，直接使用 下标i + 元素数量countArr[i] 进行生成
function countingSort(array) {
    let max = Math.max(...array)
    const countArr = Array.from({length: max + 1})
    const ret = []
    array.forEach(e => {
        countArr[e] = countArr[e] ? (countArr[e] + 1) : 1
    })
    for(let i = 0; i < countArr.length; i++) {
        const length = countArr[i]??0 
        if(length) ret.push(...Array.from({length}).fill(i, 0, length))
    }
    return ret
}
//稳定版本 -> 计数排序的“稳定性”是理解基数排序的关键。
function countingSort(array) {
    //获取最大值 -> 作为计数数组的最大索引值
    let max = Math.max(...array)
    const ret = []
    //生成计数索引（易错点：length为max + 1）
    const countArr = Array.from({length: max + 1})
    //构建计数数组{ index(aka element) => count }
    array.forEach(e => {
        countArr[e] = countArr[e] ? (countArr[e] + 1) : 1
    })
    //改造计数数组为索引形式{ index(aka element a) => (the index of last element a + 1) }
    for(let i = 1; i < countArr.length; i++){
        countArr[i] += (countArr[i - 1]??0)
                        }
    //首先反向读取数组（因为countArr[index(aka element)])，为了先读取到末尾的相同元素
    //为什么先读取末尾？
    //countArr[]在经过（countArr[i] = countArr[i - 1]）的操作之后
    //每一个索引（也就是原数组中的元素值）对应的值是原数组（array）中该元素的等值末尾元素排序后所处的索引+1
    for(let i = array.length - 1; i >= 0; i--) {
        ret[countArr[array[i]] - 1] = array[i]
        countArr[array[i]] -= 1
    }
    for(let i = 0; i < ret.length; i++) {
        array[i] = ret[i]
    }
    return array
}
```

## 桶排序

Q:为什么桶排序最坏情况的时间复杂度是`O(n^2)`？为什么最好的情况下是`O(n)`？

A:当全部元素都**集中到一个桶中**的时候，时间复杂度会弱化到桶内的排序算法（通常是插入算法`O(n) - O(n^2)`）。当数组非常稀疏，稀疏到足以**每一个元素进入一个桶**，那么桶内无需进行排序，时间复杂度就是`O(n)`。

Q:为什么桶排序是稳定的排序？

A:桶排序中，相同元素会被分配到同一个桶中，并在桶中按照原有次序进行排序，不会破坏稳定性。

```javascript
function bucketSort(array, bucketSize = 5) {
    function createBuckets(array, bucketSize) {
        let minVal = array[0]
        let maxVal = array[0]
        const buckets = []
        array.forEach(e => {
            minVal = e < minVal ? e : minVal
            maxVal = e > maxVal ? e : maxVal
        })
        const bucketsCount = Math.floor(((maxVal - minVal) / bucketSize))
        for(let i = 0; i <= bucketsCount; i++) {
            buckets[i] = []
        }
        array.forEach(e => {
            const bucketIndex = Math.floor((e - minVal) / bucketSize)
            buckets[bucketIndex].push(e)
        })
        return buckets
    }
    function sortBuckets(buckets) {
        const ret = []
        buckets.forEach((bucket, index,array) => {
            //这里应当使用自定义的桶内排序方法
            if(bucket.length) array[index].sort((a, b) => (a - b))
            ret.push(...array[index])
        })
        return ret
    }
	if(array.length === 1) return array
    return sortBuckets(createBuckets(array, bucketSize))
}
```

## 基数排序

> 定义
>
> 基数排序的时间复杂度是![{\displaystyle O(k\cdot n)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/7efd17682e88bf7b780c4670152aab506e4578d4)，其中![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)是**排序元素个数**，![k](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40)是**数字位数**。注意这不是说这个时间复杂度一定优于![{\displaystyle O\left(n\cdot \log \left(n\right)\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a5b9aa5a52db86871db4f1853e2ee5822d0db395)，![k](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40)的大小取决于**数字位的选择**（比如比特位数），和**待排序数据所属数据类型的全集的大小**；![k](https://wikimedia.org/api/rest_v1/media/math/render/svg/c3c9a2c7b599b37105512c5d570edc034056dd40)决定了**进行多少轮处理**，而![n](https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b)是**每轮处理的操作数目**。基数排序法是属于稳定性的排序。

Q:为什么基数排序的空间复杂度是`O(n+k)`？

A:其中生成了`k`个桶，空间复杂度为`O(k)`，需要创建**临时数组**存储每一轮基数排序的结果，空间复杂度为`O(n)`，总的就是`O(n+k)`

```javascript
function radixSort(array, radixBase = 10) {
    function countingSortForRadixSort(array, radixBase, currentBit, minVal) {
        //时间复杂度n（元素个数）
        const buckets = []
        const ret = []
        for(let i = 0; i < radixBase; i++) {
            buckets[i] = 0
        }
        array.forEach(e => {
            const bucketIndex = Math.floor((e.val - minVal) / currentBit % radixBase)
            buckets[bucketIndex] += 1
        })
        for(let i = 1; i < radixBase; i++) {
            buckets[i] += buckets[i - 1]
        }
        //这里容易出错 -> array.length - 1
        for(let i = array.length - 1; i >= 0; i--) {
            const bucketIndex = Math.floor(((array[i].val - minVal) / currentBit) % radixBase)
            ret[--buckets[bucketIndex]] = array[i]
        }
        for(let i = 0; i < array.length; i++) {
			array[i] = ret[i]
        }
        return ret
    }
    if(array.length === 1) return array
    let minVal = array[0].val
    let maxVal = array[0].val
    array.forEach(e => {
        maxVal = e.val > maxVal ? e.val : maxVal
        minVal = e.val < minVal ? e.val : minVal
    })
    let currentBit = 1
    //时间复杂度K（位数）
    while(((maxVal - minVal) / currentBit) >= 1) {
        array = countingSortForRadixSort(array, radixBase, currentBit, minVal)
        currentBit *= radixBase
    }
    return array
}
```

## 希尔排序

```javascript
function shellSort(arr) {
    const { length } = arr
    let gap = 1
    while(gap < length / 3) {
        //(gap)的经验值是 (gap = gap * 3 + 1) && (gap < length / 3)
        gap = gap * 3 + 1
    }
    for(; gap > 0; gap = Math.floor(gap / 3)) {
        //对组内进行插入排序
        for(let i = gap; i < length; i++) {
            let temp = arr[i]
            let j = i - gap
            for(; j >= 0 && temp < arr[j]; j -= gap) {
                arr[j + gap] = arr[j]
            }
            arr[j + gap] = temp
        }
    }
    return arr
}
```

## 面试题：`Chrome V8`引擎的排序算法是怎样实现的？

[V8源码](https://github.com/v8/v8/blob/6504f4a18df46b82e4cf9f2782e70401beee1f38/src/js/array.js#L668)

`Chome V8`引擎采用两种排序算法：插入排序、`In-place`快速排序。在数组小于`<=10`的时候采用插入排序，否则采取快速排序。

# 搜索算法

## 二分搜索

```javascript
function binarySearch(array, value) {
    if (array.length === 0) return false
    if (array.length === 1) return (array[0] === value)
    const mid = Math.floor(array.length / 2)
    if (array[mid] === value) return true
    if (value > array[mid]) return binarySearch(array.slice(mid), value)
    if (value < array[mid]) return binarySearch(array.slice(0, mid), value)
}

function binarySearch2(array, value) {
    if (array.length === 0) return false
    let left = 0
    let right = array.length - 1
    let mid = Math.floor((right - left) / 2) + left
    while (left <= right) {
        if (array[mid] === value) return true
        if (value > array[mid]) {
            left = mid + 1
            mid = Math.floor((right + left) / 2) + left
        } else {
            right = mid - 1
            mid = Math.floor((right - left) / 2) + left
        }
    }
    return false
}
```

## 内插搜索

```javascript
const interpolationSearch = (array, value) => {
    const {length} = array
    let low = 0
    let high = length - 1
    let position = -1
    let delta = -1
    while (low < high) {
        delta = (value - array[low]) / (array[high] - array[low])
        position = low + Math.floor((high - low) * delta);
        if (array[position] === value) {
            return position
        }
        if (array[position] < value) {
            low = position + 1
        } else {
            high = position - 1
        }
    }
}
```

# 算法

## 动态规划`DP`



### 1.[`01`背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf)

#### 核心公式

$$
dp[i][j] = 
    \begin{cases}
        0, \quad i=0 \quad or \quad j=0\\[2ex]
        max(dp[i−1][j],dp[i−1][j−vw[i−1][0]]+vw[i−1][1]), \quad i>0 \quad and \quad j>0 \quad and \quad vw[i-1][1]<=j\\[2ex]
        dp[i−1][j], \quad i>0 \quad and \quad j>0 \quad and \quad vw[i-1][1]>j\\[2ex]
    \end{cases}
$$

```typescript
/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 计算01背包问题的结果
 * @param V int整型 背包的体积
 * @param n int整型 物品的个数
 * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
 * @return int整型
 */
export function knapsack(V: number, n: number, vw: number[][]): number {
    let dp: number[][] = []
    for(let i = 0; i <=n; i++) {
        dp[i] = []
    }
    for(let objIndex = 0; objIndex <= n; objIndex++) {
        for(let capacity = 0; capacity <= V; capacity++) {
            if(objIndex === 0 || capacity === 0) {
                dp[objIndex][capacity] = 0
            } else if(vw[objIndex - 1][0] > capacity) {    //当前物品重量大于小背包的重量，直接取上一个最大价值
                dp[objIndex][capacity] = dp[objIndex - 1][capacity]
            } else {    //当前物品重量小于等于小背包的重量，需要比较 上一个最大价值 <-> 剩余重量的最大价值
                dp[objIndex][capacity] = Math.max(dp[objIndex - 1][capacity], vw[objIndex - 1][1] + dp[objIndex - 1][capacity - vw[objIndex - 1][0]])
            }
        }
    }
    return dp[n][V]
}
```

### 2.[最长公共子串](https://leetcode-cn.com/problems/longest-common-subsequence/)

#### 核心公式

### ![image-20211218191625546](https://github.com/NoAlligator/pico/blob/main/img/202203271801403.png?raw=true)

![image.png](https://pic.leetcode-cn.com/1617411822-KhEKGw-image.png)

### 3.[零钱兑换最少硬币数](https://leetcode-cn.com/problems/coin-change/)

### 4.[零钱兑换方案总数](https://leetcode-cn.com/problems/coin-change-2/)

# 手写实现并查集

```javascript
class UnionSearchSet {

    constructor(n) {
        this.count = n  //集合总数
        this.parent = new Array(n)
        this.size = new Array(n)    //记录每棵树的重量
        this.elements = n
        for (let i = 0; i < n; i++) {
            this.parent[i] = i //自己是自己的parent
            this.size[i] = 1   //初始重量都是1
        }
    }

    //查找集合父亲
    find(p) {
        if (this.parent[p] === p) {
            return p
        } else {
            this.parent[p] = this.find(this.parent[p])
            return this.parent[p]
            // return this.find(parent[p]) //不压缩路径版本
        }
        // return (parent(p) === p) ? p : (parent[p] = this.find(parent[p]))  //简写版本
    }

    //查询节点之间的关系：是否位于同一集合
    relation(p, q) {
        return (this.find(p) === this.find(q))
    }

    //返回并查集集合总数
    sum() {
        return this.count
    }

    elements() {
        return this.elements
    }

    union(p, q) {
        if (p < 0 || p > this.elements - 1) return
        if (q < 0 || q > this.elements - 1) return
        let parentP = this.find(p)
        let parentQ = this.find(q)
        if (parentP === parentQ) return
        if (this.size[parentP] > this.size[parentQ]) {
            this.parent[parentQ] = parentP  //将parentQ的父亲设置为parentP
            this.size[parentP] += this.size[parentQ] //因为添加了一个parentQ，所以需要更新parentP的重量
        } else {
            this.parent[parentP] = parentQ
            this.size[parentQ] += this.size[parentP]
        }
        this.count -= 1
    }
}

const uss = new UnionSearchSet(20)
```

# 目录

第 1章　JavaScript简介　　1
1．1　JavaScript数据结构与算法　1
1．2　环境搭建　2
1．2．1　最简单的环境搭建　2
1．2．2　使用Web服务器　3
1．2．3　Node．js http-server　5
1．3　JavaScript基础　5
1．3．1　变量　6
1．3．2　运算符　8
1．3．3　真值和假值　11
1．3．4　相等运算符（==和===）　12
1．4　控制结构　14
1．4．1　条件语句　14
1．4．2　循环　15
1．5　函数　16
1．6　JavaScript面向对象编程　17
1．7　调试工具　18
1．8　小结　20
第　2章 ECMAScript和TypeScript概述　21
2．1　ECMAScript还是JavaScript　21
2．1．1　ES6、ES2015、ES7、ES2016、ES8、ES2017和ES．Next　21
2．1．2　使用Babel．js　23
2．2　ECMAScript 2015+的功能　24
2．2．1　用let替代var声明变量　24
2．2．2　模板字面量　27
2．2．3　箭头函数　27
2．2．4　函数的参数默认值　28
2．2．5　声明展开和剩余参数　29
2．2．6　增强的对象属性　30
2．2．7　使用类进行面向对象编程　31
2．2．8　乘方运算符　33
2．2．9　模块　33
2．3　介绍TypeScript　39
2．3．1　类型推断　40
2．3．2　接口　41
2．3．3　其他TypeScript功能　43
2．3．4　TypeScript中对JavaScript文件的编译时检查　43
2．4　小结　44
第3章　数组　45
3．1　为什么用数组　45
3．2　创建和初始化数组　46
3．3　添加元素　47
3．3．1　在数组末尾插入元素　47
3．3．2　在数组开头插入元素　48
3．4　删除元素　49
3．4．1　从数组末尾删除元素　49
3．4．2　从数组开头删除元素　49
3．5　在任意位置添加或删除元素　51
3．6　二维和多维数组　51
3．6．1　迭代二维数组的元素　52
3．6．2　多维数组　53
3．7　JavaScript的数组方法参考　54
3．7．1　数组合并　55
3．7．2　迭代器函数　55
3．7．3　ECMAScript 6和数组的新功能　57
3．7．4　排序元素　60
3．7．5　搜索　63
3．7．6　输出数组为字符串　64
3．8　类型数组　64
3．9　TypeScript中的数组　65
3．10　小结　66
第4章　栈　67
4．1　创建一个JavaScript数据结构和算法库　67
4．2　栈数据结构　68
4．2．1　创建一个基于数组的栈　69
4．2．2　向栈添加元素　69
4．2．3　从栈移除元素　70
4．2．4　查看栈顶元素　70
4．2．5　检查栈是否为空　71
4．2．6　清空栈元素　71
4．2．7　使用Stack类　71
4．3　创建一个基于JavaScript对象的Stack类　73
4．3．1　向栈中插入元素　73
4．3．2　验证一个栈是否为空和它的大小　74
4．3．3　从栈中弹出元素　74
4．3．4　查看栈顶的值并将栈清空　75
4．3．5　创建toString方法　75
4．4　保护数据结构内部元素　76
4．4．1　下划线命名约定　76
4．4．2　用ES2015的限定作用域Symbol实现类　77
4．4．3　用ES2015的WeakMap实现类　77
4．4．4　ECMAScript类属性提案　78
4．5　用栈解决问题　79
4．6　小结　81
第5章　队列和双端队列　82
5．1　队列数据结构　82
5．1．1　创建队列　83
5．1．2　使用Queue 类　86
5．2　双端队列数据结构　87
5．2．1　创建Deque类　87
5．2．2　使用Deque类　89
5．3　使用队列和双端队列来解决问题　90
5．3．1　循环队列——击鼓传花游戏　90
5．3．2　回文检查器　91
5．3．3　JavaScript任务队列　93
5．4　小结　93
第6章　链表　94
6．1　链表数据结构　94
6．2　双向链表　106
6．2．1　在任意位置插入新元素　107
6．2．2　从任意位置移除元素　109
6．3　循环链表　111
6．3．1　在任意位置插入新元素　112
6．3．2　从任意位置移除元素　113
6．4　有序链表　114
6．5　创建StackLinkedList类　116
6．6　小结　117
第7章　集合　118
7．1　构建数据集合　118
7．2　创建集合类　119
7．2．1　has(element)方法　119
7．2．2　add方法　120
7．2．3　delete和clear方法　120
7．2．4　size方法　121
7．2．5　values方法　122
7．2．6　使用Set类　122
7．3　集合运算　123
7．3．1　并集　123
7．3．2　交集　125
7．3．3　差集　127
7．3．4　子集　128
7．4　ECMAScript 2015——Set类　130
7．5　多重集或袋　132
7．6　小结　133
第8章　字典和散列表　134
8．1　字典　134
8．1．1　创建字典类　135
8．1．2　使用Dictionary类　141
8．2　散列表　142
8．2．1　创建散列表　143
8．2．2　使用HashTable类　146
8．2．3　散列表和散列集合　147
8．2．4　处理散列表中的冲突　147
8．2．5　创建更好的散列函数　158
8．3　ES2015 Map类　159
8．4　ES2105 WeakMap类和WeakSet类　159
8．5　小结　160
第9章　递归　161
9．1　理解递归　161
9．2　计算一个数的阶乘　162
9．2．1　迭代阶乘　162
9．2．2　递归阶乘　163
9．3　斐波那契数列　165
9．3．1　迭代求斐波那契数　166
9．3．2　递归求斐波那契数　166
9．3．3　记忆化斐波那契数　167
9．4　为什么要用递归？它更快吗　167
9．5　小结　168
第　10章 树　169
10．1　树数据结构　169
10．2　树的相关术语　170
10．3　二叉树和二叉搜索树　170
10．3．1　创建BinarySearchTree类　171
10．3．2　向二叉搜索树中插入一个键　172
10．4　树的遍历　175
10．4．1　中序遍历　175
10．4．2　先序遍历　176
10．4．3　后序遍历　177
10．5　搜索树中的值　178
10．5．1　搜索最小值和最大值　178
10．5．2　搜索一个特定的值　180
10．5．3　移除一个节点　182
10．6　自平衡树　185
10．6．1　Adelson-Velskii-Landi树（AVL树）　185
10．6．2　红黑树　194
10．7　小结　200
第　11章 二叉堆和堆排序　201
11．1　二叉堆数据结构　201
11．1．1　创建最小堆类　202
11．1．2　创建最大堆类　208
11．2　堆排序算法　209
11．3　小结　211
第　12章 图　212
12．1　图的相关术语　212
12．2　图的表示　214
12．2．1　邻接矩阵　215
12．2．2　邻接表　215
12．2．3　关联矩阵　216
12．3　创建Graph类　216
12．4　图的遍历　219
12．4．1　广度优先搜索　220
12．4．2　深度优先搜索　225
12．5　最短路径算法　231
12．5．1　Dijkstra算法　232
12．5．2　Floyd-Warshall算法　234
12．6　最小生成树　235
12．6．1　Prim算法　236
12．6．2　Kruskal算法　237
12．7　小结　238
第　13章 排序和搜索算法　239
13．1　排序算法　239
13．1．1　冒泡排序　239
13．1．2　选择排序　242
13．1．3　插入排序　244
13．1．4　归并排序　245
13．1．5　快速排序　247
13．1．6　计数排序　251
13．1．7　桶排序　253
13．1．8　基数排序　255
13．2　搜索算法　257
13．2．1　顺序搜索　257
13．2．2　二分搜索　258
13．2．3　内插搜索　260
13．3　随机算法　261
13．4　小结　262
第　14章 算法设计与技巧　263
14．1　分而治之　263
14．2　动态规划　265
14．2．1　最少硬币找零问题　266
14．2．2　背包问题　268
14．2．3　最长公共子序列　270
14．2．4　矩阵链相乘　272
14．3　贪心算法　274
14．3．1　最少硬币找零问题　274
14．3．2　分数背包问题　275
14．4　回溯算法　276
14．4．1　迷宫老鼠问题　277
14．4．2　数独解题器　279
14．5　函数式编程简介　282
14．5．1　函数式编程与命令式编程　283
14．5．3　JavaScript函数式工具箱——map、filter和reduce　284
14．5．4　JavaScript函数式类库和数据结构　286
14．6　小结　286
第　15章 算法复杂度　287
15．1　大O表示法　287
15．1．1　理解大O表示法　287
15．1．2　时间复杂度比较　289
15．1．3　NP完全理论概述　292
15．2　用算法娱乐身心　293
15．3　小结　294
