# 1.`<link>` `<script>`会阻塞页面渲染吗?（搞定）

## 规则

1. `<script/>脚本的执行的加载、解析和运行都会阻塞DOM的解析和渲染以及后续其他资源（因为GUI渲染线程和JS引擎线程互斥）`
   1. 但是async模式和defer模式下加载不会阻塞DOM解析，但是会阻塞渲染；

2. `<link/>脚本不阻塞DOM的解析，但会阻塞DOM的渲染和JS的执行（确保CSS样式正确渲染后执行JS）`

> **当 HTML 解析器被 JavaScript 脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。**

## 阻塞渲染是页面不渲染吗？

阻塞渲染并不是页面不渲染，如果页面非要等到`JS`加载执行完毕之后再渲染，那用户等待时间也太长了。浏览器的设计肯定会尽早让用户看到页面，因此遇到`<script>`标签时，会触发一次`Paint`，浏览器会将`<script>`标签之前的元素渲染出来。

但也并不是所有的`<script>`标签都会触发`Paint`。

- `<head>`中的`<script>`标签是不会触发的，毕竟此时`<body>`还没有解析，触发`Paint`也看不到任何内容。
- `inline` 的 `<script>`也不会触发`Paint`。

## `<link/>`会阻塞DOM解析吗？

<link/>本身只能阻塞渲染不能阻塞解析（这两者是并行的）。但是因为`<script>`执行会阻塞`HTML`解析,而执行`<script>`之前必须完成`<link>`中`CSS`样式的加载，这样就造成了`CSS`阻塞`HTML`解析的假象。

## `<link/>`标签放在哪里？

放在<head>中最合适，`<link>`标签并不会阻塞`HTML`的解析，所以放在`<head>`中可以被并行加载，如果是放在`DOM`底部的话会导致**回流或者重绘**，减缓加载的速度。

## `<script/>`标签放在哪里？

`<script>`标签会阻塞`HTML`的解析，从而阻塞页面的渲染，所以一般将其放在`<body>`的底部或者加上`defer`。`<script>`标签置于`<body>`可以确保页面完整`DOM`的获取。（<script>放在<body>底部或者加上`defer`属性）。

# 2.`<link>`标签的`rel`属性有什么含义？(搞定)

## `preload`：优先加载，一定会用到（不阻塞、不产生额外请求）

> preload （预加载），它告诉浏览器如何将特定资源提前提取到当前页面中。本质上，它会在当前页面开始加载之前在浏览器后台提前下载资源。并且，浏览器通常以高优先级，而不是布局阻塞的方式来获取此资源。使用 preload 提前加载的资源，不会花费额外的带宽。也就是不会产生额外的 HTTP 请求，这个是 preload 与 prefetch 不同的地方之一。
>
> 使用`preload`定义的资源标签是进行**关键路径优化中加载非关键CSS的关键**，因为使用 preload 加载的资源在加载完成后浏览器也不会立刻解析，这使得首屏渲染不会受到它的阻塞。

`<link>`元素的`rel`属性的属性值`preload`能够让你在你的`HTML`页面中`<head>`元素内部书写一些声明式的资源获取请求，可以指明哪些资源是在**页面加载完成后**即刻需要的。对于这种即刻需要的资源，你可能希望在页面加载的生命周期的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能（告知浏览器当前页面某些资源需要优先加载，当页面使用到这些资源的时候可以达到更流畅的效果）。

1. preload加载的资源是在浏览器**渲染机制之前进行处理**的，并且不会阻塞onload事件；
2. preload可以**支持加载多种类型的资源，并且可以加载跨域资源**；
3. preload**加载的js脚本其加载和执行的过程是分离的。即preload会预加载 相应的脚本代码，待到需要时等待下载完成后自行调用**；

```html
<link rel="preload" href="style.css" as="style">
```

## `prefetch`：空闲时预加载，可能会用到，（不阻塞、会产生额外请求）

> prefetch （预取用），它可以利用浏览器的空闲时间来预取用（下载）用户可能在不久的将来会访问的资源。换句话说，浏览器将提前加载用户将来可能要访问的页面资源。**浏览器将这些提前下载的资源存储在本地缓存中，以便在用户最终访问该页面的资源时能更快地发送请求的信息，并非常快速的加载资源。**所以，使用 prefetch 技术，**不会减少 HTTP 请求（还是会重新请求）**，但会提升使用资源时的资源加载速度。
>
> 关键字`prefetch`作为元素`<link>` 的属性`rel`的值，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。（告知浏览器其他页面有可能会用到某些资源，网络线程空闲时可以优先加载这些资源）

```html
<link rel="prefetch" href="pageB/images/B.png">
```

## `dns-prefetch`：预先进行`DNS`解析

`DNS-prefetch` (**DNS 预获取**) 是尝试在请求资源之前解析域名。**这可能是后面要加载的文件，也可能是用户尝试打开的链接目标。**

```html
<link rel="dns-prefetch" href="https://fonts.googleapis.com/"> 
```

------

# 3.`<script>`可以被延迟吗？（搞定）

- 默认：
  - **下载、运行都会直接阻塞页面渲染**（具体就是阻塞`DOMContentLoaded`）
  - **按照脚本位置顺序执行**（这也就意味着后面的脚本先加载完也不会被执行，必须等着前一个脚本加载并执行完才会继续执行）
- async：
  - `DOMContentLoaded` 和异步脚本**不会彼此等待**
  - 运行顺序为**先加载先运行**，其他脚本不会等待 `async` 脚本加载完成，同样，`async` 脚本也不会等待其他脚本，但同一时间只能有一个脚本运行
  - 异步加载，**加载不会阻塞页面渲染**，在加载完成后会**立即运行，阻塞页面渲染**
- defer
  - 异步加载，加载不阻塞页面渲染，运行在HTML解析完成之后，DOMContentLoaded之前（也就是阻塞DOMContentLoaded）
  - 加载顺序按照放置顺序
- 动态添加脚本
  - 相当于async，因为默认设置async
  - 可以手动设置defer和async来达到预期行为

> 给脚本设置`defer`是进行**关键路径优化**的重点，因为能够提前开启脚本的并行非阻塞下载，并且能够保证脚本运行的有序性。非关键`JS`资源并且无执行顺序要求的脚本可以考虑添加`async`进行加载，因为他们是和生命周期无关的。
>
> `defer`和`async`的区别：`defer`和`async`脚本在执行的时候都是会阻塞DOM渲染的。
>
> `async`在下载完成后**立即执行**（`async` 脚本会在后台加载，并在加载就绪时运行。DOM 和其他脚本不会等待它们，它们也不会等待其它的东西。`async` 脚本就是一个会在加载完成时执行的完全独立的脚本。因为async脚本也是外部资源，而页面在加载完成所有外部资源之后会触发`onload`事件）；
>
> `defer`可以确保脚本无论出现在HTML中哪一个位置，都是在`DOM`解析完成之后，`onDomContentrLoaded`之前被执行。

## 结论

可以通过调整<script>的位置，修改<script>**标签属性，动态插入，定时器延时**等方式来延迟脚本加载。

## 图例

![img](https://www.growingwiththeweb.com/images/2014/02/26/legend.svg)

## 解释

#### `<Script>`

特性：下载阻塞，运行阻塞

![img](https://www.growingwiththeweb.com/images/2014/02/26/script.svg)

#### `<script async>`

特性：异步下载（无阻塞），运行阻塞（立即运行，运行顺序是**先完成加载的先运行**）

![img](https://www.growingwiththeweb.com/images/2014/02/26/script-async.svg)

#### `<script defer>`

特性：异步下载（无阻塞），延后运行（在**DOM解析完之后** & **触发`DOMContentLoaded`之前按照顺序依次执行**。）

![img](https://www.growingwiththeweb.com/images/2014/02/26/script-defer.svg)

动态插入的<script>默认`async = true`

## 何时使用？

- 脚本的执行**有严格顺序要求** → <script defer> 
- 脚本的执行**无顺序要求**（没有前后关联）→ <script async>
- 脚本的执行有严格顺序要求，且**脚本较小并且必须在<script async>脚本之前执行** → <script>

## 其他方式

- **动态创建 `DOM` 方式：** 动态创建 `DOM` 标签的方式，可以对文档的**加载事件**进行监听，当文档**加载完成**后再动态的创建 `script` 标签来引入 `JS` 脚本。

- **使用 `setTimeout` 延迟方法：** 设置一个定时器来延迟加载`JS`脚本文件

- **让`<script>`最后加载：** 将`JS`脚本放在文档的底部，来使`JS`脚本尽可能的在最后来加载执行。

------

# 4.`<link>`和`@import`的区别?（搞定）

> 关键路径优化的重点是不要使用`@import`的方式加载CSS。

### 从属关系区别

- `@import`是 CSS 提供的语法规则，只有导入样式表的作用；
- `link`是HTML提供的标签，不仅可以加载 CSS 文件，还可以引入其他资源。

## 加载时机

- `<link> in <head>`
  - `HTML` 标签加载`DOM`时会**并行加载`<link>`标签的内容**；

- `@import`
  - 最大的问题是会等到所在的<link>整个加载完成后分析样式表找到对应命令后才开始下载`@import`的内容，等待下载完成之后才开始`CSS`内容的解析，效率低下；
  - 部分浏览器下使用`@import`有可能影响<link>的并行加载；


## DOM可控性区别

- 可以通过 JS 操作 DOM ，**插入`link`标签来改变样式**；
- 由于DOM方法是基于文档的，无法使用`@import`的方式插入样式。

### 兼容性区别

- `@import`是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；
- `link`标签作为 HTML 元素，不存在兼容性问题。

### 优先级角度

在`link`标签引入的 `CSS` 文件中，使用`@import`时需注意，如果已经存在相同样式，`@import`引入的这个样式将被该 `CSS` 文件本身的样式层叠掉，表现出`link`标签引入的样式权重大于`@import`引入的样式这样的直观效果。

------

# 5.`@import`如何使用？（搞定）

`@import`一定要写在除`@charset`外的其他任何 `CSS` 规则之前，如果置于其它位置将会被浏览器忽略，而且，在`@import`之后如果存在其它样式，则`@import`之后的**<u>分号</u>**是必须书写，不可省略的。

# 6.`@import`和内部CSS代码的优先级（搞定）

[参考资料](https://www.cnblogs.com/my--sunshine/p/6872224.html)

`@import`和同级的CSS存在冲突，且`@import`会被覆盖。

```css
/* inner.css */
@import url('outer.css');
div {
	color: red;
}

/* outer.css */
div {
    color: blue;
}

/* 最终命中red */
```

```html
<style>
    @import "./outer.css";
    div {
        color: blue
    }
    /* 最终命中blue */
</style>
```

## 原因

渲染的动作一般都会执行多次，最后一次渲染，一定是依据之前加载过的所有样式整合后的渲染树进行绘制页面的，已经被渲染过的页面元素，也会被重新渲染。可以把`@import`这种导入 `CSS` 文件的方式理解成一种替换，`CSS` 解析引擎在对一个 `CSS` 文件进行解析时，如在文件顶部遇到`@import`，将被替换为该`@import`导入的 `CSS` 文件中的全部样式。

# 7.浏览器缓存（搞定）

![Alt text](https://github.com/NoAlligator/pico/blob/main/img/15fe1d6fc1269a86~tplv-t2oaga2asx-watermark.awebp?raw=true)

> 强缓存代表**不需要发送请求到服务端，直接读取浏览器本地缓存**，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。 

### Expires

Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。

### Cache-Control

```http
cache-control: max-age=31536000, public
```

Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：

- max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效
- no-cache：**不使用强缓存**，需要与服务器验证缓存是否新鲜
- no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源
- private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
- public：响应可以被中间代理、CDN 等缓存
- must-revalidate：在缓存过期前可以直接使用，过期后必须向服务器重新验证

### Pragma

Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。

## 缓存的基本流程？

1. 浏览器发送请求前，根据**对应缓存响应头**的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略（强缓存是利用http的返回头中的**`Expires`**或者**`Cache-Control`**两个字段来控制的，用来表示资源的缓存时间，如果开启了`no-cache`、`no-store`、`private`、`must-revalidate`等会导致强缓存失效，没有导致强缓存失效的头存在并且缓存依旧新鲜的话便会进入强缓存），如果**命中，直接从缓存获取资源，并不会发送请求**。如果**没有命中，则进入下一步**。
2. **没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存**，如果**命中，直接从缓存获取资源**。如果没有命中，则进入下一步。 
3. 如果前两步都没有命中，则**直接从服务端获取资源**。

## 为什么使用缓存？

`Web`缓存可以**自动保存已获取的资源**，当`Web`请求抵达缓存时，如果本地有**“已缓存的”**副本，就可以**从本地存储而不是原始服务器中提取这些资源**，使用缓存有下列有点：

- 缓存减少了**冗余**的数据传输，使得需要频繁用到的**资源得以复用**。
- 缓存缓解了**网络瓶颈**问题，**节省带宽**。
- 缓存降低原始服务器的**压力**，因为**减少了资源请求的次数**。
- 缓存可以**明显地提升性能**，使用**本地资源较之请求服务器资源更高效**。

## 缓存的类型有哪些？

缓存按照是否可以共享分为两大类型：**私有缓存**和**公有缓存**

私有缓存：私有缓存，**不能被代理服务器缓存**，**不可以被多个用户共享**。（对应`private`指令）

公有缓存：公有缓存，表示**可以被代理服务器缓存**，可以被**多个用户共享**。（对应`public`指令）

缓存按照缓存的位置分为四大类型：

![img](https://github.com/NoAlligator/pico/blob/main/img/70f599db34fa42068ccfa4e04748a078~tplv-k3u1fbpfcp-watermark.awebp?raw=true)

## 什么是浏览器缓存？

所谓浏览器缓存其实就是指在**本地使用的计算机中开辟一个内存区**，同时也**开辟一个硬盘区作为数据传输的缓冲区**，然后用这个缓冲区来**暂时保存用户以前访问过的信息**。

## 浏览器缓存的两种情况？

强缓存（本地缓存）、弱缓存（协商缓存）

强缓存：不会向服务器发送请求，**直接从缓存中读取资源**。强缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间。

- `Expires` 是 `http 1.0` 的规范，值是一个`GMT` 格式的时间点字符串，比如 `Expires:Mon,18 Oct 2066 23:59:59 GMT` 。这个时间点代表资源失效的时间，如果当前的时间戳在这个时间之前，则判定命中缓存。有一个缺点是，失效时间是一个绝对时间，如果服务器时间与客户端时间偏差较大时，就会导致缓存混乱。而服务器的时间跟用户的实际时间是不一样是很正常的，所以 `Expires` 在实际使用中会带来一些麻烦。
- `Cache-Control`详见下一个问题。
- **`Cache-Control`优先级高于`Expire`**

协商缓存：协商缓存是由服务器来确定缓存资源是否可用。 主要涉及到**两对属性字段，都是成对出现的**，即第一次请求的响应头带上某个字, `Last-Modified` 或者 `Etag`，则后续请求则会带上对应的请求字段 `If-Modified-Since`或者 `If-None-Match`，**若响应头没有 `Last-Modified` 或者 `Etag` 字段，则请求头也不会有对应的字段。**

- `Last-Modified/If-Modified-Since` 二者的值都是 GMT 格式的时间字符串， `Last-Modified` 标记最后文件修改时间， 下一次请求时，请求头中会带上 `If-Modified-Since` 值就是 `Last-Modified` 告诉服务器我本地缓存的文件最后修改的时间，在服务器上根据文件的最后修改时间判断资源是否有变化， 如果文件没有变更则返回 `304 Not Modified` ，请求不会返回资源内容，浏览器直接使用本地缓存。当服务器返回 `304 Not Modified` 的响应时，`response header` 中不会再添加的 `Last-Modified` 去试图更新本地缓存的 `Last-Modified`， 因为既然资源没有变化，那么 `Last-Modified` 也就不会改变；如果资源有变化，就正常返回返回资源内容，新的 `Last-Modified` 会在 `response header` 返回，并在下次请求之前更新本地缓存的 `Last-Modified`，下次请求时，`If-Modified-Since`会启用更新后的 `Last-Modified`。
- `Etag/If-None-Match`， 值都是由服务器为每一个资源生成的唯一标识串，只要资源有变化就这个值就会改变。服务器根据文件本身算出一个哈希值并通过 `ETag`字段返回给浏览器，接收到 `If-None-Match` 字段以后，服务器通过比较两者是否一致来判定文件内容是否被改变。与 `Last-Modified` 不一样的是，当服务器返回 `304 Not Modified` 的响应时，由于在服务器上`ETag` 重新计算过，`response header`中还会把这个 `ETag` 返回，即使这个 `ETag` 跟之前的没有变化。

> `HTTP` 中并没有指定如何生成 `ETag`，可以由开发者自行生成，哈希是比较理想的选择。

区别：如果浏览器命中强缓存，则**不需要给服务器发请求**；而协商缓存最终**由服务器来决定是否使用缓存**，即客户端与服务器之间**存在一次通信**。在`chrome` 中强缓存（虽然没有发出真实的 `http` 请求）的请求状态码返回是 `200 (from cache)`；而协商缓存如果命中走缓存的话，请求的状态码是 `304 (not modified)`。 不同浏览器的策略不同，在 `Fire Fox`中，`from cache` 状态码是 `304`。

## 协商缓存详解？

[参考链接](https://zhuanlan.zhihu.com/p/273651157)

协商缓存**不指定缓存的有效时间，而是在请求时直接发送资源标识到服务端确认缓存是否需要更新，如果请求响应返回的 HTTP 状态为 `304`，则表示缓存仍然有效；否则返回状态码 `200 `、最新的资源和最新的资源标识**。

> **控制缓存的难题就从浏览器端转移到了服务端**。

### 资源标识符有两种，对应方案就有两组：

- `Last-Modified`：资源的最后修改时间
- `Etag`：资源的**唯一标识**（一个字符串）

#### 方案一：`Last-Modified`与`if-Modified-Since`

服务端通过响应头部字段 `Last-Modified` 和请求头部字段 `If-Modified-Since` 比对**双方资源的修改时间，来确定缓存是否需要更新**。具体工作流程如下：

![img](https://github.com/NoAlligator/pico/blob/main/img/v2-e7c5b4ea204be53364f72ef03fef6fbd_r.jpg?raw=true)

1. 浏览器第一次请求资源，服务端在返回资源的响应头中加入 `Last-Modified` 字段，表示这个资源在服务端上的最近修改时间；
2. 当浏览器再次向服务端请求该资源时，请求头部带上之前服务端返回的 `Last-Modified`，这个请求头叫 `If-Modified-Since`；
3. 服务端再次收到请求，根据 `If-Modified-Since` 的值，判断**相关资源是否有变化**，如果没有，则返回 `304 Not Modified`，浏览器使用资源缓存值；否则返回资源内容，且更新 `Last-Modified`响应头内容。

存在问题：

1. 精度问题：`Last-Modified` 的**时间精度**为秒，如果在 `1` 秒内发生修改，那么缓存判断会失效。
2. 准度问题：如果一个文件**被修改后又被还原，内容没有发生变化，却仍然需要重新请求**。
3. 服务器问题：**某些服务器不能精确的得到文件的最后修改时间**。

#### 方案二：`Eag`与`if-None-Match`

为了解决精度问题和准度问题，`HTTP` 提供了另一种依赖于**文件哈希值的精确判断缓存**的方式：响应头部字段 `ETag` 和请求头部字段 `If-None-Match`。具体工作流程如下：

![img](https://github.com/NoAlligator/pico/blob/main/img/v2-3e1da5789e1743643ee8c0ed8487660e_r.jpg?raw=true)

1. 浏览器第一次请求资源，**服务端**在返响应头中加入 `Etag` 字段，`Etag` 字段值为该资源的**哈希值**；
2. 当浏览器再次跟服务端请求这个资源时，在**请求头上加上 `If-None-Match`，值为之前响应头部字段 `ETag` 的值**；
3. 服务端再次收到请求，将**请求头 `if-None-Match` 字段的值和响应资源的哈希值进行比对**，如果**两个值相同，则说明资源没有变化**，返回 `304 Not Modified`；**否则就正常返回资源内容，无论是否发生变化，都会将计算出的哈希值放入响应头部的 `ETag` 字段中**。

这种缓存比较的方式也会存在一些问题，具体表现在以下两个方面：

1. **计算成本**。对于大文件而言，**读取完整的文件内容生成哈希值开销较大**；只读取文件部分内容，又容易判断出错。
2. **计算误差。**不同服务端可能会采用不同的哈希值计算方式。**所以同一个资源在两台服务端产生的 `Etag` 可能是不相同的。对于**使用服务器集群**来处理请求的网站来说，**使用 `Etag` 的缓存命中率会有所降低**。（如果资源是走分布式服务器（比如CDN）存储的情况，需要这些服务器上**计算`ETag`唯一值的算法保持一致**，才不会导致明明同一个文件，**在服务器`A`和服务器`B`上生成的`ETag`却不一样）

## 为什么要有`Etag`？

- 一些文件也许会**周期性的更改**，但是内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新`GET`；
- 某些**文件修改非常频繁，比如在秒以下的时间内进行修改**，(比方说 `1s` 内修改了 `N` 次)，`If-Modified-Since` 能检查到的**粒度是秒级的**，使用 `Etag` 就能够保证这种需求下客户端在 `1` 秒内能刷新 `N` 次 `cache`。
- 某些服务器不能精确的得到文件的最后修改时间。

## `Etag`方案和`last-Modified`方案的优先级，强制缓存和协商缓存的优先级？

当两个方案都存在的时候，会优先使用 `Etag`方案，因为：

- `Last-Modified` 只能精确到秒级；
- 如果资源被重复生成，**而内容不变，`Etag` 更加精准**。

![img](https://github.com/NoAlligator/pico/blob/main/img/v2-760cfd58fbe0bf6a331c51ef1f883473_r.jpg?raw=true)

结论一：为了能够最大限度的减少请求，提升性能，**强制缓存的优先级是高于协商缓存**的，因为强制缓存直接读取缓存，不存在网络请求上的开销。

结论二：在强制缓存中，请求头`Cache-Cotrol`字段的指令优先级要高于`Expire`。

结论三：在协商缓存中，`Etag`方案的优先级要高于`Last-Modified`，因为使用`Etag`更加准确。

`Cache-Control` > `expires` > `Etag` > `Last-Modified`

## 哪些情况导致协商缓存？

- `Expire`：该请求头字段验证后表示过期的话必须进行协商缓存；
- `Cache-Control: no-cache`：设置`no-cache`代表在**读取客户端缓存之前必须和服务器进行沟通**，确保资源是最新的，如果返回`304`的话代表可以使用本地缓存并更新响应的头信息使得缓存有效期相关的信息更新，如果是`200`的话代表得到了新的资源，在可以被缓存的情况下更新该资源缓存。
- `Cache-Control: max-age=0`：资源立即过期，重新验证。
- `Cache-Control: no-store`：资源**不能在客户端进行缓存**，请求资源必须重新发送请求。
- `Cache-Control:` `must-revalidate`

## 用户行为对缓存的影响？

1. 打开网页，地址栏输入地址： 查找 `disk cache` 中是否有匹配。如有则使用；如没有则发送网络请求。
2. 普通刷新 (`F5`)：因为 `TAB` 并没有关闭，因此 `memory cache` 是可用的，会被优先使用(如果匹配的话)。其次才是 `disk cache`。
3. 强制刷新 (`Ctrl + F5`)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control:no-cache`(为了兼容，还带了 `Pragma:no-cache`),服务器直接返回 `200` 和最新内容。（注意，这里的`no-cache`还是需要服务器或者代理服务器兼容的，如果代理服务器忽略了这样一个请求头，那么浏览器依然会**读取本地缓存**，经过测试，很多网站是不支持使用`Ctrl+F5`强制重新请求资源覆盖缓存的）。



## 浏览器缓存解读？

### `200 memory cache`

表示**不访问服务器，直接从内存中读取缓存**。因为缓存的资源保存在内存中，所以**读取速度较快**，但是**关闭进程后，缓存资源也会随之销毁**，一般来说，**系统不会给内存分配较大的容量，因此内存缓存一般用于存储较小文件。**同时内存缓存在**有时效性要求**的场景下也很有用（比如浏览器的隐私模式）。

### `200 disk cache`

表示**不访问服务器，直接从硬盘中读取缓存**。与内存相比，**硬盘的读取速度相对较慢，但硬盘缓存持续的时间更长，关闭进程之后，缓存的资源仍然存在。**由于硬盘的容量较大，因此一般用于存储大文件。

下图可以明显比较出读取速度的差距：

![img](https://image.jiqizhixin.com/uploads/editor/af77fe61-49a5-4ef5-8494-f4e6023b3807/640.png)

### `200 prefetch cache`

当资源被 preload 或者 prefetch 后，会从网络堆栈传输到 HTTP 缓存并进入渲染器的内存缓存。 如果资源可以被缓存（例如，存在有效的 cache-control和 max-age），它将存储在 HTTP 缓存中，可用于当前和未来的会话。 如果**资源不可缓存，则不会将其存储在 HTTP 缓存中**。 相反，它会被缓存到**内存缓存**中并保持不变直到它被使用。

![img](https://image.jiqizhixin.com/uploads/editor/0526e3b1-3213-4501-8aa4-bb667caf2428/640.png)

### `CDN Cache`

以腾讯 CDN 为例：`X-Cache-Lookup:Hit From MemCache` 表示命中 CDN 节点的内存；`X-Cache-Lookup:Hit From Disktank` 表示命中 CDN 节点的磁盘；`X-Cache-Lookup:Hit From Upstream` 表示没有命中 CDN。

![img](https://github.com/NoAlligator/pico/blob/main/img/640.png?raw=true)

## 缓存位置？

按照缓存位置优先级排序： 

`Service Worker`（可以实现**离线体验**） --> `Memory Cache`（内存缓存） --> `Disk Cache`（硬盘缓存） --> `Push Cache`（推送缓存）

请求一个资源时，会按照**优先级**依次查找缓存，如果**命中则使用缓存**，否则发起请求。

`Service Worker`是**运行在浏览器背后的独立线程**，可以用来**实现缓存功能**。使用 `Service Worker` 的话，传输协议**必须为 HTTPS**。因为 `Service Worker` 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。`Service Worker` 的缓存与浏览器其他内建的缓存机制不同，它可以让我们**自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的**。

`Memory Cache`是**内存中的缓存**，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。**读取内存中的数据高效，但是缓存持续性很短**。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。**而且由于计算机中的内存比硬盘容量小得多，我们**能够使用存储缓存的内存并不多**。

`Disk Cache` 是存储在硬盘中的缓存，**读取速度比 Memory Cache 慢，但是存储量更大**。它会**根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求**。

`Push Cache`（推送缓存）是 HTTP/2 中的内容，当以上三种缓存**都没有命中**时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

## 浏览器什么时候会把缓存存储到内存，什么时候存储到硬盘呢？

对于大文件来说，大概率是不存储在内存中的，反之优先。**当前系统内存使用率高的话**，文件**优先存储进硬盘**。

## 实际场景应用的缓存策略

1. 频繁变动资源：**对于频繁变动的资源，首先需要使用`Cache-Control: no-cache` 使浏览器每次都请求服务器（确保资源严格最新），然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。**
2. 不经常变化的资源：**通常在处理这类资源时，给它们的 `Cache-Control` 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 `URL` 会命中强制缓存。**而为了解决更新的问题，就需要**在文件名(或者路径)中添加 `hash`， 版本号等动态字符，之后更改动态字符，从而达到更改引用 `URL` 的目的，让之前的强制缓存失效** (其实并未立即失效，只是不再使用了而已)。在线提供的类库 (如 `jquery-3.3.1.min.js`, `lodash.min.js` 等) 均采用这个模式。

# 8.说一说缓存控制相关的请求头？

**缓存控制**：控制缓存的开关，用于标识请求或访问中是否开启了缓存，使用了哪种缓存方式。
**缓存校验**：如何校验缓存，比如怎么定义缓存的有效期，怎么确保缓存是最新的。

## 与缓存控制相关的请求头

在`http`中，控制缓存开关的字段有两个：`Pragma`和 `Cache-Control`

## ⭐`Pragma`

`Pragma` 是一个在 `HTTP/1.0`中规定的通用首部，这个首部的效果依赖于不同的实现，所以在“请求-响应”链中可能会有不同的效果。它用来向后兼容只支持 `HTTP/1.0`协议的缓存服务器，那时候 `HTTP/1.1` 协议中的 `Cache-Control` 还没有出来。建议只在需要兼容 `HTTP/1.0` 客户端的场合下应用 `Pragma` 首部。

`Pragma`仅支持`no-cache`一个指令。

```
Pragma: no-cache
```

## ⭐`Cache-Control`

> 通过指定首部字段`Cache-Control`的指令，就能**操作缓存**的工作机制。

#### 基本格式

`Cache-Control`指令的参数是**可选的**，多个指令之间通过**逗号**分隔。

```
Cache-Control: private, max-age = 0, no-cache
```

#### 分类

`Cache-Control`指令按照请求和响应分类：

![img](https://github.com/NoAlligator/pico/blob/main/img/20180921155944100?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2018092116013247?raw=true)

#### 详解

[指令详解](https://netsecurity.51cto.com/art/202001/609646.htm)

- 可缓存性：它们分别是 no-cache、no-store、private 和 public
- 缓存有效性时间：它们分别是 max-age、s-maxage、max-stale、min-fresh
- 重新验证并重新加载：它们分别是 must-revalidate 和 proxy-revalidate
- 其他：它们分别是 only-if-cached 和 no-transform

![img](https://github.com/NoAlligator/pico/blob/main/img/817f04c2e97412854504f9e242f8a64e.jpg-wh_600x-s_4053185376.jpg?raw=true)

##### ⭐`public` 和 `private`

`public` 意味着包括 **`CDN`、代理服务器之类的任何缓存都可以存储响应的副本**。`public` 指令经常是冗余的，因为**其他指令的存在（例如 `max-age`）已经隐式表示响应是可以缓存的**。

相比之下，**`private` 是一个显式指令，表示只有响应的最终接收方（客户端或浏览器）可以缓存文件**。虽然 `private` 本身并不具备安全功能，但它意在**有效防止公共缓存（如 `CDN`）存储包含用户个人信息的响应**。

##### ⭐`max-age`（一般面向私有缓存的设置 ）

`max-age` 指令主动告知客户端**该资源在指定时间内是最新的**，**有效期内无需重新验证请求该资源**，直接从缓存中读取（**以秒计**）。

```http
Cache-Control: max-age=60
```

案例中的指令表示（隐式）**缓存该请求**并且可在接下来的`60`秒**重用该响应**。这个 `Cache-Control` 报头告诉浏览器可以在接下来的`60`秒内从缓存中使用这个文件**而不必担心是否需要重新验证**。`60`秒后，浏览器将**回访服务器以重新验证该文件**。回访的时候，服务器如果有了一个**新文件**供浏览器下载，服务器会返回 `200`，浏览器下载新文件，旧文件也会从`HTTP`缓存中被剔除，新的文件会接替它，并**应用新缓存报头**。

如果并**没有新的副本**供下载，服务器会返回 `304`，不需要下载新文件，使用**新的报头来更新缓存副本**。也就是说如果 `Cache-Control: max-age=60` 报头依然存在，**缓存文件的`60`秒会重新开始。这个文件的总缓存时间是`120`秒**。

**注意：**`max-age` 本身有一个巨坑，它**告诉浏览器相关资源已经过期**，**但没有告诉这个过期版本绝对不能使用**。浏览器**可能使用它自己的机制来决定是否在不经验证的情况下释放文件的过期副本**。这种行为有些不确定性，想确切知道浏览器会怎么做有点困难。为此，我们有一系列更为明确的指令，用来增强 `max-age`，也就是`s-maxage`。

##### ⭐`s-maxage`（面向公共缓存的设置）

`s-maxage`（注意 `max` 和 `age` 之间没有 `-`）会覆盖 `max-age` 指令，但只在**公共缓存**中生效。`max-age` 和 `s-maxage` 结合使用可以让你**针对私有缓存和公共缓存**（例如代理、`CDN`）分别设定不同的刷新时间。`s-maxage`一般用在缓存服务器上(比如`cache CDN`)，并**只对`public`缓存有效**。

##### ⭐`no-store`

```
Cache-Control: no-store
```

`no-store` 是一个**非常高优先级的指令**，表示**不会将任何信息持久化到任何缓存中，无论是私有与否**。

##### ⭐`no-cache`

```
Cache-Control: no-cache
```

`no-cache` 并不意味着 “`no cache`”。它**意味着“在你和服务器验证过并且服务器告诉你可以使用缓存的副本之前，你`不`能使用`缓存`中的副本”**。（已缓存但不能直接使用，能否复用依赖向服务器发起新鲜度验证）。使用`no-cache`是一个兼顾文件新鲜度和快速从缓存中读取原始资源的智能方式，缺点是他必须发起一次验证请求。

`no-cache` 一个很好的使用场景就是动态 `HTML` 页面获取。想想一个新闻网站的首页：既不是实时的，也不包含任何敏感信息，但理想情况下我们希望页面始终显示最新的内容。我们可以使用 `cache-control: no-cache` 来让浏览器首先回访服务器检查，如果服务器没有更新鲜的内容提供（`304`），那我们就重用缓存的版本。如果服务器有更新鲜的内容，它会返回（`200`）并且发送最新的文件。

注意：`max-age` 指令和 `no-cache` 指令一起发送**是没用的**，因为**重新验证的时间限制是零秒**。

##### ⭐`must-revalidate`

```
Cache-Control: must-revalidate, max-age=600
```

`must-revalidate` **需要一个关联的 `max-age` 指令**；上文我们把它设置为`10`分钟。

`no-cache`和`must-revalidate`的区别：

- `no-cache`: **告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。**
- `must-revalidate`：**告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。**

 `no-cache` 会**立即向服务器验证，经过允许后才能使用缓存的副本**。

`must-revalidate` 是一个具有**宽期限**的 `no-cache`**。以上面的指令设置为例：**在最初的十分钟浏览器不会向服务器重新验证，但是就在十分钟过去的那一刻，它又到服务器去请求，如果服务器没什么新东西，它会返回 `304` 并且新的 `Cache-Control` 报头应用于缓存的文件 —— 这使得**缓存文件的有效期被延长**。如果十分钟后服务器上有了一个新的文件，我们会得到 `200` 的响应和它的报文，那么本地缓存就会被更新。

`must-revalidate` 一个很适合的场景就是博客（比如我这个博客）：**静态页面很少更改**。当然，最新的内容是可以获取的，但考虑到我的网站很少更改，我们不需要 `no-cache` 这么下重手的东西。相反，我们会假设在十分钟内一切都好，之后再重新验证。

##### ⭐`immutable`

在了解 `immutable` 是什么之前，我们先看看它要解决什么问题：

用户刷新会导致浏览器强制验证一个文件而不论文件新鲜与否，因为用户刷新**往往意味着发生了这两件事之一**：

1. 页面崩溃之类的；
2. 内容看起来已经过期了。

所以我们浏览器必须检查一下服务器上**是否有更加新鲜的内容**。

`immutable` 就是**一种告诉浏览器一个文件永远都不会改变的方法** —— 它是**不可变的** —— 因此不要再费心重新验证它。我们可以完全减去造成延迟的往返开销。

```
Cache-Control: max-age=31536000, immutable
```

在支持 `immutable` 的浏览器中，只要没超过 31,536,000 秒的**新鲜寿命**，用户**刷新也不会造成重新验证**。这意味着避免了响应 `304` 的往返请求，这可能会节约我们在关键路径上（[CSS blocks rendering](https://link.juejin.cn?target=https%3A%2F%2Fcsswizardry.com%2F2018%2F11%2Fcss-and-network-performance%2F)）的大量延迟。在**高延迟的场景**里，这种节约是可感知的。

注意：千万不要给任何非不可变文件应用 `immutable`。你还应该有一个非常周全的缓存破坏策略，以防无意中将不可变文件强缓存。

##### ⭐`min-fresh`

`min-fresh`只能出现在请求中，`min-fresh` 要求缓存服务器返回 `min-fresh`**时间内**的缓存数据。例如 `Cache-Control:min-fresh=60`，这就要求缓存服务器发送**60**秒内的数据。

##### ⭐`max-stable`

`max-stable` 只能出现在请求中，表示客户端会接受缓存数据，即使过期也照常接收。

##### ⭐`only-if-cached`

这个标头只能出现在请求中，使用 `only-if-cached` 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。

##### ⭐`proxy-revalidate`

`proxy-revalidate` 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须**再次验证缓存的有效性**。

##### ⭐`no-transform`

使用 `no-transform` 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。



# 9.最佳的缓存策略？

- 使用**一致的网址**：如果您在不同的网址上提供相同的内容，将会多次获取和存储该内容。注意：`URL `在某些情况下区分大小写（**域名不区分，域名后面的路径根据服务器设置情况需要进行讨论**）。
- 跨域针对不同域返回不同`Access-control-allow-origin`务必记得设置`Vary: Origin`，避免破坏缓存。
- 确定中继缓存可以缓存哪些资源：对所有用户的响应完全相同的资源很适合由`CDN`或其他中继缓存进行缓存；
- 确定每个资源的最优缓存周期：不同的资源可能有不同的更新要求。审查并确定每个资源适合的 `max-age`；
- 确定网站的最佳缓存层级：对 `HTML` 文档组合使用包含内容特征码的资源网址以及短时间或 `no-cache `的生命周期，可以控制客户端获取更新的速度；
- 更新最小化：**有些资源的更新比其他资源频繁**。如果资源的特定部分（例如 `JS` 函数或一组 `CSS` 样式）会经常更新，应考虑**将其代码作为单独的文件提供**（合理的代码分割）。这样，每次获取更新时，剩余内容（例如不会频繁更新的库代码）可以**从缓存中获取，确保下载的内容量最少**；
- 确保服务器配置或移除`ETag`：因为`Etag`跟服务器配置有关，每台服务器的`Etag`都是不同的，确保使用相同的算法生成一致的`Etag`；
- 善用 `HTML5` 的缓存机制：合理设计启用 `LocalStorage`、`SessionStorage`、`IndexDB`、`SW`等存储，会给页面性能带来明显提升；
- 结合 `Native` 的强大存储能力：善于利用客户端能力，定制合适的缓存机制，打造极致体验。

# 10.关键渲染路径优化

[参考](https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487228&idx=1&sn=848218a220558d4f87fa8ed5611e1157&source=41#wechat_redirect)

> 优化关键渲染路径可以提升网页的渲染速度，从而得到一个更好的用户体验。

到目前为止，只有三种因素可以影响关键渲染路径的耗时。而所有的优化方式，都是在尽可能的针对这三种因素进行优化。

这三种因素分别是：

- 关键资源的数量
- 关键路径的长度
- 关键字节的数量

> *切记，非常重要，所有优化关键渲染路径的方法，都是在优化以上三种因素。因为只有这三种因素可以影响关键渲染路径。*关键资源指的是那些可以阻塞页面首次渲染的资源。例如JavaScript、CSS都是可以阻塞关键渲染路径的资源，这些资源就属于“关键资源”。关键资源的数量越少，浏览器处理渲染的工作量就越少，同时CPU及其他资源的占用也越少。关键路径中的每一步耗时越长，由于阻塞会导致渲染路径的整体耗时变长。关键路径的长度指的是关键渲染路径的总耗时。关键渲染路径的长度会受到很多因素的影响。例如：关键资源的网络情况、关键资源的数量、关键资源的字节大小、关键资源的依赖关系等。关键字节的数量指的是关键资源的字节大小，浏览器要下载的资源字节越小，则下载速度与处理资源的速度都会更快。通常很多优化方法都是针对关键字节的数量进行优化。例如：压缩。

## 优化DOM

精简压缩、开启缓存、极端情况下考虑使用svelte等减少了JS运行时的开销

在关键渲染路径中，构建渲染树（Render Tree）的第一步是构建DOM，所以我们先讨论如何让构建DOM的速度变得更快。**HTML文件的尺寸应该尽可能的小**，目的是为了让客户端尽可能早的接收到完整的HTML。对于生产环境的HTML来说，应该删除一切无用的代码，尽可能保证HTML文件精简。总结起来有三种方式可以优化HTML：**缩小文件的尺寸（Minify）**、**使用gzip压缩（Compress）**、**使用缓存（HTTP Cache）**。本质上，优化DOM其实是在**尽可能的减小关键路径的长度与关键字节的数量**。

## 优化CSSOM

精简压缩、开启缓存、添加媒体查询属性屏蔽不相关资源的阻塞、Critial CSS、避免使用@import

与优化DOM类似，CSS文件也需要**让文件尽可能的小**，或者说所有文本资源都需要。CSS文件应该删除未使用的样式、缩小文件的尺寸（Minify）、使用gzip压缩（Compress）、使用缓存（HTTP Cache）。除了上面提到的优化策略，CSS还有一个可以影响性能的因素是：**CSS会阻塞关键渲染路径**。CSS是关键资源，它会阻塞关键渲染路径也并不奇怪，但通常并不是所有的CSS资源都那么的『关键』。

举个例子：一些响应式CSS只在屏幕宽度符合条件时才会生效，还有一些CSS只在打印页面时才生效。这些CSS在不符合条件时，是不会生效的，所以我们为什么要让浏览器等待我们并不需要的CSS资源呢？

针对这种情况，我们应该让这些非关键的CSS资源**不阻塞渲染**。

实现这一目的非常简单，我们只需要将**不阻塞渲染**的CSS移动到单独的文件里。例如我们将打印相关的CSS移动到print.css，然后我们在HTML中引入CSS时，添加媒体查询属性print，代码如下：

```html
<link href="print.css" rel="stylesheet" media="print">
```

上面代码添加了media="print"属性，所以上面CSS资源仅用于打印。添加了媒体查询属性后，浏览器依然会下载该资源，但如果条件不符合，那么它就不再阻塞渲染，也就是变成了**非阻塞的CSS**。

关于CSS的加载有这么多门道，到底怎样才是最佳实践？答案是：**Critical CSS**。

**Critical CSS的意思是：把首屏渲染需要使用的CSS通过style标签内嵌到head标签中，其余CSS资源使用异步的方式非阻塞加载。**CSS资源在构建渲染树时，会阻塞JavaScript，所以我们应该保证所有与首屏渲染无关的CSS资源都应该被标记为非关键资源。所以Critical CSS从两个方面解决了性能问题：

1. **减少关键资源的数量**（将所有与首屏渲染无关的CSS使用异步非阻塞加载）。
2. **减少关键路径的长度**（将首屏渲染需要的CSS直接内嵌到head标签中，移除了网络请求的时间）。

避免使用@import：避免使用@import是为了降低关键路径的长度。

## 异步JavaScript

精简压缩、开启缓存、开启异步脚本，减少阻塞式脚本、非关键JS资源可以延迟加载防止阻塞页面渲染

所有文本资源都应该**让文件尽可能的小**，JavaScript也不例外，它也需要删除未使用的代码、缩小文件的尺寸（Minify）、使用gzip压缩（Compress）、使用缓存（HTTP Cache）。

与CSS资源相似，JavaScript资源也是关键资源，JavaScript资源会阻塞DOM的构建。并且JavaScript会被CSS文件所阻塞。为了避免阻塞，可以为script标签添加async属性。

> 总结：**关键路径优化**就是为了从**应用资源以及浏览器运行的角度**寻求资源最高效下载和加载以优化网页渲染速度的方法。**对于DOM，我们应当对HTML进行压缩、缓存，使得客户端可以尽早收到HTML文件**；对于CSSOM，我们应当尽量删减掉多余的样式代码，并进行合并、压缩、缓存，以缩减CSS下载和解析的时间。并且因为，CSS的解析会阻塞关键渲染路径，我们可以将非必要的CSS文件进行非命中的标记以减少这些CSS文件对于当前关键渲染路径的阻塞。此外，关于CSS优化的最佳实践时进行“Critical CSS”，把首屏渲染需要使用的CSS通过style标签内嵌到head标签中，其余CSS资源使用异步的方式非阻塞加载。CSS资源在构建渲染树时，会阻塞JavaScript，所以我们应该保证所有与首屏渲染无关的CSS资源都应该被标记为非关键资源。并且，我们不应当使用`@import`，它会导致串行下载，降低了CSS资源的下载效率并推迟了CSS的解析时机；对于JS，它首先应当被压缩、缓存，其次，因为JS脚本内的下载和加载都会阻塞HTML的解析，所以我们应当使用`defer`标签实现异步的下载。

# 11.性能优化地图

[参考](https://github.com/berwin/Blog/issues/23)

## 1. 度量标准与设定目标

在进行性能优化之前，我们需要为应用选择一个正确的度量标准（性能指标）以及设定一个合理的优化目标。

> 并不是所有指标都同样重要，这取决于你的应用。最后根据度量标准设定一个现实的目标。

### 1.1 度量标准

下面是一些值得考虑的指标：

- 首次有效绘制（First Meaningful Paint，简称FMP，当主要内容呈现在页面上）
- 英雄渲染时间（Hero Rendering Times，度量用户体验的新指标，当用户最关心的内容渲染完成）
- 可交互时间（Time to Interactive，简称TTI，指页面布局已经稳定，关键的页面字体是可见的，并且主进程可用于处理用户输入，基本上用户可以点击UI并与其交互）
- 输入响应（Input responsiveness，界面响应用户输入所需的时间）
- 感知速度指数（Perceptual Speed Index，简称PSI，测量页面在加载过程中视觉上的变化速度，分数越低越好）
- 自定义指标，由业务需求和用户体验来决定。

FMP与英雄渲染时间非常相似，但它们不一样的地方在于FMP不区分内容是否有用，不区分渲染出的内容是否是用户关心的。

### 1.2 设定目标

- 100毫秒的界面响应时间与60FPS
- 速度指标（Speed Index）小于1250ms
- 3G网络环境下可交互时间小于5s
- 重要文件的大小预算小于170kb

以上四种指标的设定都**有据可循**。详细信息请查看[RAIL](https://developers.google.com/web/fundamentals/performance/rail?hl=zh-cn)性能模型。

## 2. 编码优化

编码优化涉及到应用的运行时性能，本小节介绍几个可以提升程序运行时性能的建议。

### 2.1 数据读取速度

事实上数据访问速度有快慢之分，下面列出几个影响数据访问速度的因素：

- **字面量**与**局部变量**的访问速度最快，数组元素和对象成员相对较慢；
- 变量从**局部作用域到全局作用域**的搜索过程越长速度越慢；
- 对象**嵌套的越深，读取速度就越慢**；
- 对象在**原型链中存在的位置越深，找到它的速度就越慢**。

> 推荐的做法是缓存对象成员值。**将对象成员值缓存到局部变量中会加快访问速度**（空间换时间）。

### 2.2 DOM

现代浏览器会对频繁的回流或重绘操作进行优化，浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。应用在运行时，性能的瓶颈主要在于**DOM操作的代价非常昂贵**，下面列出一些关于DOM操作相关提升性能的建议：

- （减少强制同步布局）在JS中**对DOM进行访问的代价非常高**，例如`getComputedStyles()` `getBoundingClientRect()`会强制触发重绘立即清空队列确保获取到当前最新的样式。请尽可能减少强制同步布局（**建议可以适当地缓存DOM属性和元素**）；
- （避免频繁操作 DOM）**重排与重绘的代价非常昂贵。**如果操作需要进行多次重排与重绘，**建议先让元素脱离文档流，处理完毕后再让元素回归文档流，这样浏览器只会进行两次重排与重绘**（脱离时和回归时），例如插入大量节点的情况，可以考虑在；
- 开启GPU加速
- 善于使用**事件委托**。

### 2.3 流程控制

下面列出一些流程控制相关的一些可以略微提升性能的细节，这些细节在大型开源项目中大量运用（例如Vue）：

- 避免使用`for...in`（它能**枚举到原型**，所以很慢）；
- 在JS中**倒序循环**会略微提升性能；
- 减少迭代的次数；
- **基于循环的迭代比基于函数的迭代快8倍**；
- **用Map表代替大量的`if-else`和`switch`会提升性能**；

## 3. 静态资源优化

Web应用的运行离不开静态资源，所以对静态资源的优化至关重要。

### 3.1 使用`Brotli`或`Zopfli`进行纯文本压缩

在最高级别的压缩下Brotli会非常慢（但较慢的压缩最终会得到更高的压缩率）以至于服务器在等待动态资源压缩的时间会抵消掉高压缩率带来的好处，但它非常适合静态文件压缩，因为它的解压速度很快。使用Zopfli压缩可以比Zlib的最大压缩提升3％至8％。

### 3.2 图片优化

尽可能通过`srcset`，`sizes`和`<picture>`元素使用**响应式图片**。还可以通过`<picture>`元素使用WebP格式的图像。响应式图片可能大家未必听说过，但响应式布局大家肯定都听说过。响应式图片与响应式布局类似，它可以在不同屏幕尺寸与分辨率的设备上都能良好工作（比如自动切换图片大小、自动裁切图片等）。

当然，如果您不满足这种尺度的优化，还可以对图片进行更深层次的优化。例如：模糊图片中不重要的部分以减小文件大小、使用自动播放与循环的HTML5视频替换GIF图，因为**视频比GIF文件还小**（好消息是未来可以通过`img`标签加载视频）。

更多图片优化可以看我的另一篇文章：[《图像优化原理》](https://github.com/berwin/Blog/issues/28)

## 4. 交付优化

交付优化指的是对页面加载资源以及用户与网页之间的交付过程进行优化。

### 4.1 异步无阻塞加载JS

JS的加载与执行会阻塞页面渲染，可以将Script标签放到页面的最底部。但是更好的做法是异步无阻塞加载JS。有多种无阻塞加载JS的方法：`defer`、`async`、动态创建`script`标签、使用XHR异步请求JS代码并注入到页面。

但更推荐的做法是使用`defer`或`async`。如果使用`defer`或`async`请将Script标签放到`head`标签中，以便让浏览器更早地发现资源并在后台线程中解析并开始加载JS。

### 4.2 使用`Intersection Observer`实现懒加载

懒加载是一个比较常用的性能优化手段，下面列出了一些常用的做法：

- 可以通过`Intersection Observer`延迟加载图片、视频、广告脚本、或任何其他资源。
- 可以**先加载低质量或模糊的图片，当图片加载完毕后再使用完整版图片替换它**。

> 延迟加载所有体积较大的组件、字体、JS、视频或Iframe是一个好主意

### 4.3 优先加载关键的CSS

CSS资源的加载对浏览器渲染的影响很大，默认情况下浏览器只有在完成`<head>`标签中CSS的加载与解析之后才会渲染页面。如果CSS文件过大，用户就需要等待很长的时间才能看到渲染结果。针对这种情况可以将首屏渲染必须用到的CSS提取出来内嵌到`<head>`中，然后再将剩余部分的CSS用异步的方式加载。可以通过[Critical](https://github.com/addyosmani/critical)做到这一点。

### 4.4 资源提示（Resource Hints）

[Resource Hints（资源提示）](https://w3c.github.io/resource-hints/)定义了HTML中的Link元素与`dns-prefetch`、`preconnect`、`prefetch`与`prerender`之间的关系。**它可以帮助浏览器决定应该连接到哪些源，以及应该获取与预处理哪些资源来提升页面性能。**

#### 4.4.1 dns-prefetch

`dns-prefetch`可以指定一个用于获取资源所需的源（origin），并提示浏览器应该尽可能早的解析。

```
<link rel="dns-prefetch" href="//example.com">
```

#### 4.4.2 preconnect

`preconnect`用于**启动预链接，其中包含DNS查找，TCP握手，以及可选的TLS协议，允许浏览器减少潜在的建立连接的开销。**

```
<link rel="preconnect" href="//example.com">
<link rel="preconnect" href="//cdn.example.com" crossorigin>
```

#### 4.4.3 prefetch

`Prefetch`用于标识下一个导航可能需要的资源。浏览器会获取该资源，一旦将来请求该资源，浏览器可以提供更快的响应。

```
<link rel="prefetch" href="//example.com/next-page.html" as="html" crossorigin="use-credentials">
<link rel="prefetch" href="/library.js" as="script">
```

> 浏览器不会预处理、不会自动执行、不会将其应用于当前上下文。

`as`与`crossorigin`选项都是可选的。

#### 4.4.4 prerender

`prerender`用于标识下一个导航可能需要的资源。浏览器会获取并执行，一旦将来请求该资源，浏览器可以提供更快的响应。

```
<link rel="prerender" href="//example.com/next-page.html">
```

浏览器将预加载目标页面相关的资源并执行来预处理HTML响应。

### 4.5 Preload

通过一个现有元素（例如：`img`，`script`，`link`）声明资源会将获取与执行耦合在一起。然而应用可能只是想要先获取资源，当满足某些条件时再执行资源。

[Preload](https://www.w3.org/TR/preload/)提供了预获取资源的能力，可以将获取资源的行为从资源执行中分离出来。因此，Preload可以构建自定义的资源加载与执行。

例如，应用可以使用Preload进行CSS资源的预加载、并且同时具备：高优先级、不阻塞渲染等特性。然后应用程序在合适的时间使用CSS资源：

```
<!-- 通过声明性标记预加载 CSS 资源 -->
<link rel="preload" href="/styles/other.css" as="style">

<!-- 或，通过JavaScript预加载 CSS 资源 -->
<script>
var res = document.createElement("link");
res.rel = "preload";
res.as = "style";
res.href = "styles/other.css";
document.head.appendChild(res);
</script>
<!-- 使用HTTP头预加载 -->
Link: <https://example.com/other/styles.css>; rel=preload; as=style
```

### 4.6 快速响应的用户界面

PSI（Perceptual Speed Index，感知速度指数）是提升用户体验的重要指标，让用户感觉到页面的反馈比没有反馈体验要好很多。

可以尝试**使用骨架屏或添加一些Loading过渡动画提示用户体验**。

输入响应（Input responsiveness）指标同样重要，甚至更重要。试想，用户点击了网页后缺毫无反应会是什么心情。JS的单线程大家已经不能再熟悉，这意味着当JS在运行时用户界面处于“锁定”状态，所以JS同步执行的时间越长，用户等待响应的时间也就越长。

据调查，JS执行100毫秒以上用户就会明显觉得网页变卡了。所以要严格限制每个JS任务执行时间不能超过100毫秒。解决方案是可以**将一个大任务拆分成多个小任务分布在不同的Macrotask中执行（通俗的说是将大的JS任务拆分成多个小任务异步执行）。或者使用WebWorkers，它可以在UI线程外执行JS代码运算，不会阻塞UI线程，所以不会影响用户体验（使用加载态代替）。**

> 应用越复杂，主动管理UI线程就越重要

## 5. 构建优化

现代前端应用都需要有构建的过程，项目在构建过程中是否进行了合理的优化，会对Web应用的性能有着巨大的影响。例如：**影响构建后文件的体积、代码执行效率、文件加载时间、首次有效绘制指标等**。

### 5.1 使用预编译

拿Vue举例，如果您使用单文件组件开发项目，组件会在编译阶段将模板编译为渲染函数。最终代码被执行时可以直接执行渲染函数进行渲染。而如果您没有使用单文件组件预编译代码，而是在网页中引入`vue.min.js`，那么应用在运行时需要先将模板编译成渲染函数，然后再执行渲染函数进行渲染。相比预编译，多了模板编译的步骤，所以会浪费很多性能。

### 5.2 使用 Tree-shaking、Scope hoisting、Code-splitting

Tree-shaking是一种在构建过程中清除无用代码的技术。使用Tree-shaking可以减少构建后文件的体积。

目前Webpack与Rollup都支持`Scope Hoisting`。它们可以检查`import`链，并尽可能的将散乱的模块放到一个函数中，前提是不能造成代码冗余。所以只有被引用了一次的模块才会被合并。使用`Scope Hoisting`可以让代码体积更小并且可以降低代码在运行时的内存开销，同时它的运行速度更快。前面2.1节介绍了变量从局部作用域到全局作用域的搜索过程越长执行速度越慢，`Scope Hoisting`可以减少搜索时间。

**`code-splitting`是Webpack中最引人注目的特性之一。此特性能够把代码分离到不同的`bundle`中，然后可以按需加载或并行加载这些文件。`code-splitting`可以用于获取更小的`bundle`，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。**

### 5.3 服务端渲染（SSR）

单页应用需要等JS加载完毕后在前端渲染页面，也就是说在JS加载完毕并开始执行渲染操作前的这段时间里浏览器会产生白屏。服务端渲染（Server Side Render，简称SSR）的意义在于弥补主要内容在前端渲染的成本，减少白屏时间，提升首次有效绘制的速度。可以使用服务端渲染来获得更快的首次有效绘制。

比较推荐的做法是：**使用服务端渲染静态HTML来获得更快的首次有效绘制，一旦JavaScript加载完毕再将页面接管下来。**

### 5.4 使用`import`函数动态导入模块

使用`import`函数可以在运行时动态地加载ES2015模块，从而实现按需加载的需求。

这种优化在单页应用中变得尤为重要，在切换路由的时候动态导入当前路由所需的模块，会避免加载冗余的模块（试想如果在首次加载页面时一次性把整个站点所需要的所有模块都同时加载下来会加载多少非必须的JS，应该尽可能的让加载的JS更小，只在首屏加载需要的JS），但这种优化不是绝对的，如果页面中的资源都是立即会用到的，频繁地懒加载资源反而是一种负优化。

> 使用静态`import`导入初始依赖模块。其他情况下使用动态`import`按需加载依赖

### 5.5 使用HTTP缓存头

**正确设置`expires`，`cache-control`和其他HTTP缓存头**。推荐使用`Cache-control: immutable`避免重新验证。

## 6. 其他

其他一些值得考虑的优化点：

- 开启HTTP2，例如HTTP的主动推送能力；
- 优化CDN缓存；
- 优化字体；
- 其他垂直领域的性能优化

## 7. 性能监控

最后，你可能需要一个性能检测工具来持续监视网站的性能。

> 性能优化方面的思路：
>
> [写给中高级前端关于性能优化的9大策略和6大指标 | 网易四年实践](https://juejin.cn/post/6981673766178783262)
>
> [前端性能优化 24 条建议（2020）](https://juejin.cn/post/6892994632968306702)
>
> [工作中如何进行前端性能优化(21种优化+7种定位方式)](https://juejin.cn/post/6904517485349830670)
>
> JS角度：
>
> - （内存泄漏）使用性能分析工具，阻止**内存泄漏**
> - （本地缓存）善用**WEB本地存储进行缓存**，减少内存使用；
> - （中间变量缓存）尽量减少对象深层嵌套和原型链的取值方式，及时缓存中间变量，使用循环时缓存数组长度而非重复访问长度；
> - （计算属性缓存）缓存DOM计算属性避免多次触发回流；
> - （DOM操作批处理）避免过多DOM操作，尽量在内存中进行DOM的操作，一次性挂载到页面；
> - （事件委托）尽量使用事件委托，可以有效减少闭包以及**事件处理函数的内存占用**；
> - （位运算符）可以使用位操作符加快部分运算逻辑；
>
> CSS：
>
> - （精简代码）避免过度约束（尽量精简合并规则），移除空规则选择器，移除无效属性以**精简代码**；值为0时不添加任何单位；
> - （减少后代选择器）减少后代选择器使用，减少多种选择器的杂糅，提高选择器效率；
> - （减少`!important`）尽量避免使用!important，减少后期修改异常行为；
> - （减少表达式）尽量**避免表达式**，因为可能会带来严重性能问题；
> - （减少内联）减少HTML**内联样式嵌套**；
> - （类名修改样式）以**类名的方式一次性替换样式减少样式修改**；
> - 不要滥用浮动；
> - 不要**滥用Web字体**，因为Web字体会阻塞；
> - 不申明过多font-size；
> - （开启GPU加速）适当的将需要频繁更改的元素开启复合图层；
>
> HTML文档：
>
> - （视口协商）设置viewport进行视口协商；
> - （精简DOM结构）减少不必要DOM节点；
> - （语义化）尽量遵循语义化（SEO优化）；
> - （SSR）考虑使用SSR加快首屏内容的加载（SEO优化）；
>
> V8：
>
> - （LightHouse）通过LightHouse获取页面性能指标报告；
> - （Performance）通过Performance面板获取页面性能瓶颈报告；
> - （Performance API）通过Performance API获取页面各个阶段精确时间；
> - 压缩代码体积/减少嵌套函数以降低编译时间；
> - （入参一致优化）保证函数入参类型一致让V8自动优化代码；
>
> 优化网络：
>
> - （缓存优化）针对不同的资源采用不同的**资源缓存策略**；
> - （避免重定向导致重新加载）SPA尽量**避免重定向**导致重新加载；
> - （防止JS阻塞）防止**脚本阻塞**；
> - （开启CSS并行加载）在头部放置外链样式表**提前开启异步加载**；
> - （减少请求次数、减少请求携带Cookie）**减少、合并HTTP请求**，减少**不必要的cookie携带**；
> - （非必要JS资源延后加载）**异步加载非必要的资源（JS）**，防止非必要资源阻塞核心资源；
> - （开启长连接复用连接）使用HTTP长连接，设置`Connection: Keep-alive`，开启`HTTP2`以及主动推送等能力；
> - （使用CDN加速）使用CDN内容分发网络；
>
> 压缩文件
>
> - 合理的进行代码分割（HTTP2 采取多路复用，可以很好适应，但是，在 HTTP/1 环境中还会有额外的请求开销）；
> - （压缩代码）开启GZIP压缩，压缩代码，使用Minify精简代码；
> - （精灵图）合成小图标为精灵图；
> - （CSS修饰图像）修饰类图像使用CSS；
> - （SVG）优先使用SVG；
> - （压缩图片）压缩图像到合适的质量；
> - （Base64）用Base64代替小质量图像；
> - 使用CDN加载静态资源；
> - （媒体查询）使用srcset指定不同dpr下的加载资源；
>
> 预加载：
>
> - （pre-fetch）开启pre-fetch进行资源预取
> - （dns-prefetch）开启DNS预解析dns-prefetch，提高建立连接的速度；
> - （pre-render）开启预渲染pre-render；
>
> 首屏：
>
> - 构建
>   - `GZIP`压缩
>   - `Compress`精简
>   - `Tree-shaking`移除非必要代码；
>   - 缓存；
> - JS
>   - 使用`JS`的异步加载，防止脚本阻塞`DOM`解析；
>   - 非必要**第三方脚本**等进行预取而非加载，防止阻塞渲染；
>   - 使用按需加载；
> - CSS
>   - 精简关键CSS代码并进行合并，阻止非关键CSS代码阻塞；
>   - 可以考虑使用`Critial CSS`技术；
>   - 避免使用`@import`；
>   - 通过标签的媒体查询属性动态加载对应尺寸的样式；
> - HTML
>   - 使用SSR；
> - 用户体验
>   - 使用骨架屏；
>
> 高频事件：
>
> - 节流；
> - 防抖；
>
> 密集型计算
>
> - 时间分片；
> - 工作者线程；
>
> 性能调试：
>
> - Performance面包记录和分析页面实时运行时的所有活动；
> - LightHouse面板生成性能报告。

# 8.Performance面板

[快速掌握 Performance 性能分析：一个真实的优化案例](https://juejin.cn/post/7046805217668497445)

[我的前端性能优化知识体系](https://juejin.cn/post/7063754993072865287)

# 9.Lighthouse面板

[如何将 Lighthouse Performance 评分从 20 提高到 96](https://juejin.cn/post/7012567366198362120)

