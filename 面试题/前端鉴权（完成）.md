# 前端鉴权方式

[参考](https://tsejx.github.io/blog/authentication/)

## 常见的鉴权方式

1. HTTP Basic Authentication(HTTP 基本认证)
2. session - cookie
3. Token验证(包括JWT、SSO)
4. OAuth(开放授权)

## 一、HTTP Basic Authentication

这种认证方式是浏览器遵守http协议实现的基本授权方式，HTTP协议进行通信的过程中，HTTP协议定义了基本认证认证允许HTTP服务器对客户端进行用户身份证的方法。目前基本没有再使用这种认证方式的，一些老项目的内网认证可能还会有。

### 认证过程： 

1. 客户端向服务器请求数据，请求的内容可能是一个网页或者是一个ajax异步请求，此时，假设客户端尚未被验证，则客户端提供如下请求至服务器：

   ```http
     Get /index.html HTTP/1.0
     Host:www.google.com
   ```

2. 服务器向客户端发送验证请求代码401,（`WWW-Authenticate: Basic realm=”google.com”`这句话是关键，如果没有，客户端不会弹出用户名和密码输入界面）服务器返回的数据大抵如下：

   ```http
     HTTP/1.0 401 Unauthorised 
     Server: SokEvo/1.0 
     WWW-Authenticate: Basic realm=”google.com” 
     Content-Type: text/html 
     Content-Length: xxx
   ```

3. 当符合http1.0或1.1规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。

4. 用户输入用户名和密码后，将**用户名及密码以base64编码(base64不安全)**，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：

   ```http
     Get /index.html HTTP/1.0
     Host:www.google.com
     Authorization: Basic d2FuZzp3YW5n
     
   ```

   注：d2FuZzp3YW5n表示加密后的用户名及密码（用户名：密码 然后通过base64编码，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）。

5. 服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端。

### 实现效果：

客户端未认证的时候，会弹出用户名密码输入框，这个时候请求时属于pending状态， 这个时候其实服务当用户输入用户名密码的时候客户端会再次发送带Authentication头的请求。

## 二、session-cookie

这个方式是利用服务器端的session（会话）和浏览器端的cookie来实现前后端的认证，**由于http请求时是无状态的**，服务器正常情况下是不知道当前请求之前有没有来过，这个时候我们如果要记录状态，就需要在服务器端创建一个会话(session),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建session，如果有则已经认证成功了，否则就没有认证。

### 认证过程

1. 服务器在接受客户端首次访问时在服务器端创建session，然后保存session(我们可以将session保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串sessionid，然后在响应头中种下这个唯一标识字符串。
2. 签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）
3. 浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的请求头中会带上该域名下的cookie信息，
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。

### 弊端

1. **服务器内存消耗大**: 用户每做一次应用认证，应用就会在服务端做一次记录，以方便用户下次请求时使用，通常来讲session保存在内存中，随着认证用户的增加，服务器的消耗就会很大。
2. **易受到CSRF攻击**: 基于cookie的一种跨站伪造攻击，基于cookie来进行识别用户的话，用户本身就携带了值，cookie被截获，用户就很容易被伪造（重放攻击）。

## 三、Token

token是用户身份的验证方式，我们通常叫它：令牌。当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，**无需再次带上用户名和密码。**最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免**多次查库**。我们可以把Token想象成一个安全的护照。你在一个安全的前台验证你的身份（通过你的用户名和密码），如果你成功验证了自己，你就可以取得这个。当你走进大楼的时候（试图从调用API获取资源），你会被要求验证你的护照，而不是在前台重新验证。

### 验证流程

1. 客户端使用**用户名跟密码**请求登录；
2. 服务端收到请求，去**验证用户名与密码**；
3. 验证成功后，服务端会**签发一个 Token**，再把这个 Token **发送给客户端**；
4. 客户端**收到 Token** 以后可以把它**存储起来**，比如放在 Cookie 里或者 Local Storage 里（推荐存储在cookie中）；
5. 客户端**每次向服务端请求资源的时候需要带着服务端签发的 Token**；
6. 服务端收到请求，然后去**验证客户端请求里面带着的 Token**，如果验证成功，就向客户端返回请求的数据。

> 在XSS面前，即便你的httpOnly cookie无法被获取，黑客依然可以诱导或者在用户毫不知情的情况下做任何事情。记住！黑客的代码和你的代码一样被用户信任！XSS只要存在那么无论将信息存储在cookie还是localStorage，都是一样脆弱不堪，唯一的区别只是获取难度。XSS漏洞很难被发现，因为一个网站的构建不仅仅是基于你自己的代码，第三方的代码同样已可能存在XSS。

### 优点

1. Token 完全由应用管理，所以它可以避开同源策略. (Cookie是不允许垮域访问的,token不存在)；
2. Token 可以避免 CSRF 攻击(因为可以存储在localStorage中，CSRF携带cookie也没有用，但是无法避免XSS攻击通过JS获取token)；
3. Token 可以是无状态的，可以在多个服务间共享；
4. Token 支持手机端访问(Cookie不支持手机端访问)。

服务器只需要对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证.所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，**它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了**，这就为应用的扩展提供了便利，解决了session扩展性的弊端。

### 缺点

1. **占带宽**: 正常情况下token要比 session_id更大，需要消耗更多流量，挤占更多带宽。(不过几乎可以忽略)。
2. **性能问题**: 相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证，其实Token相比于session-cookie来说就是一个"**时间换空间**"的方案。
3. **权限收回**：以JWT为例。如果Access Token是JWT形式签发，资源服务可以使用验证签名的方式判断是否合法，只需要把签名密钥在资源服务同步一份即可。也有使用非对称加密的，授权服务使用私钥签发，资源服务使用公钥验证。由于JWT允许携带一些信息，用户，权限，有效期等，因此资源服务判断JWT合法之后可以继续根据携带信息来判断是否可访问资源。**仅此而已，这样的好处是可以快速验证有效性，坏处是Access Token一旦签发，将很难收回，只能通过过期来失效。**

### Token VS. Session

1.  **使用Token,服务端不需要保存状态.** 在session中sessionid 是一个唯一标识的字符串，服务端是根据这个字符串，来查询在服务器端保持的session，这里面才保存着用户的登陆状态。但是token本身就是一种登陆成功凭证，他是在登陆成功后根据某种规则生成的一种信息凭证，他里面本身就保存着用户的登陆状态。服务器端只需要根据定义的规则校验这个token是否合法就行。
2.  **Token不需要借助cookie的.** session-cookie是需要cookie配合的，那么在http代理客户端的选择上就只有浏览器了，因为只有浏览器才会去解析请求响应头里面的cookie,然后每次请求再默认带上该域名下的cookie。但是我们知道http代理客户端不只有浏览器，还有原生APP等等，这个时候cookie是不起作用的，或者浏览器端是可以禁止cookie的，但是token 就不一样，他是登陆请求在登陆成功后再请求响应体中返回的信息，客户端在收到响应的时候，可以把他存在本地的cookie，storage，或者内存中，然后再下一次请求的请求头重带上这个token就行了。简单点来说cookie-session机制他限制了客户端的类型，而**token验证机制丰富了客户端类型。**
4. **可扩展性。**token验证本身是**比较灵活**的，一是token的解决方案有许多，常用的是JWT，二来我们可以基于token验证机制，专门做一个鉴权服务，用它向多个服务的请求进行统一鉴权。

```
  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant --------->|               |
  |        |                                           |               |
  |        |<-(B)----------- Access Token -------------|               |
  |        |               & Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ---->|          |   |               |
  |        |                            |          |   |               |
  |        |<-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token ----------->|               |
  |        |                                           |               |
  |        |<-(H)----------- Access Token -------------|               |
  +--------+           & Optional Refresh Token        +---------------+
               Figure 2: Refreshing an Expired Access Token
```



### Updated Token / Refresh Token

[参考链接](https://juejin.cn/post/6859572307505971213#heading-2)

> (A) 客户端向授权服务器请求Access Token（整个认证授权的流程，可以是多次请求完成该步骤）
>
> (B) 授权服务器验证客户端身份无误，且请求的资源是合理的，则颁发Access Token 和 Refresh Token，可以同时返回Access Token的过期时间等附加属性。
>
> (C) 带着Access Token请求资源
>
> (D) 资源服务器验证Access Token有效则返回请求的内容。
>
> (E) **注意：** 上面的(C)(D)步骤可以反复进行，直到Access Token过期。 如果客户端在请求之前就能判断Access Token已过期或临近过期（下发过期时间），就可以直接跳到步骤(G)。否则，就会再请求一次，也就产生了本步骤。
>
> (F) 当Access Token无效的时候，资源服务器会拒绝响应资源并返回Token无效的错误。
>
> (G) 客户端重新向授权服务器请求Access Token，但是这次只需带着Refresh Token即可，而不需要用户再执行认证和授权的流程。这样就可以做到用户无感。
>
> (H) 授权服务器验证Refresh Token，如果有效，则签发新的Access Token（或者同时下发一个新的Refresh Token）。

#### Updated Token

Token是访问特定资源的凭证，出于安全考虑，肯定是要有过期时间的。要不然一次登录便可能一直使用，那token认证还有什么意义? token可定是有过期时间的，一般不会很长，不会超高一个小时。

#### Refresh Token

为什么需要Refresh token？

如果token过期了，就要重新获取。继续重复第一次获取token的过程(比如登录，扫描授权等)，每一小时就必须获取一次。这样做是非常不好的用户体验。为了解决这个问题，于是就有了refresh token。通过refresh token去重新获取新的 token。refresh token，也是加密字符串，并且和token是相关联的。与获取资源的token不同，**refresh token的作用仅仅是获取新的token**，因此其作用和安全性要求都较低，所以其过期时间也可以设置得长一些，可以以天为最小单位。当然，如果refresh token过期了，还是需要重新登录验证的。

可否直接让Access Token具有更长的有效期？

不可以，这样是不安全的。举个例子，某个用户登录成功，获得了一个可以发帖的Access Token，这时管理员发现他发布垃圾内容吊销了发帖权限，而这个信息一般属于授权服务管理，也就是说他下次向授权服务请求Access Token将不会得到发帖权限。但是如果用户之前拿到的Access Token是长期有效的，那么这个用户就可以发帖很长时间。如果Access Token在短时间内失效，那么他必须重新去授权服务请求，这时授权服务将不会颁发具备发帖权限的Access Token。第二个例子，如果Access Token具有较长的有效期，一旦被盗用，攻击者就可以拿Access Token使用很长时间。聪明的你可能会想到，攻击者可以同时盗取Refresh Token。[RFC6749](https://link.juejin.cn?target=http%3A%2F%2Fwww.rfcreader.com%2F%23rfc6749)第10节中有说明，授权服务**必须维护Refresh Token与客户端的绑定关系**，也就是说只有合法用户的客户端（可通过IP、UA等资料判断）来请求是可以通过的。退一步讲，如果攻击者模拟了客户端可以执行刷新请求，那么就要看谁先刷。由于授权服务**可以设置Refresh Token一次有效**，因此不管哪个先刷新，另一个人刷新就会报错。如果用户先刷新，攻击者以Access Token和Refresh Token的双重失效结束游戏。如果攻击者先刷新了，合法用户就会收到报错信息，授权服务会引导用户从上图的步骤(A)重新开始认证，从而把有效的Refresh Token拿回到合法用户这里。

### JSON Web Token(JWT)

#### JWT原理

JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。之后用户与服务器通信的时候，服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，**会加上签名**。JWT最大的特点就是: **服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。**

#### JWT 的数据结构

它是一个很长的**字符串**，中间用点（.）分隔成三个部分。

分别是：Header.Payload.Signature

- **Header :** 部分是一个 JSON 对象，描述 JWT 的元数据，例如:`{ "alg": "HS256","typ": "JWT"}`.alg属性表示签名的算法.默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。头部的 JSON 对象使用 Base64URL 算法转成字符串。

- **Payload:** 部分也是一个 JSON 对象，用来存放实际需要传递的数据。这个 JSON 对象也要使用 Base64URL 算法转成字符串。

**注意:** **JWT 默认是不加密的，任何人都可以读到，所以不要把`秘密信息`放在这个部分。**

- **Signature:** 部分是对前两部分的签名，**防止数据篡改。** 首先，需要指定一个密钥（secret）。这个密钥**只有服务器才知道，不能泄露给用户**。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256）.

#### JWT 的几个特点

- JWT 默认是不加密，但也是可以加密的。**生成原始 Token 以后，可以用密钥再加密一次**。
- JWT **不加密的情况下，不能将秘密数据写入 JWT**。
- JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
- JWT 的最大缺点是，**由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。**
- JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，**JWT的有效期应该设置得比较短。（或者使用双token机制）** 对于一些比较重要的权限，使用时应该再次对用户进行认证。
- 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。
- 如若token存放在cookie中，警惕XSS攻击；如若token存放在localStorage中，警惕CSRF攻击。

#### JWT使用流程

首次登录时，后端服务器判断用户账号密码正确之后，根据用户id、用户名、定义好的秘钥、过期时间生成 token ，返回给前端； 前端拿到后端返回的 token ,存储在 localStroage 和 Vuex 里； 前端每次路由跳转，判断 localStroage 有无 token ，没有则跳转到登录页，有则请求获取用户信息，改变登录状态； 每次请求接口，在 Axios 请求头里携带 token; 后端接口判断请求头有无 token，没有或者 token 过期，返回401； 前端得到 401 状态码，重定向到登录页面。

#### 后端主动让JWT失效的方法

前面说过JWT一旦签发了，就不再收服务端控制了。因为它在服务端没有记录，是无状态的，是它最大的优点也是最大的缺点。这样就会造成一种**不可控性**。例如：如果用户修改了密码，那他之前未到期的token怎么废弃掉？此时服务端是没有记录的，它是不知道哪些未到期的token是被废弃了的。解决这个问题,其实是**没有完美的方法的。** 都**需要后端添加状态**，只是那种方法开销最小。

目前常见的处理方法有：

- 将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。
- **维护一个 Token 黑名单，失效则加入黑名单中(用的比较多)**。
- **在 JWT 中增加一个版本号字段，失效则改变该版本号**。
- **在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。**

这里就简单说下第二种方法：黑名单

- 在签发的jwt中payload加入一个伪随机字符的字段`token_id`。
- 在服务端的分布式缓存上保存一份“groupId”黑名单。如果用户的jwt重置密码等需要作废已经签发但未过期的jwt时，就将该之前用户的“token_id”存入到黑名单中。并分配给他一个新的“tokenid”到token中。
- 存入到黑名单中的“token__id”会设置一个过期时间（一般是根据token颁发的有效期来决定）。过期后“token_id”自动从黑名单中删除。
- 所有需要做JWT有效性校验的服务器，启动时访问分布式缓存，将黑名单下载到本地内存。并且订阅分布式缓存的消息推送功能，在黑名单发生增删的时候，接收推送消息同步修改内存中的黑名单列表。
- 服务器做JWT校验的时候，除了校验过期时间，还要查询内存中的黑名单列表。若在黑名单中，则判定该JWT为失效。

结论：虽然黑名单还是做了分布式存储，但黑名单本身的体积和使用频率却很低，所以开销很小.

### SSO单点登录

#### 概念

单点登录（Single Sign On），简称为 SSO，是目前**比较流行的企业业务整合的解决方案之一**。SSO的定义是在多个应用系统中，**用户只需要登录一次就可以访问所有相互信任的应用系统。**SSO一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作，当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证。

#### 单点登录流程 

[参考](https://www.cnblogs.com/parry/archive/2010/10/28/SSO_for_cross_domain_ASPNET_applications_Part_I_The_design_blue_print.html?spm=a2c6h.12873639.0.0.7052441cOZWQiB)

[参考](https://developer.aliyun.com/article/626749)

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/21/1690f49acf068537~tplv-t2oaga2asx-watermark.awebp)



- 用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
- sso认证中心发现用户未登录，将用户引导至登录页面
- 用户输入用户名密码提交登录申请
- sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌
- sso认证中心带着令牌跳转回最初的请求地址（系统1）
- 系统1拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统1
- 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源
- 用户访问系统2的受保护资源
- 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数
- sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌
- 系统2拿到令牌，去sso认证中心校验令牌是否有效
- sso认证中心校验令牌，返回有效，注册系统2
- 系统2使用该令牌创建与用户的局部会话，返回受保护资源

用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系：

- 局部会话存在，全局会话一定存在
- 全局会话存在，局部会话不一定存在
- 全局会话销毁，局部会话必须销毁

> 一句话概括：现有全局会话再有局部会话。

**注销：**

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/21/1690f4a13430cf2a~tplv-t2oaga2asx-watermark.awebp)



sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。

- 用户向系统1发起注销请求
- 系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求
- sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址
- sso认证中心向所有注册系统发起注销请求
- 各注册系统接收sso认证中心的注销请求，销毁局部会话
- sso认证中心引导用户至登录页面

## OAuth 2.0

> OAuth就是在原有认证系统的基础上再添加一个“授权层”，第三方不能直接访问原有认证系统，但是可以通过授权层获取令牌，通过该令牌对用户主动开放的权限进行使用。

OAuth即开发授权，其实和SSO比较像。它**允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息**，而不需要将**用户名和密码**提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供OAuth认证服务的厂商有QQ、微信、微博等。

[参考资料](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)              

