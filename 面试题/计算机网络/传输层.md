# 传输层

**网络层**可以把数据从**一个主机传送到另一个主机**，但是没有和**进程**建立联系。**传输层**就是将进程和收到的数据联系到一起，使数据**能够为应用服务**，所以说传输层是**主机**才有的层次。

## 传输层的两个协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630094727731.png?raw=true)

## 传输层的寻址和端口

**端口号只用于计算机分辨本地进程**，总共有`2^16=65536`种端口号，**端口号有很多种，不能随便使用**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095024127.png?raw=true)

### 常见的应用程序端口号

### ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095258962.png?raw=true)

## `UDP`协议（`User Datagram Protocol `）

因为`UDP`一次发送一个**完整报文不会分片**，所以需要应用层传输过来的数据**不要太大**，否则网络层分片任务就很重，但是也**不能太小**，不然效率较低，`UDP`适合一些实时应用，因为**实时应用延迟要求高，需要立即响应**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095616466.png?raw=true)

### `UDP`首部格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020063010003161.png?raw=true)

### `UDP`的校验位构成

这里的**伪首部**只是用来计算**检验和**的，计算完了就丢弃，可以见下`UDP`的校验方式。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630105441329.png?raw=true)

`UDP`计算校验和的方法和`IP`数据报首部校验和的方法相似。不同的是：`IP`数据报校验和只校验`IP`数据报的首部，但`UDP`的校验和是把**首部和数据部分**一起都检验。

`UDP`的校验和需要计算`UDP`首部加数据荷载部分，但也需要加上`UDP`伪首部。这个伪首部指，源地址、目的地址、`UDP`数据长度、协议类型（`0x11`），协议类型就一个字节，但需要补一个字节的`0x0`，构成`12`个字节。伪首部+`UDP`首部+数据一起计算校验和。

`UDP`检验和的计算方法是：

1.按每`16`位求和得出一个`32`位的数；
2.如果这个`32`位的数，高`16`位不为`0`，则高`16`位加低`16`位再得到一个`32`位的数；
3.重复第`2`步直到高`16`位为`0`，将低`16`位取反码，得到校验和。

接收端：

与发送端的时候不同的是，此时检验和字段不是`0`，按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和，如果最后得到**结果全`1`**就是没问题，否则丢弃。

### `UDP`实际例子

![image-20220102105404182](https://github.com/NoAlligator/pico/blob/main/img/image-20220102105404182.png?raw=true)

## `TCP`协议（`Transmission Control Protocol`）

### `TCP`的特点

`TCP`必须要建立连接之后才可以进行数据交换，所以`TCP`是面向连接的。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630194247441.png?raw=true)

`TCP`传输数据是**随机切割数据**的：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020063020421472.png?raw=true)

#### `TCP`报文段的首部

见上图，可以看到`TCP`是将**数据随机分割**后加上`TCP`头传输的，所以序号就是为了**标记这些随机分割之后的数据**，这里把**第一个字节的编号**当成**序号**。

**确认号**就是收到之后做一下标记，代表这之前的都收到了，希望收到的**下一个编号的数据**就是确认号打头的那个数据。

**偏移量**就是为了标记一下距离`TCP`开始多少字节是数据，这里的单位是`4B`，这个偏移量就是`TCP`首部长度。

**窗口**就是接收方告诉**发送方**，**还有多少地方（缓存）可以放数据**。

**紧急指针**就是告诉`TCP`从哪里到**哪里是紧急数据**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630210441410.png?raw=true)

#### `TCP`报文段首部的六个控制位

##### 紧急位`URG`

发送端的优先传输，`URG`的特点就是让数据**插队**，`URG=1`的就会在缓存中被提前到**第一个**传输。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211126589.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211151331.png?raw=true)

##### 确认位`ACK`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211354251.png?raw=true)

##### 推送位`PSH`

就是接收端的`URG`，将`PSH=1`的数据尽快接收，注意一下，如果没有`PSH`，一般都是接收方缓存满了之后再将数据发送到主机。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212045298.png?raw=true)

##### 复位`RST`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212049447.png?raw=true)

##### 同步位`SYN`

`A`和`B`主机要**建立连接**，就`A`先发一个报文，其中`SYN=1`，`B`收到之后也回复一个`SYN=1`的报文，代表**接受连接**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212152221.png?raw=true)

##### 中止位`FIN`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212056958.png?raw=true)

### `TCP`连接管理

#### `TCP`三次握手

注释：
第一段的意思是
SYN=1：(A)要建立连接了！
seq=x（随机）：因为还没有数据，所以写什么都无所谓

第二段的意思是
SYN=1：我(B)同意你(A)建立连接！
ACK=1：连接建立了，之后的ACK必须都置为1
seq=y（随机）：因为还没有数据，所以写什么都无所谓
ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据

第三段的意思是
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0
ACK=1：连接建立了，之后的ACK必须都置为1
seq=x+1：我(A)发送的报文段的第一个字节就是x+1
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据

注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630213814996.png?raw=true)

####   `TCP`三次握手特定导致的`SYN`洪泛攻击

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630214925395.png?raw=true)

#### `TCP`四次挥手（连接释放）

注释：
第一段的意思是
FIN=1：(A)要释放连接了！
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的

第二段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）

第三段的意思是
FIN=1：(B)要释放连接了！
ACK=1：连接建立了，之后的ACK必须都置为1
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）

第四段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据

为什么需要等待计时2MSL？
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630215522825.png?raw=true)

#### `TCP`可靠传输

`TCP`是提供可靠传输，`UDP`这种本身还是不可靠传输的就再靠**应用层**解决可靠性问题。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630220542461.png?raw=true)

##### 序号

就是`TCP`根据下方数据链路层的`MTU`（**最大传输单元**）来随即将**数据切割**成好几段并且进行**编号**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630221424853.png?raw=true)

##### 确认

发送方每一次发送数据之后都需要接收方进行确认。`TCP`使用的是**累计确认机制**，就是从**第一个丢失的字节开始请求丢失的报文段**。如图中`456`丢失，`78`到达，但仍然请求发送的数据序号是`4`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630221636424.png?raw=true)

##### 重传

为什么要使用**自适应算法**？网络环境太复杂，路径又长又短，`RTT`设置短了照顾不了距离远的，`RTT`设置长了又导致网络利用率降低，所以使用`RTTs`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630222205619.png?raw=true)

#### `TCP`流量控制

简单来说就是**接收方可以动态的发送信息告诉发送方发送窗口的大小**。接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了。接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/202006302226272.png?raw=true)

##### 计时器

在本例子中，使用的**累计确认机制**（一次回复收到`ack=201`）和**三次流量控制机制**。但是有一个情况就是，如果最后`B`不允许`A`再发送数据了，`B`在处理完数据之后想要恢复窗口大小时发送的有`rwnd`大小的数据报丢了怎么办？此时`A`有`B`的指令在前，发送窗口为`0`无法发送数据，`B`也在等待`A`回复，造成了**类似死锁**的现象。
解决方法：使用计时器，超时之后发送探测报文段。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630223616929.png?raw=true)

#### `TCP`拥塞控制

流量控制是对**单独一个**来说的，拥塞控制是**一群**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630224242515.png?raw=true)

##### 拥塞控制四种算法

这里虽然是**四种算法**，但是通常是**两两结合**进行使用。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630232411944.png?raw=true)

##### 慢开始和拥塞避免

这里开始时以指数形式增长，`ssthresh`的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。 之后一段都是线性增长，每次增加`1`，直至达到**网络拥塞状态**。瞬间将`cwnd`设置为`1`，同时调整原来的`ssthresh`的值到之前达到网络拥塞状态的`1/2`,（这里是`24`降到`12`），重复以上步骤，但是注意此时`ssthresh`变了之后**线性增长的转折点**也变了。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630232910475.png?raw=true)

#####  快重传和快恢复

这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。不同的点是快重传和快恢复算法是在收到连续的`ack`确认之后执行，这里的`ack`就是冗余`ack`，冗余`ack`的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在`cwnd`的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始（从`1`开始）。
