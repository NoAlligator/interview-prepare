# yin计算机网络概述

## 计算机网络的组成

### 组成部分

- 硬件
- 软件
- 协议

### 工作方式

- 边缘部分
  - `C/S`客户端-客户服务器方式
  - `P2P`客户端-客户端方式
- 核心部分
  - 为边缘部分服务

### 功能组成

- 通信子网：实现数据通信，`OSI`七层模型中的**网络层、数据链路层、物理层**，对应的是各种传输介质、通信设备、相应的网络协议（路由器、交换机、网桥、集线器、中继器）。
- 资源子网：实现资源共享/数据处理，`OSI`七层模型中**应用层、表示层、会话层**，对应的是实现资源共享功能的设备和软件的集合。

## 计算机网络的分类

### 按作用范围

- 广域网(WAN - Wide Area Network) 交换技术
- 城域网(MAN - Metro Area Network)
- 局域网(LAN - Local Area Network) 广播技术
- 个人区域网(PAN - Personal Area Network)

### 按使用者

- 公用网络
- 专用网络

### 按交换技术

- 电路交换
- 报文交换
- 分组交换

### 按拓扑结构

- 总线型
- 星型
- 环形
- 网状型（常用于广域网）

### 按传输技术

- 广播式网络 - 共享**公共通信信道**
- 点对点网络 - 使用**分组存储转发**和**路由存储**机制

## 网络速率相关性能指标

### 速率

定义：

连接在计算机网络上的主机在数字信道上传输数据位数的速率。

单位：

- 以**比特**计算`b/s(bps)`，`Kb/s(kbps)`，`Mb/s(mbps)`，`Tb/s`
- 以**字节**计算`B/s`，`KB/s`，`MB/s`，`TB/s`
- 换算公式：`8(K|M|T)b/s = 1(K|M|T)B/s`

### 带宽

在计算机网络中，指的是网络设备所支持的**最高速度**，单位同速率，是**理想条件下最高速率**

### 吞吐量

指的是**单位时间**内通过某个网络**数据总量**

## 时延相关指标

### 时延种类

| 名称     | 描述                                 | 计算公式                          |
| -------- | ------------------------------------ | --------------------------------- |
| 发送时延 | 数据从主机到信道上所用的时间         | 发送的数据长度/发送速率(信道带宽) |
| 传播时延 | 数据在信道上传播所花费的时间         | 信道长度/电磁波在信道上传播的速率 |
| 排队时延 | 数据在路由器前等待前面数据处理的时间 | 无计算方式                        |
| 处理时延 | 数据在路由器中处理需求的时间         | 无计算方式                        |

⭐使用高速链路(**提高网速**)，只能**减小发送时延**，无法减少其他三个时延

### 时延带宽积

公式：时延带宽积 = 传播时延 x 带宽 (计算链路上有多少比特的数据)

### 往返时延`RTT`

定义：

从**发送方发送数据**开始，到发送方**收到接收方的确认**（接收方收到数据后立即发送确认）总共经历的时延。这里的发送和接收都是从发送或接收到第一个比特开始计算。



`RTT`的大小与发送数据大小的关系：

`RTT`越大，在收到确认之前，可以发送的数据越多。



`RTT`包括：

1. 往返传播时延（传播时延 x 2）
2. 末端处理时间

利用率：

- 信道利用率 = 信道有数据通过的时间 / (有 + 无 数据通过的时间)
- 网络利用率 = 信道利用率加权平均值

### 时延和利用率的关系

利用率越高，时延越大

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227114808451.png" alt="image-20211227114808451" style="zoom:50%;" />

## 分层结构

### 为什么要分层？分层要做什么？

1. 发起通信的计算机必须将数据通信的通路进行激活。
2. 要告诉网络如何识别目的主机。
3. 发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。
4. 发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。
5. 确保差错和意外可以解决。

### 正确认识分层结构

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227120012508.png" alt="image-20211227120012508"  />

### 参考模型

#### 参考模型分类：

- `7`层`OSI`参考模型：**法定标准**
- `5`层体系结构：在`7`层`OSI`参考模型的基础上形成。
- `4`层`TCP/IP`参考模型：**事实标准**

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227205441225.png" alt="image-20211227205441225" style="zoom:50%;" />

#### `OSI`七层参考模型层次：

- **应用层**
- **表示层**
- **会话层**
- 传输层
- **网络层**
- **数据链路层**
- **物理层**

#### `OSI`七层参考模型详解：

| `OSI`层次  | 英文               | 概述                                                         | 作用                                                         |
| :--------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 应用层     | Application Layer  | **直接**为用户的**应用进程**（例如电子邮件、文件传输和终端仿真）**提供服务**。 | 典型的例子：如`HTTP`、`SMTP`、`FTP`、`DNS`等。               |
| 表示层     | Presentation Layer | 用于**处理**在两个通信系统中**交换信息的表示方式**（语法和语义） | 1.数据格式变换。2.数据加密解密。3.数据压缩和恢复。           |
| 会话层     | Session Layer      | 向表示层实体/用户进程提供**建立连接**并在连接上有序地传输数据，这是**会话**，也是**建立同步（SYN）**。 | 1.建立、管理、终止会话。2.使用校验点可使会话在通信失效时从校验点/同步点继续回复通信，实现数据同步（适用于传输大文件）。 |
| 传输层     | Transport Layer    | 负责主机中两个进程的通信，即**端到端**通讯。传输单位是**报文段或用户数据报**。 | 1.可靠传输、不可靠传输 。2.流量控制。3.复用分用。            |
| 网络层     | Network Layer      | 主要任务是把分组从**源端**传到**目的端**，为分组交换网上的不同主机提供通信服务，网络层传输单位是**数据报**。 | 1.路由选择（最佳路径）。2.流量控制。3.差错控制。4.拥塞控制。 |
| 数据链路层 | Data Layer         | 主要任务是把网络层传下来的**数据报组装成帧**。数据链路层/链路层的传输单位是帧。 | 1.成帧（定义帧的开始和结束）2.差错控制（纠错由传输层解决）。3.流量控制。4.访问（接入）控制。 |
| 物理层     | Physical Layer     | 主要任务是在物理媒体上**实现比特流的透明传输**（透明传输指不管所传数据是什么样的比特组合，都应当能够在链路上传送），物理层传输单位是比特。 | 1.定义接口特性。2.定义传输模式（单工、半双工、双工）。3.定义传输速率。4.比特同步。5.比特编码。 |

#### ISO/OSI参考模型通信过程

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227142740979.png" alt="image-20211227142740979" style="zoom:50%;" />

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227142841962.png" alt="image-20211227142841962" style="zoom:50%;" />

#### `TCP/IP`和`OSI`协议的异同点：

相同点：1.都是分层结构。2.都基于独立的协议栈的概念。3.都可以实现异构网络互联。

不同点：1.`OIS`定义三点：服务、协议、接口。2.`OSI`先出现，参考模型先于协议发明，不偏向特定的协议。3.`TCP/IP`设计之初就考虑到异构网互联的问题，将`IP`作为重要层次。

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227210842054.png" alt="image-20211227210842054" style="zoom:50%;" />

#### 五层参考模型

综合了`OSI`和`TCP/IP`的优点

![image-20211227211000473](https://github.com/NoAlligator/pico/blob/main/img/image-20211227211000473.png?raw=true)

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211227211118609.png" alt="image-20211227211118609" style="zoom:50%;" />

# 物理层

## 基本概念

物理层解决如何在连接各种计算机的传输媒体上**传输数据比特流**，而不是指具体的传输媒体。物理层主要任务：确定与传输媒体接口有关的一些特性（定义标准）。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626212252286.png?raw=true)

## 数据通信的例子

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626212614182.png?raw=true)

## 数据通信相关术语

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626212816152.png?raw=true)

##  三种通信方式

| 名称       | 英文          | 定义                                     | 需要信道条数 |
| ---------- | ------------- | ---------------------------------------- | ------------ |
| 单工通信   | `Simplex`     | 只能一个发一个收                         | 一条         |
| 半双工通信 | `half-duplex` | 都可以发或者收，但是同一时间只能进行一个 | 两条         |
| 全双工通信 | `duplex`      | 都可以同时收发数据                       | 两条         |

## 传输方式

| 传输方式 | 特点                     |
| -------- | ------------------------ |
| 串行传输 | 速度慢，省钱，适合远距离 |
| 并行传输 | 速度快，耗钱，适合近距离 |

## 码元

定义：码元是指用一个固定时长的信号波形（数字脉冲），代表不同离散数值的基本波形。当码元的离散状态有`M`个时（`M > 2`），此时码元为`M`进制码元。`1`码元可以携带多个比特的信息量。例如，在使用二进制编码时，只有两种不同的码元。

## 速率

分为**码元传输速率**（一秒传输多少个码元）和**信息传输速率**（一秒传输多少个比特）

码元传输速率（码元速率、波形速率、调制速率）：单位时间内数字系统所传输的**码元个数**（也可以称为**脉冲个数**或**信号变化的次数**），单位是波特（`Baud`），这里的码元可以是多进制的，也可以是二进制的，但**码元速率与进制数**无关。

信息传输速率（信息速率、比特率）：表示单位时间的数字通信系统传输的二进制码元个数（即比特数），单位是`b/s`

信息传输速率 = 码元传输速率 x 码元所带信息量（多少比特）

码元所带信息量（比特数）= log2（码元进制数）

## 带宽

表示最高数据速率，单位是`b/s`

## 奈氏准则

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626222053679.png?raw=true)

## 香农公式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626225409541.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626225547833.png?raw=true)

## 基带信号和宽带（带通）信号

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626225921565.png?raw=true)

## 编码

### 数据转化为数字信号

数字数据(`digtal data`)通过 数字发送器(`digit emitter`) 转化为 数字信号(`digtal signal`)

<img src="https://github.com/NoAlligator/pico/blob/main/img/20200626154459852.png" alt="在这里插入图片描述" style="zoom: 67%;" />

模拟数据(`analog data`)通过 PCM编码器(`PCM coder`) 转化为 数字信号 (`digtal signal`)

<img src="https://github.com/NoAlligator/pico/blob/main/img/20200626154431937.png" alt="在这里插入图片描述" style="zoom:67%;" />

### 数据转化为模拟信号

模拟数据(`analog data`)通过 **放大器调制器**(`modulaotr`) 转化为 模拟信号 (`analog signal`)
![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626154409879.png?raw=true)

数字数据(`digtal data`)通过 调制器(`modulaotr`) 转化为 模拟信号 (`analog signal`)
![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626154455793.png?raw=true)

### 数字数据编码为数字信号

- 单极性不归零编码：只使用一个电压值，高电平表示`1`，低电平表示`0`.
- 双极性不归零编码：用幅值相等的正负电平表示二进制数`1`和`0`.
- 单极性归零编码：发送码`1`时高电平在整个码元期间只持续一段时间，其余时间返回零电平。
- 双极性归零编码：正负零三个电平，信号本身携带同步信息。
  <img src="https://github.com/NoAlligator/pico/blob/main/img/20200626163610563.png" alt="在这里插入图片描述" style="zoom:50%;" />

- 曼彻斯特编码：单极性编码的缺点是**没有办法区分此时是没有信号，还是有信号**。曼彻斯特编码方式是`bit`中间有信号，**低 - 高跳转**表示`0`，**高 - 低跳转**表示`1`，一个时钟周期只可以表示一个`bit`，并且必须通过**两次采样**才能得到一个`bit`。它能携带时钟信号，而且能区分此时是没有信号还是信号为`0`。
- 差分曼彻斯特编码：**抗干扰能力比曼彻斯特编码更强**。`bit`与`bit`之间有信号跳变，表示下一个`bit`为`0`，`bit`与`bit`之间没有信号跳变，表示下一个`bit`为`1`。

<img src="https://github.com/NoAlligator/pico/blob/main/img/20200626165018277.png" alt="在这里插入图片描述" style="zoom:67%;" />

### 数据转化为模拟信号

常用的调制方法：调频(`AM`)，调频(`FM`)，调相(`PM`)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200626165059865.png?raw=true)

## 常见的导向性传输介质

### 物理层传输介质

传输介质分为**导向性**传输介质和**非导向性**传输介质

| 导向性传输介质                             | 非导向性传输介质                       |
| ------------------------------------------ | -------------------------------------- |
| 电磁波沿着固体媒介（铜线、光纤）被导向传播 | 自由空间，介质可以是空气，真空，水等等 |

### 双绞线

根据有无屏蔽层分为**屏蔽双绞线（STP）和无屏蔽双绞线（UTP）**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627110148375.png?raw=true)

### 同轴电缆

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627110353962.png?raw=true)

### 光纤

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627110509407.png?raw=true)

根据**入射角**不同，又分为**单模光纤**和**多模光纤**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627110700437.png?raw=true)

## 常见的非导向性传输介质

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627110843264.png?raw=true)

# 数据链路层

## 基本概念

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627112630722.png?raw=true)

## 封装成帧/透明传输

**封装成帧**就是加将数据加头加尾，相当于将**数据打包**。
**透明传输**就是为了防止**特殊的数据无法正常传输**的的情况的发生，比如说在封装成帧的过程中出现数据中的某些标记符与开始 / 结束标记符**恰巧重复**等等情况。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627121353485.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627121943191.png?raw=true)

### 透明传输的应用（组装成帧，作用1）

#### 字符计数法

在帧的首部做**计数**

缺点：如果在某一个帧内，标记位后面的某个字节的数据丢失，那么会影响后面的帧
比如`3 1 1 `和 `4 2 2 2`，如果前面的帧丢失变成 `3 1`，那么后面的`4`就会被补到前面变成`3 1 4`导致错误

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627122122260.png?raw=true)

#### 字符填充法

加头加尾分别**标记开始结束**，和零比特填充法（见下）对比，**开始和结束的对应的字符不一样**
缺点：有可能出现数据内某段比特流数据正好**与标记字段重复**，从而导致**误判断**的情况

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627122415229.png?raw=true)

##### 解决方法：添加转义字符

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627122642435.png?raw=true)

#### 零比特填充法

#### ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627122934743.png?raw=true)

#### 违规编码法

因为曼彻斯特编码不使用高-高，低-低来表示，所以如果使用高-高，低-低来表示帧起始和终止就**不会与数据冲突**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627123050151.png?raw=true)

### 差错控制（作用2）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062712365377.png?raw=true)

#### 奇偶校验码

缺点：只能检测出`1，3，5，7…`等等奇位数错误，检测成功率位`50%`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627130921199.png?raw=true)

#### 循环冗余码

用传输数据除以生成多项式得到冗余码

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062713153254.png?raw=true)

##### 例子：

1.阶数就是最高位是哪位，然后`位数 - 1`，如 `10011` 就是 `5 - 1 = 4` ,`1011`就是`4 - 1 = 3`
3.除数和最后的余数添加到要发送的数据后面，称为帧检验序列`FCS`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627131633434.png?raw=true)

接收方收到数据后进行检测

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627132107709.png?raw=true)

##### 循环校验码是不是可靠传输？

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627132214691.png?raw=true)

#### 海明码

可以发现**双比特**错，纠正**单比特**错

##### 第一步：确定校验码和数据的位置

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627132546766.png?raw=true)

##### 第二步：确定校验码和数据的位置

1.为什么是`10`为数据位？因为`4`位校验码 +  `6`位信息位 = `10`位。
2.校验码放到`2`的几次方的位置，其他的地方按顺序放已知的信息位。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627132725336.png?raw=true)

##### 第三步：求出校验码的值

1.先是通过二进制位确定有几位。本题中因为最大位`10`的二进制是`1010`，所以是`4`位，将其标注。
2.然后从`p1`开始看，看`p1`的二进制位的数值和所有信息位的对应位置的数值是否相同，然后找出来这些位
这里有点难理解，这里以`p1`为例辅助理解，这里找出来的就是`P1,D1,D2,D4,D5`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627133356420.png?raw=true)

然后计算异或值，比如说这里`D1=1,D2=0,D4=1,D5=0`，就是`p1`要同时和`0,1,0,1`进行异或之后得到`0`。其他同理，按顺序计算出`P2,P3,P4`,然后填入表格

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627133056623.png?raw=true)

##### 第四步：检测并纠错

将所有**校验位**进行运算，得出的结果的值就是**错误的位**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627134416184.png?raw=true)

### 流量控制与可靠传输机制（作用3）

> **较高的发送速度**和**较低的接收能力**的不匹配，会造成传输出错，因此**流量控制**也是数据链路层的一项重要工作。

#### 数据链路层/传输层的流量控制的区别

**数据链路层**的流量控制是**点对点**的，**传输层**的流量控制是**端到端**的。

**数据链路链路层**流量控制手段：接收方收不下就不回复确认。

**传输层**流量控制手段：接收端给发送端一个窗口公告。

#### 流量控制，可靠传输，滑动窗口

流量控制是为了让传输过程中的**发送速度**和**接受速度**<u>匹配</u>，减少传输出错与资源浪费。
可靠传输是**发送端发送什么，接收端就要受到什么**。

滑动窗口解决流量控制（收不下就不给确认，想发也发不了）、可靠传输的问题（发送方自动重传）。

#### 流量控制的方法

<img src="https://github.com/NoAlligator/pico/blob/main/img/image-20211228114624808.png" alt="image-20211228114624808"  />

#### 协议一、停止等待协议（Stop-and-Wait）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627150624453.png?raw=true)

##### 停止等待协议的无差错情况

`ACK`全称`Acknowledge character`，即确认字符，表示收到的字符无错误。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627150810912.png?raw=true)

##### 停止等待协议的有差错情况

###### 1.数据帧丢失或检测到帧出错

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627151008798.png?raw=true)

###### 2.ACK丢失

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627151301222.png?raw=true)

###### ACK迟到

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627151343650.png?raw=true)

##### 停止等待协议的优缺点

有点：原理简单

缺点：**信道利用率低**，大部分时间数据都在路上，发送方**很长时间闲置**，浪费资源。

###### 信道利用率公式：`U = Td / (Td + RTT +Ta)`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627151529667.png?raw=true)

以下的计算公式忽略了`TA`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627151615649.png?raw=true)

#### 协议二、后退N帧协议（Go-Back-N aka GBN）

因为**停止等待协议**太浪费时间了，所以尝试采用`GBN`，发送**连续多个数据帧**，以增大信道利用率。

累计确认：就是**收到一个确认帧**，那么**它和它之前的所有帧**都默认已收到，反之，如果某个确认帧没收到，那么**它和它之后的所有帧**都默认丢失（即使收到了也丢掉），进行**重传**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062715251276.png?raw=true)

`GBN`实例：此图发送`2`帧时丢失，所以接收方几首收到后面的帧也是直接丢弃并且发送最晚收到的有效帧`1`的`ACK`，直至`2`帧的超时重传机制被触发进行重传并得到`ACK`之后，接收方才会接受`2`帧以及后面的帧

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627153111466.png?raw=true)

滑动窗口的大小限制：

![image-20211228204516726](https://github.com/NoAlligator/pico/blob/main/img/image-20211228204516726.png?raw=true)

缺点：因为重传机制的原因导致**已经收到数据却需要强行丢弃**而造成浪费。

优点：提高了**信道利用率**。

#### 协议三、选择重传协议（Selective Repeat aka SR）

为了解决`GBN`的缺点，我们打算尝试**只重传错误的帧**，这样的话就不用浪费资源把**已经收到的帧再重传一次**。

和`GBN`相比，两者都有窗口了，和`GBN`的区别其实就是**做了一个数据缓存**，已经收到的帧不用扔了，等待之前因意外丢失的帧收到的时候确认即可，但是只能缓存**窗口尺寸内的包含的帧**。

`SR`运行实例：`2`帧丢失之后仍然在发送，但是`2`帧丢失之后只是缓存，并没有移动窗口，直至最后`2`帧收到后一次性确认`2-5`帧

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627155019851.png?raw=true)

滑动窗口大小限制：

发送窗口最好**等于**接收窗口，滑动窗口大小限制公式为<img src="../../../../AppData/Roaming/Typora/typora-user-images/image-20211228205011911.png" alt="image-20211228205011911" style="zoom: 50%;" />，在这里`n`是能够表示所有编号的最小比特位数，例如编号为`0-3`，那么可以表示`0-3`最小比特位数就是`2`，计算得出滑动窗口的最大长度是`2 ^ (2 - 1) = 2`。

## 信道划分介质访问控制

**介质访问控制**的内容就是采取一定的措施，使得**两对节点**之间的通信不会发生**互相干扰**的情况。

![image-20211228213142956](https://github.com/NoAlligator/pico/blob/main/img/image-20211228213142956.png?raw=true)

### 信道划分介质访问控制的种类

定义：将使用介质的每个设备与来自同一信道上的其他设备的**通信隔离开**，把**时域和域频资源**合理地**分配**给网络上的设备。

#### 1.频分多路复用（`FDM`）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062716134134.png?raw=true)

#### 2.时分多路复用（`TDM`）

`TDM`的缺点就是利用率低，所以又衍生出了`STDM`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627161416465.png?raw=true)

#### 3.统计时分复用（`STDM`）

`STDM`的原则是先到先走，满了就发，相对于`TDM`提高了利用率。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627161525107.png?raw=true)

#### 4.码分多路复用（`CDM`）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627161726662.png?raw=true)

## 随机访问介质访问控制

所有用户都可以**随机发送信息**，发送时可以**占用全部带宽**，理论上**个人使用时比静态分配信道的速度更快**。

### 随机访问介质访问控制种类

#### 1.`ALOHA`协议

纯ALOHA协议缺点：太随性，导致效率低

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627162357969.png?raw=true)

#### 2.时隙`ALOHA`协议

相对于纯`ALOHA`协议就是固定了发送的时间（只能在一个时间片的开始），提高了效率。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627162650471.png?raw=true)

#### 4.`CSMA`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627163031462.png?raw=true)

| 名称       | 描述                                                         | 优点                       | 缺点                                     |
| ---------- | ------------------------------------------------------------ | -------------------------- | ---------------------------------------- |
| 1-坚持CSMA | 发送信息时监听信道，一空闲下来就立即传输，信道忙也一直监听，如果发送时冲突就等待随机时长之后再监听 | 立即发送，利用率高         | 如果多台设备同时监听，那么会发生冲突     |
| 非坚持CSMA | 发送信息时监听信道，如果空闲就立即传输，信道忙就随机等待一段时间后再监听 | 冲突发生的几率减少         | 因为需要等待，所以利用率不高             |
| p-坚持CSMA | 发送信息时监听信道，空闲时以概率p进行传输，概率1-p不传输（等到下一个时间槽再传输）。信道忙就随机等待一段时间后再监听 | 冲突减少的同时效率也比较高 | 即使发生冲突也要坚持发送数据，资源被浪费 |

#### 5.`CSMA/CD`协议 `aka Carrier Sense Multiple Access with Collision Detection`

因为链路实际有长短，发送数据需要时间，这个时间内可能就被其他节点当成空闲状态导致发生碰撞，知道自己发生碰撞的最长时间是`2τ`（两倍的**传播时延**），就是一去一回。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627172333977.png?raw=true)

图示传播时延对载波监听的影响：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627181945643.png?raw=true)

帧的传输时延和信号在总线中的传播时延的关系：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627183458233.png?raw=true)

碰撞后的重传时机算法：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627182153577.png?raw=true)

由此我们可以想到**最小帧长**的问题，因为如果**帧太短，帧都发送完了才检测到碰撞导致停止，导致无法停止碰撞**：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062718350424.png?raw=true)

#### 6.`CSMA/CA`协议`aka  Carrier Sense Multiple Access with Collision Avoidance`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627184714796.png?raw=true)![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627184823659.png?raw=true)

##### `CSMA/CA`和`CSMA/CD`的区别

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062718532038.png?raw=true)

## 轮询访问介质访问控制

主要包括两大类，一个是**轮询协议**，另一个是**令牌传递协议**

### 1.轮询协议

就是选出一个代表，让他控制所有的传输。**轮询开销**在随着服务的节点越多，需要用于查询是否发送数据发送的数据帧也就越多，会造成一定开销。**等待延迟**就是因为这是轮流“邀请”，所以难免某个节点需要发送数据，但是主节点还在较远的需要里有需求的节点那边，导致需求得不到立即响应。**单点故障**很好理解，就是代表挂了。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627190229529.png?raw=true)

### 2.令牌传递协议

在节点之间没有收发数据的需求时，令牌在节点之间**循环**。

1. 当一个节点需要时就可以获得这个令牌。然后修改这个令牌的状态（空闲`->`占用）。
2. 再将令牌与数据帧结合，让其在节点构成的环之间流动。
3. 不是目的地的节点收到令牌也不接受，直接略过，目标节点收到信息并复制一份到本地（传输完成），因为是个闭环，所以发送节点最后得到令牌。
4. 最后，发送令牌的节点对令牌的内容进行检查，如果发现数据出错还要重新发一遍。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627205055826.png?raw=true)

## 局域网（Local Area Network）

是指在某一区域内由多台计算机互联形成的计算机组，使用**广播信道**。

特点概括：范围小、速度快、延迟低、节点平等。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627210439299.png?raw=true)

### 局域网的网络拓扑结构

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627210700283.png?raw=true)

### 局域网的传播介质 

| 局域网     | 常用介质               |
| ---------- | ---------------------- |
| 有线局域网 | 双绞线，同轴电缆，光纤 |
| 无线局域网 | 电磁波                 |

### 局域网介质访问方法

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627210926529.png?raw=true)

### 局域网的分类

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627211026206.png?raw=true)

###  `IEEE802`标准

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627211306397.png?raw=true)

### `IEEE802`描述的局域网参考模型

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627211401404.png?raw=true)

### 以太网/`802.3`区域网（`Ethernet`）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627211606200.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627211721247.png?raw=true)

#### 以太网的发展

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627224030441.png?raw=true)

#### `10BASE-T`以太网

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627225136362.png?raw=true)

#### 适配器和`MAC`地址

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627224149350.png?raw=true)

#### 以太网`MAC`帧

1. 这里的`MAC`层指的是**数据链路层**
2. 之前说过数据链路层将上一层`ip`数据报**加头加尾**，头就是目标地址（6字节），源地址（6字节），类型（2字节），尾就是`FCS`（帧检验序列，4字节）。
3. 前导码不是`MAC`帧的一部分，目的是使时钟同步。
4. 为什么数据长度时`46~1500`？因为有最小传输字节`64`字节，`mac`占用`6+6+2+4=18`，所以数据最小为`64-18=46`，`1500`则是规定的默认最大字节（`MTU`）。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627224520210.png?raw=true)

#### 高速以太网

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627224252903.png?raw=true)

### 无线局域网 / `IEEE 802.11`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230045240.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230109894.png?raw=true)

#### 两种无线区域网

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230151259.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230158897.png?raw=true)

### 广域网

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230316639.png?raw=true)

### `PPP`协议（`Point to Point Protocol`）

`PPP`协议是目前**使用最广泛**的数据链路层协议，拨号基本都是`PPP`协议，`PPP`协议**仅支持全双工**链路

#### `PPP`协议需要满足的要求

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230948785.png?raw=true)

#### `PPP`协议不需要满足的要求

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627230916385.png?raw=true)

#### `PPP`协议的帧格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062723121486.png?raw=true)

### `HDLC`协议（`High-Level Data Link Control`）

#### 概述

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627231345512.png?raw=true)

#### `HDLC`的三种站

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/202006272314286.png?raw=true)

#### `HDLC`的帧格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200627231635817.png?raw=true)

###  `HDLC`和`PPP`对比

为什么HDLC协议更可靠，但是我们使用PPP协议？因为现在网络要求高，数据链路层本来就是不可靠的尽力传输，差错控制这些复杂的交给了TCP等。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062723171761.png?raw=true)

## 链路层设备

### 集线器

可以扩展以太网，但是集线器会无脑将一个设备的所有消息转发到集线器所连的**所有设备**，故会将所连接的**所有设备**变成一个大的**冲突域**，同时只能有两台设备进行通信，且设备越多，冲突越多。由此诞生了**网桥**。

### 网桥

在使用网桥时，由于网桥会根据`mac`地址进行**过滤**，所以**不会形成冲突域**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628000638789.png?raw=true)

#### 透明网桥

通过自学习来构建转发表。每一个通过网桥的数据包都会被记录下网桥收到数据时**数据对应的地址**和**网桥自己的接口**，通过许许多多的数据包的构造的缓存，网桥就可以知道哪个数据包在哪个接口，以后如果要穿数据包就知道要往哪个接口发送数据包。

#### 原路由网桥

在发送时，直接将最佳路径放到帧首部。那么网桥如何获得最佳路径？通过广播方式想目标地址发送广播，此时可能会经过不同路由产生不同的路径，目标地址收到后再将每一条路径都发一个响应帧给网桥，网桥经过对比就知道哪个接口最快。

### 交换机

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062800263617.png?raw=true)

#### 冲突域和广播域

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628001124492.png?raw=true)

# 网络层

## 一、概述

**数据报**和**分组**的关系：**分组**是一段比较长的数据，将它进行切割成一段段之后就得到**数据报**。

网络层的功能：

一、路由选择与分组转发（让数据在路由器之间走最佳的路径）
二、异构网络互联（让不同的设备（手机，电脑，平板等）都能正常连接）
三、拥塞控制

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628100232914.png?raw=true)

| OSI参考模型 | 各层次的传输单元                               |
| ----------- | ---------------------------------------------- |
| 应用层      | 报文                                           |
| 传输层      | 报文段                                         |
| 网络层      | IP数据报，分组（如果IP数据报太大就切割成分组） |
| 数据链路层  | 帧                                             |
| 物理层      | 比特流                                         |

## 二、数据交换方式

为什么要进行数据交换？因为每个节点之间都拉网线**太麻烦了也不实际**，所以通过大量交换设备**互联**进行数据交换。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628101240749.png?raw=true)

### 电路交换

常见的例子：拨打电话。

注释：链路支持多路复用（可参考[数据链路层](https://so.csdn.net/so/search?q=数据链路层)的TDM等）。

特点：独占资源，因为两者建立了连接。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628134105730.png?raw=true)

### 报文交换

报文发送的过程：

1. 源先根据报文加上`ip`地址，物理地址等，通过**物理层**发送。
2. 交换机收到报文之后，先进行存储，等待链路空闲之后进行转发，但是转发的路径不是固定的，是比较随机的。
3. 最后通过许多交换机最终到达目的地。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628134558218.png?raw=true)

### 分组交换

分组交换和报文交换**基本相同**，就是将报文切割之后再进行发送。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628135456570.png?raw=true)

### 分组交换和报文交换的具体计算对比

报文 交换：一共三段，每段都需要`10000bit/1000bps=10s`，三段就是`3x10=30s`

分组交换：可以分为两段，一个是第一个数据开始发到最后一个数据从源发出，一段是最后一个数据到达目的地。第一段总时间是`10000bit/1000bps=10s`，第二段总时间是`（10/1000）*2=0.02s`，所以总时间是`10.02s`。
理解一下，这里就是报文交换的时候，由于报文没有分割，所以即使先到的数据也不能先发走，只能等到最后一段报文全部到了之后才能一起走，相对于分组交换明显拖慢了前面数据的速度，所以导致报文交换明显慢于分组交换。

结论：可以看到分组交换明显快于报文交换，所以我们通常使用**分组交换**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628140059520.png?raw=true)

#### 分组传输的两种方式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628141302754.png?raw=true)![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628151011994.png?raw=true)

###    数据报

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628150810177.png?raw=true)

### 虚电路

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628150941414.png?raw=true)

### 数据报&虚电路的区别

![image-20220101011044140](https://github.com/NoAlligator/pico/blob/main/img/image-20220101011044140.png?raw=true)

## `IP`数据报

### `IP`数据报格式

| 名称                      | 注释                                                         | 大小                     |
| ------------------------- | ------------------------------------------------------------ | ------------------------ |
| 版本`Version`             | `ipv4` 或 `ipv6`。                                           | `4b`                     |
| 首部长度`IHL`             | 此处数值再乘以`4`才是真正大小，因为`IP`数据报固定长度为`20`字节，所以此处最小值为`5`，即二进制的`0101`。 | `4b`                     |
| 区分服务`DSCP+ECN`        | 希望获得哪种服务，用的比较少。                               | `8b`                     |
| 总长度`Total Length`      | 首部 + 数据的总长度，最大为`2 ^ 16 = 65535`，实际上并不会达到最大长度，会进行分片。 | `16b`                    |
| 标识`Identification`      | 用来表示**是哪一个数据报的分片**，不同的分片标识各不相同。   | `8b`                     |
| 标志`Flags`               | 用来表示**是否分片**和**分片是否结束（后面是否还有分片）**。 | `3b`实际有用的只有后两位 |
| 片偏移`Fragment Offset`   | 用来标记分片之后，该分片在原来数据报的位置，以`8`字节为单位  | `13b`                    |
| 生存时间`Time to Live`    | 即`TTL`，每经过一个路由器`TTL` 将减一，等到`TTL`到达`0`的时候自动放弃，根据系统不同默认的`TTL`不同。 | `8b`                     |
| 协议`Protocol`            | 用来标记协议名的字段值，如`TCP`，`UDP`，`ICMP`等等。         | `8b`                     |
| 首部检验和`Head Checksum` | 检验首部的字段是否出错，出错就丢弃此数据报。                 | `16b`                    |
| 源地址`Source IP`         | 发送方`IP`地址                                               | `32b`                    |
| 目的地址`Destination IP`  | 接收方`IP`地址                                               | `32b`                    |
| 可选字段`Optional fields` | 用来排错等安全检测                                           | 未知，可在`0-40b`之间    |
| 填充`padding`             | 将数据报对齐成`4`字节的整数倍，数值全部为`0`                 | 未知                     |

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628163753975.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628163922707.png?raw=true)

 

计算偏移量时记住是以`0`开始的就行，以每一篇最开始的除以8得到的数值就是偏移量

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628164237523.png?raw=true)

## 三、路由算法

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062815165630.png?raw=true)

###  `AS`

`AS`就是多个路由器之间构成的单独的小圈子，圈子内使用自己的协议（`RIP、OSPF`），圈子和圈子之间用的是`BGP`协议。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062815185760.png?raw=true)

### 一、`RIP`协议和距离向量算法

#### `RIP`协议概述

`RIP`协议通过交换信息构建路由表。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629105637285.png?raw=true)

#### 如何建立路由表？

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629105916914.png?raw=true)

#### `RIP`协议报文格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629111259211.png?raw=true)

#### `RIP`协议特点

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200629111526974.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200629111637786.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629111700886.png?raw=true)![在这里插入图片描述](https://img-blog.csdnimg.cn/20200629111718198.png?shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTA2NzYwMw==,size_16,color_FFFFFF,t_70?raw=true)

#### 距离向量算法

为什么改地址？因为图中是从`x`得到的信息。
为什么距离固定`+1`？因为路由器只从相邻路由器之间获取`RIP`报文，距离只会是`1`。
为什么下一跳是`x`就要替换？因为网络环境不断变化，可能这次某个节点挂掉，所以保持最新的。
为什么下一跳不是`x`时有更新和不处理两种手段？因为这样可以提高效率，比原来快就换，比原来慢就保留原来的路由。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062911085927.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629111155473.png?raw=true)

### 二、`OSPF`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629111933218.png?raw=true)

#### `OSPF`的其他特点

为什么`OSPF`收敛速度快？因为它只是刷新一下链路状态，得知其是否连通，不需要和`RIP`一样进行对照，而是直接通过`Dijilstra`算法来自己算出路径。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629115353647.png?raw=true)

### 链路状态路由算法

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629115012290.png?raw=true)

#### `OSPF`区域

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629115212801.png?raw=true)

#### `OSPF`分组

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629115305114.png?raw=true)

### 三、`BGP`协议

#### `BGP`协议简介

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629202605883.png?raw=true)

#### `BGP`协议交换信息的过程

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629203846439.png?raw=true)![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629202751648.png?raw=true)

#### `BGP`协议报文格式

`BGP`是**应用层**协议。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062920290996.png?raw=true)

#### `BGP`协议特点

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629203255760.png?raw=true)

#### `BGP`的四种报文

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629203720460.png?raw=true)

###  四、三种路由协议的比较

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629204241177.png?raw=true)

## 四、`IP`

### `ipv4`地址

**全球唯一的**表示某一个主机或者路由器接口的编码。

#### `IP`地址分类

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628165300355.png?raw=true)

#### 特殊`IP`地址

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062816534040.png?raw=true)

#### 私有`IP`地址

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628165703918.png?raw=true)![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628173140760.png?raw=true)

#### 网络地址转换`NAT`（`Network Address Translation`）

连接**内网和外网**，就是找个代理的用它的`ip`地址与外面收发数据。`NAT`需要构建`NAT`转换表，既要存广域网（`WAN`，外网）也要存局域网（`LAN`，内网）的`ip`地址和端口号。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628203040212.png?raw=true)

### 子网划分 / 子网掩码

为什么需要**子网划分**？两级`IP`地址**不够灵活**、`IP`地址空间利用率有时很低。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628203445257.png?raw=true)

为什么子网好能全`0`或者全`1`？因为`CIDR`编址（可见下一段）
为什么主机号不能全`0`或者全`1`？因为全`0`代表本网络，全`1`代表广播分组

#### 子网划分

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628203628674.png?raw=true)

#### 子网掩码

子网掩码就是用来和`ip`地址一起计算子网的地址的，方法就是讲子网掩码逐位写成二进制然后而原来`ip`地址进行与运算，就可以得到子网`ip`地址。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628204154511.png?raw=true)

这道题可以看出来，即使**子网掩码**不同，相同`ip`地址对应的子网`ip`地址也可能相同，但是子网掩码不同，划分的**子网数目不同**。

为什么划分的子网数目不同？或者说怎么算划分的子网位数目？

以`255.255.192.0`为例，`255`是`11111111`即`8`个`1`,`192`是`11000000`即`2`个`1`，一共是`82+2=18`个`1`，一共有`32`位地址，所以剩余有`32-18=14`位。
以`255.255.224.0`为例，`255`是`11111111`即`8`个`1`，`224`是`11100000`即`3`个`1`，一共是`82+3=19`个`1`，一共有`32`位地址，所以剩余有`32-19=13`位

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628204442714.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062821061359.png?raw=true)

#### 使用子网时分组的转发

1. 这里**特定主机路由**就是指找特定的处理这里这个`ip`地址的路由。
2. 默认路由会将这个数据报发给另一个路由，直至找到对应的路由，或者`TTL`耗尽被丢弃。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628212251576.png?raw=true)

### 无分类编制`CIDR`（`Classless inter-domain routing`）

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628213057516.png?raw=true)

使用`CIDR`可以聚合网络，如图，通过**缩短前缀**，`R1`和`R2`就可以合并在`206.1.0.0/16`的子网下，但是这样转发表之中就会有**多个匹配结果**，所以我们使用**最长前缀匹配**

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628214310460.png?raw=true)

解释：最长前缀匹配就是在计算后符合同一子网的时候，选前缀越长的。
![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628214654941.png?raw=true)

解释：因为本网络是`192.168.5.0/24`，就是`192.168.5.（0000 0000）/24`，将`248`写成二进制是`11111 000`，有`5`个`1`，所以**前五位**都可以作为子网的编号，剩下的**三位**就是用来分配子网内剩余的地址了，因为不能全`0`或者全`1`，所以还要减`2`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628220204999.png?raw=true)

### `ARP`协议

 ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020062822274549.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628222947367.png?raw=true)

### `DHCP`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628223418552.png?raw=true)

### `ICMP`协议

`ICMP`，`IGMP`处于**网络层和传输层之间**，就是为了更好地转发`ip`数据报和提高交互成功的几率。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200628223751853.png?raw=true)

#### `ICMP`差错报告报文

#### `ICMP`差错报告报文如何与`IP`数据报结合

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629094024680.png?raw=true)

#### 物种差错报文

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629083834897.png?raw=true)

#### 四种不发送`ICMP`差错报文的情况

**组播**是指由**一点到多点**，但不是发到**所有点**，发到所有点的是**广播**，组播有**筛选条件**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629094235772.png?raw=true)

#### ICMP询问报文

后两种是**掩码地址请求和回答报文**，路由器询问和通告报文，这两个已经废弃不再使用。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629094521489.png?raw=true)

#### `ICMP`的应用

1. `ping`命令：测试两个主机之间**连通性**，使用了**ICMP回送请求和回答报文**
2. `traceroute`命令：跟踪一个分组从**原点到终点**的路径，使用了**ICMP时间超过差错报告报文**

## `ipv6`

### 为什么会有`ipv6`

`IPV4`地址用完了，从根本上增加`IP`地址数目，之前讲的`NAT`和`CIDR`也只是在`IPV4`的基础上扩展了`IPV4`地址数目，治标不治本。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629095311686.png?raw=true)

### `ipv6`地址表示形式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629102621942.png?raw=true)

### `ipv6`数据报格式

| 名称                           | 作用                                                         | 位数   |
| ------------------------------ | ------------------------------------------------------------ | ------ |
| 版本 `Version`                 | 知名协议版本，此处因为是`ipv6`所以总是`6`                    | `4b`   |
| 优先级`Traffic Class`          | 又来区分数据报的类型和优先级                                 | `8b`   |
| 流标签`Flow Label`             | 和`ipv4`标识某个数据报分片不同，这是对于一整个数据报流的标记 | `19b`  |
| 有效载荷长度 `Payload Length`  | 指的是扩展首部+数据部分的大小，和`ipv4`的总长度和首部长度都不同，`ipv6`的首部长度是固定的`40B` | `16b`  |
| 下一个首部 `Next Header`       | 基本首部的下一个首部指的是有效载荷里标记的的扩展首部，有效载荷里的扩展首部再指向有效载荷里标记的的扩展首部，直至最后指向数据 | `8b`   |
| 跳数限制 `Hop Limit`           | 基本相当于`ipv4`当中的`TTL`，每到一个路由器减一，减到`0`时丢弃 | `7b`   |
| 源地址 `Source Address`        | 发送方`ipv6`地址                                             | `128b` |
| 目标地址 `Destination Address` | 接收方`ipv6`地址                                             | `128b` |

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629095626140.png?raw=true)

### `ipv4`和`ipv6`的区别

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629102457217.png?raw=true)

### `ipv6`基本地址类型

| 名称 | 作用                                             | 要求                 |
| ---- | ------------------------------------------------ | -------------------- |
| 单播 | 一对一通信                                       | 可做源地址，目的地址 |
| 多播 | 一对多通信，以前的广播地址当做覆盖所有主机的多播 | 可做目的地址         |
| 任播 | 一对多当中的一个通信，看似一对多，实则一对一     | 可做目的地址         |

### `ipv4`到`ipv6`的过渡

如果是`ipv6`的数据报到了`ipv4`，就用`ipv4`重新封装，把`ipv6`数据报前面加上`ipv4`伪装成`ipv4`数据报继续传输，直至到了`ipv6`路由再解开`ipv4`伪装。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629103250467.png?raw=true)

## `IP`组播

### 什么是组播

单播只能一对一，广播必须一对全部，组播就可以是一对全部中的一部分。

### ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629205037734.png?raw=true)

辅助理解：单播所占资源多。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629210027661.png?raw=true)

组播明显减轻了压力。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629210108353.png?raw=true)

### `IP`组播地址

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629210330405.png?raw=true)

### 硬件组播

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629210827844.png?raw=true)

## `IGMP`协议与组播路由选择协议

### `IGMP`协议

`IGMP`只能知道有没有**组播组成员**，对有几个组播组成员，成员在哪个地方都不知道。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629211352630.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629211613284.png?raw=true)

### 组播路由选择协议

有了这个，成员可以**自行找到转发组**，自行决定参加哪个**组播**（就像电视机选台一样）。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629211740525.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629211913501.png?raw=true)

 

## 移动`IP`

移动`IP`**不等于**动态`IP`（`DHCP`获得的叫做动态`IP`），移动`IP`的可以让用户因为地理原因等等，即使不在内网也可以访问内网的东西。

### 术语

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629212218336.png?raw=true)

###  移动`IP`通信过程

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629212604875.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629220550874.png?raw=true)

## 网络层设备

### 路由器的构造

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629220712123.png?raw=true)

### 路由器的输入输出端口构造

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629221015438.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629221022561.png?raw=true)

### 集线器、网桥、路由器几层设备比较

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629221130818.png?raw=true)

### 路由器的路由表和转发表

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200629221253590.png?raw=true)

# 传输层

**网络层**可以把数据从**一个主机传送到另一个主机**，但是没有和**进程**建立联系。**传输层**就是将进程和收到的数据联系到一起，使数据能够为应用服务，所以说传输层是**主机**才有的层次。

## 传输层的两个协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630094727731.png?raw=true)

## 传输层的寻址和端口

端口号只用于计算机分辨本地进程，总共有`2^16=65536`种端口号，端口号有很多种，不能随便使用

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095024127.png?raw=true)

### 常见的应用程序端口号

### ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095258962.png?raw=true)

## `UDP`协议（`User Datagram Protocol `）

因为`UDP`一次发送一个**完整报文不会分片**，所以需要应用层传输过来的数据**不要太大**，否则网络层分片任务就很重，但是也**不能太小**，不然效率较低，`UDP`适合一些实时应用，因为**实时应用延迟要求高，需要立即响应**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630095616466.png?raw=true)

### `UDP`首部格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020063010003161.png?raw=true)

### `UDP`的校验位构成

这里的伪首部只是用来计算检验和的，计算完了就丢弃，可以见下`UDP`的校验方式。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630105441329.png?raw=true)

UDP计算校验和的方法和IP数据报首部校验和的方法相似。不同的是：IP数据报校验和只校验IP数据报的首部，但UDP的校验和是把首部和数据部分一起都检验。

UDP的校验和需要计算UDP首部加数据荷载部分，但也需要加上UDP伪首部。这个伪首部指，源地址、目的地址、UDP数据长度、协议类型（0x11），协议类型就一个字节，但需要补一个字节的0x0，构成12个字节。伪首部+UDP首部+数据一起计算校验和。

UDP检验和的计算方法是：

1.按每16位求和得出一个32位的数；
2.如果这个32位的数，高16位不为0，则高16位加低16位再得到一个32位的数；
3.重复第2步直到高16位为0，将低16位取反码，得到校验和。

接收端：

与发送端的时候不同的是，此时检验和字段不是0，按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和，如果最后得到**结果全1**就是没问题，否则丢弃。

### `UDP`实际例子

![image-20220102105404182](https://github.com/NoAlligator/pico/blob/main/img/image-20220102105404182.png?raw=true)

## `TCP`协议（`Transmission Control Protocol`）

### `TCP`的特点

`TCP`必须要建立连接之后才可以**进行数据交换**，所以`TCP`是面向连接的。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630194247441.png?raw=true)

`TCP`传输数据是**随机切割数据**的：

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020063020421472.png?raw=true)

#### `TCP`报文段的首部

见上图，可以看到`TCP`是将数据随机分割后加上`TCP`头传输的，所以序号就是为了**标记这些随机分割之后的数据**，这里把**第一个字节的编号**当成**序号**。

**确认号**就是收到之后做一下标记，代表这之前的都收到了，希望收到的**下一个编号的数据**就是确认号打头的那个数据。

**偏移量**就是为了标记一下距离`TCP`开始多少字节是数据，这里的单位是`4B`，这个偏移量就是`TCP`首部长度。

**窗口**就是接收方告诉发送方，还有多少地方（缓存）可以放数据。

**紧急指针**就是告诉`TCP`从哪里到**哪里是紧急数据**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630210441410.png?raw=true)

#### `TCP`报文段首部的六个控制位

##### 紧急位`URG`

发送端的优先传输，`URG`的特点就是让数据**插队**，`URG=1`的就会在缓存中被提前到**第一个**传输。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211126589.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211151331.png?raw=true)

##### 确认位`ACK`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630211354251.png?raw=true)

##### 推送位`PSH`

就是接收端的`URG`，将`PSH=1`的数据尽快接收，注意一下，如果没有`PSH`，一般都是接收方缓存满了之后再将数据发送到主机。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212045298.png?raw=true)

##### 复位`RST`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212049447.png?raw=true)

##### 同步位`SYN`

`A`和`B`主机要**建立连接**，就`A`先发一个报文，其中`SYN=1`，`B`收到之后也回复一个`SYN=1`的报文，代表**接受连接**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212152221.png?raw=true)

##### 中止位`FIN`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630212056958.png?raw=true)

### `TCP`连接管理

#### `TCP`三次握手

注释：
第一段的意思是
SYN=1：(A)要建立连接了！
seq=x（随机）：因为还没有数据，所以写什么都无所谓

第二段的意思是
SYN=1：我(B)同意你(A)建立连接！
ACK=1：连接建立了，之后的ACK必须都置为1
seq=y（随机）：因为还没有数据，所以写什么都无所谓
ack=x+1：之前发送方(A)说发送的是第x位数据（虽然发送方是瞎说的），所以我(B)要的是x+1位数据

第三段的意思是
SYN=0：SYN只有在建立连接时才为1，其他时候均设为0
ACK=1：连接建立了，之后的ACK必须都置为1
seq=x+1：我(A)发送的报文段的第一个字节就是x+1
ack=y+1：之前接收方(B)说发送的是第y位数据（虽然接收方是瞎说的），所以我(A)要的是y+1位数据

注意一下，TCP是双向的，所以不存在绝对不变的发送方接收方，这里的两台主机都同时是发送方和接收方

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630213814996.png?raw=true)

####   `TCP`三次握手特定导致的`SYN`洪泛攻击

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630214925395.png?raw=true)

#### `TCP`四次挥手（连接释放）

注释：
第一段的意思是
FIN=1：(A)要释放连接了！
seq=u：发了好多数据，这里只是用u指代一下，这里u是有确定值的

第二段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=v：发了好多数据，这里只是用v指代一下，这里v是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（尽管此时A已经决定释放连接了）

第三段的意思是
FIN=1：(B)要释放连接了！
ACK=1：连接建立了，之后的ACK必须都置为1
seq=w：发了好多数据，这里只是用w指代一下，这里w是有确定值的
ack=u+1：之前发送方(A)说发送的是第u位数据，所以我(B)要的是u+1位数据（因为A直接不发数据了，所以第二段第三段的ack都是u+1）

第四段的意思是
ACK=1：连接建立了，之后的ACK必须都置为1
seq=u+1：之前发的数据时第u位数据，B也要第u+1位数据，所以我发第u+1位数据
ack=w+1：之前发送方(B)说发送的是第w位数据，所以我(A)要的是w+1位数据

为什么需要等待计时2MSL？
因为这样可以保证B可以收到A的终止报文段进而进入关闭状态
比如说如果A的第四段报文丢失，那么等待一个MSL之后B就会重传第三段报文，花费小于1MSL之后A就会再收到第三段报文，之后就可以再次向B发送第四段报文提示B关闭连接

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630215522825.png?raw=true)

#### `TCP`可靠传输

`TCP`是提供可靠传输，`UDP`这种本身还是不可靠传输的就再靠**应用层**解决可靠性问题。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630220542461.png?raw=true)

##### 序号

就是`TCP`根据下方数据链路层的`MTU`（最大传输单元）来随即将**数据切割**成好几段并且进行**编号**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630221424853.png?raw=true)

##### 确认

发送方每一次发送数据之后都需要接收方进行确认。`TCP`使用的是**累计确认机制**，就是从**第一个丢失的字节开始请求丢失的报文段**。如图中`456`丢失，`78`到达，但仍然请求发送的数据序号是`4`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630221636424.png?raw=true)

##### 重传

为什么要使用**自适应算法**？网络环境太复杂，路径又长又短，`RTT`设置短了照顾不了距离远的，`RTT`设置长了又导致网络利用率降低，所以使用`RTTs`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630222205619.png?raw=true)

#### `TCP`流量控制

简单来说就是**接收方可以动态的发送信息告诉发送方发送窗口的大小**。接收方接受不过来了就让发送方发送窗口小点，这样发送方发送的速率就慢下来了，接收方就有时间处理它的数据了。接受方处理完了也可以发送请求让发送方发送窗口大点，这样发送方发送的速率就快起来了，接收方就可以处理更多数据而不是空闲等着收数据了。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/202006302226272.png?raw=true)

##### 计时器

在本例子中，使用的**累计确认机制**（一次回复收到`ack=201`）和**三次流量控制机制**。但是有一个情况就是，如果最后`B`不允许`A`再发送数据了，`B`在处理完数据之后想要恢复窗口大小时发送的有`rwnd`大小的数据报丢了怎么办？此时`A`有`B`的指令在前，发送窗口为`0`无法发送数据，`B`也在等待`A`回复，造成了**类似死锁**的现象。
解决方法：使用计时器，超时之后发送探测报文段。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630223616929.png?raw=true)

#### `TCP`拥塞控制

流量控制是对**单独一个**来说的，拥塞控制是**一群**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630224242515.png?raw=true)

##### 拥塞控制四种算法

这里虽然是**四种算法**，但是通常是**两两结合**进行使用。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630232411944.png?raw=true)

##### 慢开始和拥塞避免

这里开始时以指数形式增长，`ssthresh`的意思是慢开始门限，代表从这个地方注入的报文段就比较多了，需要开始慢速增加了。 之后一段都是线性增长，每次增加`1`，直至达到**网络拥塞状态**。瞬间将`cwnd`设置为`1`，同时调整原来的`ssthresh`的值到之前达到网络拥塞状态的`1/2`,（这里是`24`降到`12`），重复以上步骤，但是注意此时`ssthresh`变了之后**线性增长的转折点**也变了。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200630232910475.png?raw=true)

#####  快重传和快恢复

这里和上面的慢开始和拥塞避免的一开始步骤差不多，都是先指数增长再转变为线性增长。不同的点是快重传和快恢复算法是在收到连续的`ack`确认之后执行，这里的`ack`就是冗余`ack`，冗余`ack`的特点是如果多次对某一段请求的数据没有被收到，达到一定数目之后就会立即执行重传。但是此时只是降到现在`cwnd`的一半，再重新线性增长。而不是像慢开始和拥塞避免的从头开始（从`1`开始）。

# 应用层

  不同的网络应用之间需要有一个确定的通信规则。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702215803534.png?raw=true)

## 两种常用的网络应用模型

### 客户/服务器模型（`Client/Server`）

### ![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702220439646.png?raw=true)

### `P2P`模型

**网络健壮性**指的是`P2P`模型**不容易坏掉**，即使一个节点坏了也没问题，可以有其他节点代替。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702220544850.png?raw=true)

## 域名解析系统`DNS`

`DNS`系统就是将打在**地址栏的域名**转化为`IP`地址的系统。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702220920296.png?raw=true)

### 域名

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702221601437.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702221626114.png?raw=true)

### 域名服务器（`DNS`服务器）

`DNS`服务器有很多台，根据层次结构分为**三层**：**根域名服务器，顶级域名服务器，权限域名服务器**。

**根域名服务器**并不是一个域名只有一台，而是**一个域名对应多台域名服务器**，全世界一共有`13`个这样的域名，分别是`a.rootservers.net`，`b.rootservers.net`，`c.rootservers.net`，`----`，`m.rootservers.net`。根域名服务器**掌握了所有顶级域名服务器的`IP`地址**。

在**权限域名服务器**中，虽然看似`abc.com`比`y.abc.com`少了一位，但是他们的**地位仍是对等**的，**对应的两台权限域名服务器**。

**本地域名服务器**不算层次结构，特点是**离主机比较近**，当主机和另一台**比较近的主机通信**时，就不用走那些**更高级**的服务器。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702222254726.png?raw=true)

### 域名解析过程

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702223128655.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702223220720.png?raw=true)

#### 迭代查询

主机先是向**本地域名服务器**发送请求，如果查不到的话，本地域名服务器向根域名服务器发送请求（找别人），如果还是查不到的话，根域名域名服务器向顶级域名服务器发送请求（找别人），如果还是查不到的话，顶级域名服务器向权限域名服务器发送请求（找别人）。可以看到每一次向下一个查询的服务器都变了，不是主机一个个去问，而是服务器自己一个个问下去。

#### 递归查询

主机先是向**本地域名服务器**发送请求，如果查不到的话，本地域名服务器就让主机去向根域名服务器发送请求（主机去找，本地域名给目标根域名服务器的IP地址），如果还是查不到的话，根域名域名服务器让主机去向对应的顶级域名服务器发送请求（主机去找，根域名给目标顶级域名服务器的`IP`地址），如果还是查不到的话，顶级域名服务器让主机去向权限域名服务器发送请求（主机去找，顶级域名给目标权限域名服务器的`IP`地址）。可以看到这里是主机一个个挨个问的地址。

#### 高速缓存

为了减少**多次查询同一个域名的资源浪费**，本地域名服务器会存储最近使用的`ip`地址解析，下次再访问同一个域名就不需要这么多查询步骤了。同时这个高速缓存主机本身也有存储，**本地域名服务器还可以对顶级域名服务器，权限域名服务器的地址进行缓存**，下一次即使是不知道的`ip`地址，查询也可以更快。高速缓存为了保持正确性，需要**定时更新**。

## 文件传送协议

### `TFTP`协议

`TFTP`是一个**轻量的**，比较**容易实现的**，面对**小文件**的，`UDP`的文件传输协议。

### `FTP`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702224616787.png?raw=true)

#### `FTP`的服务端和客户端

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702224816512.png?raw=true)

#### `FTP`的工作原理

为什么有**匿名登陆**：对于一些公共服务器来说，**增加验证阶段**就是**增加资源开销**，**减少验证阶段**就可以**节省资源来更好地服务**。

主进程和从属进程的区别：主进程是**打开端口**，让外部发送的数据**可以进来**，并且将这些数据逐个**分配各从属进程**。从属进程则是**单独为这些数据服务**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200702225039138.png?raw=true)

注释：这里的主进程被忽略掉了，只是没标在上面，并不是没有。
这里客户端和服务器端先建立`TCP`连接，端口是`21`，称为**控制连接**，然后看情况是**主动建立连接**还是**被动建立连接**。
**主动建立连接**是指服务器端**主动发送请求和客户端进行连接**，此时端口号固定是`20`。
**被动连接**是指**客户端发送请求和服务器端建立数据传送连接**，此时端口号是**不确定**，由两者协商得到。
数据传输完成之后，**数据连接断开**，**控制连接继续保持**，直至两边发送**断开请求**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703000333330.png?raw=true)

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703000905460.png?raw=true)

## 电子邮件

### 电子邮件的格式

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703001117831.png?raw=true)

### 电子邮件系统的组成结构

用户代理的四个功能解释：

1. 撰写就是给用户编辑信件的环境。
2. 显示就是可以看到自己写的和自己收的信件内容。
3. 处理就是对信件进行操作，包括删除，打印，转发等等。
4. 通信就是可以将邮件发送到邮件服务器当中，同时可以从邮件服务器当中读取邮件。

邮件服务器的功能注释：

- 邮件服务器端的发送和接受是指从自己的用户代理处接收邮件，之后向对面的邮件服务器发送邮件。
- 邮件服务器的报告邮件发送结果就是投递是否成功这种情况。
- 邮件服务器既可以作为客户端又可以作为服务器端，使用的是`C/S`方式。

协议的功能注释：
发邮件用的是`SMTP`
收邮件的是`POP3`或者`IMAP`

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703001436566.png?raw=true)

### 简单邮件传送协议`SMTP`

注意一下，这里`SMTP`客户和服务器不是固定死的，用户可以成为服务器，服务器也可以成为用户，由发送方和接收方决定，**发送方就是客户，接收方就是服务器**。`SMTP`协议建立在`TCP`协议之上。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703002319315.png?raw=true)

#### 协议实例

这里`RCPT`能有**多条命令**的原因是，电子邮件可以有**多个收件人**，就是群发，所以允许多个`RCPT`。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703002844133.png?raw=true)

###   改进`SMTP`缺点的`MIME`协议

`MIME`改善`SMTP`发送数据的缺点，是`SMTP`的功能性扩展，`MIME`协议已经逐渐开始应用到浏览器当中，通过对不同文件类型用不同的标识符标识，来让浏览器读取通过`MIME`的相关文件。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703003639358.png?raw=true)

### `POP3`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703003942969.png?raw=true)

### 比较复杂的读取邮件的协议——`IMAP`协议

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703004334235.png?raw=true)

### 基于万维网的电子邮件

与之前的不同的地方就是，基于万维网的电子邮件的**邮件服务器端可以不同**。同时，发送邮件使用的`SMTP/MIME`和收邮件时的`POP3/IMAP`协议都**换成了HTTP协议**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/2020070300482031.png?raw=true)

##  万维网和`HTTP`协议

`URL`用来标识整个互联网当中的**某一个资源**（文字，视屏，音频等）的位置。

`HTTP`用来将这些资源**传送给用户**。

`HTML`帮助设计者来设计页面，让不同设计者设计的页面都可以在**界面上显示**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703005114701.png?raw=true)

### `HTTP`协议

#### `HTTP`协议的过程

服务器通过`TCP 80`端口来监听`HTTP`请求，注意`HTTP`可以不一次性下载完页面的所有资源，可以只下载**文本部分**，其他音频视频等待用户**下一步请求之后再传输**。

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703005650472.png?raw=true)

#### `HTTP`协议的特点

![在这里插入图片描述](https://github.com/NoAlligator/pico/blob/main/img/20200703010043691.png?raw=true)

#### `HTTP`的连接方式——持久连接和非持久连接

**非持久连接**在`TCP`三次握手的**第三次握手**时发生，将`HTTP`请求作为**第三次握手**的数据部分发给服务器，服务器收到请求之后将`HTTP`相应报文传输给客户。耗时就是`RTT*2+文档传输时间`。
缺点：如果再想传输，那么就需要重新建立`TCP`连接从头开始。

**持久连接**和非持久连接类似，都是在**第三次握手**时发生，将`HTTP`请求作为**第三次握手**的数据部分发给服务器，服务器收到请求之后将`HTTP`相应报文传输给客户。但是持久连接再需要请资源的时候就不需要建立新的`TCP`连接了。

##### 持久连接的两种方式——非流水线和流水线

非流水线就是发一个，确认一个，才能再发下一个。
流水线就是一个个连着发，然后多个确认。

#### `HTTP`报文结构

开始行用于区别**请求报文**和**响应报文**。

- 请求报文的**方法**是指命令，就是对所请求的对象进行什么操作，如**获取/删除**等等。
- **`URL`**就是之间说的资源标识符。
- **版本**是指使用的是什么版本的`HTTP`协议。
- **`CRLF`**标识一行的结束，在整个首部行结束时，为了区别**首部行和实体主体**还会有一行单独的`CRLF`

![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLmJpdGhhY2hpLmNuLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy5wbmc?x-oss-process=image/format,png)
