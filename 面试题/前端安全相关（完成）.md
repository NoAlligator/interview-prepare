1.说一说`XSS(Cross-Site Scripting)`攻击？

[美团参考链接](https://tech.meituan.com/2018/09/27/fe-security.html#)

## 概述

`XSS`是攻击者利用**预先设置的陷阱触发的被动攻击**。

`Cross-Site Scripting`（跨站脚本攻击）简称 `XSS`，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 `Cookie`、`SessionID` 等，进而危害数据安全。

## `XSS`攻击会造成的影响

- 利用虚假输入表单骗取用户个人信息。
- 利用脚本窃取用户`Cookie`值，在被害者不知情的情况下，帮助攻击者发送恶意请求。
- 显示伪造的文章或图片。

## 案例

- `HTML`拼接注入

  - ```html
    <input type="text" value="<%= getParameter("keyword") %>">
    <button>搜索</button>
    <div>
        您搜索的关键词是：<%= getParameter("keyword") %>
    </div>
    ```

  - ```html
    <!-- 
    通过访问
    http://xxx/search?keyword="><script>alert('XSS');</script>
    注入脚本 
    -->
    <input type="text" value=""><script>alert('XSS');</script>">
    <button>搜索</button>
    <div>
        您搜索的关键词是："><script>alert('XSS');</script>
    </div>
    ```

  - 起因：通常页面中包含的用户输入内容都在固定的容器或者属性内，以文本的形式展示，攻击者**利用这些页面的用户输入片段，拼接特殊格式的字符串，突破原有位置的限制，形成了代码片段**。攻击者通过在目标网站上注入脚本，使之在用户的浏览器上运行，从而引发潜在风险。通过 `HTML` 转义，可以防止诸如此类的 `XSS` 攻击。

  - 解决方法：`HTML`转义，例如`encodeURIComponent`（但是不能防止注入`JavaScript`）。

- `JavaScript`脚本注入

  - ```html
    <a href="<%= escapeHTML(getParameter("redirect_to")) %>">跳转...</a>
    ```

  - ```html
    <!-- 当攻击URL为 http://xxx/?redirect_to=javascript:alert('XSS')时 -->
    <a href="javascript:alert(&#x27;XSS&#x27;)">跳转...</a>
    ```

  - 起因：`javascript:`这样的字符串如果出现在特定的位置诸如链接标签的`href`属性中也会引发`XSS`攻击。

  - 解决方法：设置白名单或者过滤关键词

  - ```javascript
    // 根据项目情况进行过滤，禁止掉 "javascript:" 链接、非法 scheme 等
    allowSchemes = ["http", "https"];
    
    valid = isValid(getParameter("redirect_to"), allowSchemes);
    
    if (valid) {
      <a href="<%= escapeHTML(getParameter("redirect_to"))%>">
        跳转...
      </a>
    } else {
      <a href="/404">
        跳转...
      </a>
    }
    ```

  - 经验：对于链接跳转，如 `<a href="xxx"` 或 `location.href="xxx"`，要检验其内容，禁止以 `javascript:` 开头的链接，和其他非法的`scheme`。

- 插入`JSON`时候的脚本注入

  - ```javascript
    <script>
    	var initData = <%= data.toJSON() %>
    </script>
    ```

  - 存在漏洞：当 `JSON` 中包含字符串 `</script>` 时，当前的 `script` 标签将会被闭合，后面的字符串内容浏览器会按照 `HTML` 进行解析；通过增加下一个 `<script>` 标签等方法就可以完成注入。 当 `JSON` 中包含 `U+2028` 或 `U+2029` 这两个字符时，不能作为 `JavaScript`的字面量使用，否则会抛出语法错误。

  - 注意点：`HTML`转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 `XSS` 隐患。尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。

## 总结`XSS`的注入方法

- 在 `HTML`中**内嵌的文本**中，因为后端模板没有进行正确的转义，恶意内容**以 `script` 标签形式注入**。
- 在**内联的 `JavaScript` 中**，拼接的数据突破了原本的限制形成了脚本（字符串，变量，方法名等）。
- 在**标签属性中，恶意内容包含引号**，从而突破属性值的限制，注入其他属性或者标签。
- 在**标签的 `href`、`src` 等属性中，包含 `javascript:` 等可执行代码**。
- 在 `onload`、`onerror`、`onclick` 等事件中，注入不受控制代码。
- 在 `style` 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
- 在 `style` 属性和标签中，包含类似 `expression(...)` 的 `CSS` 表达式代码（新版本浏览器已经可以防范）。

总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 `HTML` 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。

## 以下内容不可信

- 来自用户的 `UGC` 信息（用户输入信息），防止直接使用用户输入内容作为`HTML`的源码内容；
- 来自第三方的链接；
- `URL` 参数；
- `POST` 参数；
- `Referer` （可能来自不可信的来源）；
- `Cookie` （可能来自其他子域注入）；

## `XSS`分类

### 存储型（存储访问）

1. 攻击者**将恶意代码提交到目标网站的数据库中**。
2. 用户打开目标网站时，**网站服务端将恶意代码从数据库取出，拼接在 `HTML` 中返回给浏览器**。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. **恶意代码窃取用户数据并发送到攻击者的网站**，或者**冒充用户的行为，调用目标网站接口执行攻击者指定的操作**。

这种攻击常见于带有**用户保存数据的网站功能**，如**论坛发帖、商品评论、用户私信**等。

### 反射型（诱发访问）

1. 攻击者**构造出特殊的 `URL`，其中包含恶意代码**。
2. （诱导）用户打开带有恶意代码的 `URL` 时，**网站服务端将恶意代码从 `URL` 中取出，拼接在 `HTML` 中返回给浏览器。**
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 `XSS` 跟存储型 `XSS` 的区别是：存储型 `XSS` 的恶意代码存在**数据库**里，反射型 `XSS` 的恶意代码存在 **`URL`** 里。

反射型 `XSS` 漏洞常见于通过 `URL` 传递参数的功能，如**网站搜索、跳转**等。由于**需要用户主动打开恶意的 `URL` 才能生效，攻击者往往会结合多种手段诱导用户点击。**`POST` 的内容也可以触发反射型 `XSS`，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

### `DOM`型

1. 攻击者构造出特殊的 `URL`，其中**包含恶意代码。**
2. 用户打开带有恶意代码的 `URL`。
3. 用户浏览器接收到响应后解析执行，前端 `JavaScript` 取出 `URL` 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

`DOM` 型 `XSS` 跟前两种 `XSS` 的区别：`DOM` 型 `XSS` 攻击中，**取出和执行恶意代码由浏览器端完成**，属于**前端 `JavaScript` 自身的安全漏洞**，而其他两种 `XSS` 都属于**服务端的安全漏洞**。

## XSS攻击防御

`XSS`攻击两大要素：

1. 攻击者**提交恶意代码**
2. 浏览器**执行恶意代码**

### 输入过滤

结论：前端使用输入过滤是不可靠的，可能直接绕开前端发起请求导致恶意代码上传至服务器。此外，使用**转移**的方式会引入很大的不确定性和乱码。

### 预防存储型/反射性`XSS`攻击

存储型和反射型 `XSS` 都是在**服务端取出恶意代码**后，插入到**响应 `HTML`** 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

- 改成**纯前端渲染**，把**代码和数据分隔开**。
- 对 `HTML` 做充分转义。

#### 纯前端渲染

纯前端渲染的过程：

1. 浏览器先加载一个静态 `HTML`，此 `HTML` 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 `HTML` 中的 `JavaScript`。
3. `JavaScript` 通过 `Ajax` 加载业务数据，调用 `DOM API` 更新到页面上。

在纯前端渲染中，我们会**明确的告诉浏览器：下面要设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等。**浏览器不会被轻易的被欺骗，执行预期外的代码了。但纯前端渲染还需注意避免 `DOM` 型 `XSS` 漏洞（例如 `onload` 事件和 `href` 中的 `javascript:xxx` 等，请参考下文”预防 `DOM` 型 `XSS` 攻击“部分）。在很多**内部、管理系统中，采用纯前端渲染是非常合适的。**但对于性能要求高，或有 `SEO` 需求的页面，我们仍然要**面对拼接 `HTML` 的问题**。

#### 转义`HTML`

如果拼接 `HTML`是必要的，就需要**采用合适的转义库，对 `HTML` 模板各处插入点进行充分的转义**。常用的模板引擎，如 `doT.js`、`ejs`、`FreeMarker` 等，对于 `HTML` 转义通常只有一个规则，就是把 `& < > " ' /` 这几个字符转义掉，确实能起到一定的 `XSS` 防护作用，但并不完善：

### 预防`DOM`型`XSS`攻击

`DOM` 型 `XSS` 攻击，实际上就是**网站前端 `JavaScript`代码本身不够严谨，把不可信的数据当作代码执行了。**

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。如果用 `Vue/React` 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 `render` 阶段避免 `innerHTML`、`outerHTML` 的 `XSS` 隐患。

`DOM` 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，`JavaScript` 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行（`javascript:`）。如果不可信的数据拼接到字符串中传递给这些 `API`，很容易产生安全隐患，请务必避免。

如果项目中有用到这些的话，**一定要避免在字符串中拼接不可信数据**。

### 其他`XSS`防范措施

#### `Content Security Policy`

严格的 `CSP` 在 `XSS` 的防范中可以起到以下的作用：

- **禁止加载外域代码**，防止复杂的攻击逻辑。
- **禁止外域提交**，网站被攻击后，用户的数据不会泄露到外域。
- **禁止内联脚本执行**（规则较严格，目前发现 `GitHub` 使用）。
- **禁止未授权的脚本执行**（新特性，`Google Map` 移动版在使用）。
- 合理使用上报可以及时发现 `XSS`，利于尽快修复问题。

#### 输入内容长度控制

对于**不受信任的输入，都应该限定一个合理的长度**。虽然无法完全防止 `XSS` 发生，但可以**增加 `XSS`攻击的难度**。

#### 其他安全措施

- `HTTP-only Cookie`: 禁止`JavaScript` 读取某些敏感 `Cookie`，攻击者完成 `XSS` 注入后也无法窃取此 `Cookie`。
- 使用验证码：防止脚本冒充用户提交危险操作。

## XSS 的检测

1. 使用通用 `XSS` 攻击字符串手动检测 `XSS` 漏洞。
2. 使用扫描工具自动检测 `XSS` 漏洞。

```javascript
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e
```

上述代码能够检测到存在于 `HTML` 属性、`HTML` 文字内容、`HTML` 注释、跳转链接、内联 `JavaScript` 字符串、内联 `CSS` 样式表等多种上下文中的 `XSS` 漏洞，也能检测 `eval()`、`setTimeout()`、`setInterval()`、`Function()`、`innerHTML`、`document.write()` 等 `DOM` 型 `XSS` 漏洞，并且能绕过一些 `XSS` 过滤器。

只要在网站的各输入框中提交这个字符串，或者把它拼接到 `URL` 参数上，就可以进行检测：

```
http://xxx/search?keyword=jaVasCript%3A%2F*-%2F*%60%2F*%60%2F*%27%2F*%22%2F**%2F(%2F*%20*%2FoNcliCk%3Dalert()%20)%2F%2F%250D%250A%250d%250a%2F%2F%3C%2FstYle%2F%3C%2FtitLe%2F%3C%2FteXtarEa%2F%3C%2FscRipt%2F--!%3E%3CsVg%2F%3CsVg%2FoNloAd%3Dalert()%2F%2F%3E%3E
```

除了手动检测之外，还可以使用自动扫描工具寻找 XSS 漏洞，例如 [Arachni](https://github.com/Arachni/arachni)、[Mozilla HTTP Observatory](https://github.com/mozilla/http-observatory/)、[w3af](https://github.com/andresriancho/w3af) 等。

## 总结

1. `XSS` 防范是后端 `RD` 的责任，后端 `RD` 应该在所有用户提交数据的接口，对敏感字符进行转义，才能进行下一步操作。

> 不正确。因为： * 防范存储型和反射型 `XSS` 是后端 `RD` 的责任。而 `DOM` 型 `XSS` 攻击不发生在后端，是前端 `RD` 的责任。防范 `XSS` 是需要后端 `RD` 和前端 `RD` 共同参与的系统工程。 * 转义应该在输出 `HTML` 时进行，而不是在提交用户输入时。

2. 所有要插入到页面上的数据，都要通过一个敏感字符过滤函数的转义，过滤掉通用的敏感字符后，就可以插入到页面中。

> 不正确。 **不同的上下文，如 `HTML` 属性、`HTML` 文字内容、`HTML` 注释、跳转链接、内联 `JavaScript` 字符串、内联 `CSS` 样式表等，所需要的转义规则不一致。** 业务`RD` 需要选取合适的转义库，并针对不同的上下文调用不同的转义规则。

- **利用模板引擎** 开启模板引擎自带的 `HTML` 转义功能。例如： 在 `ejs` 中，尽量使用 `<%= data %>` 而不是 `<%- data %>`； 在 `doT.js` 中，尽量使用 `{{! data }` 而不是 `{{= data }`； 在 `FreeMarker` 中，确保引擎版本高于`2.3.24`，并且选择正确的 `freemarker.core.OutputFormat`。
- **避免内联事件** 尽量不要使用 `onLoad="onload('{{data}}')"`、`onClick="go('{{action}}')"` 这种拼接内联事件的写法。在 `JavaScript` 中通过 `.addEventlistener()` 事件绑定会更安全。
- **避免拼接 `HTML`** 前端采用拼接 `HTML` 的方法比较危险，如果框架允许，使用 `createElement`、`setAttribute` 之类的方法实现。或者采用比较成熟的渲染框架，如 `Vue/React` 等。
- **时刻保持警惕** 在插入位置为 `DOM` 属性、链接等位置时，要打起精神，严加防范。
- **增加攻击难度，降低攻击后果** 通过 `CSP`、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。
- **主动检测和发现** 可使用 `XSS` 攻击字符串和自动扫描工具寻找潜在的 `XSS` 漏洞。

# 2.说一说`CSRF(Cross-Site Request forgery)`攻击？

[美团参考链接](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

## 定义

`CSRF（Cross-site request forgery）`跨站请求伪造：攻击者**诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。**利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

一个典型的`CSRF`攻击有着如下的流程：

- 受害者登录`a.com`，并保留了登录凭证（`Cookie`）。
- 攻击者引诱受害者访问了`b.com`。
- `b.com` 向 `a.com`发送了一个请求：`a.com/act=xx`。浏览器会默认携带`a.com`的`Cookie`。
- `a.com`接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- `a.com`以受害者的名义执行了`act=xx`。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让`a.com`执行了自己定义的操作。

## 常见的`CSRF`攻击

### `GET`类型的`CSRF`

`GET`类型的`CSRF`利用非常简单，只需要一个`HTTP`请求，一般会这样利用：

```html
<img src="http://a.com/withdraw?amount=10000&for=hacker" >
```

在受害者访问含有这个`img`的页面后，浏览器会**自动向 `http://a.com` 发出一次`HTTP`请求**。`http://a.com` 就会**收到包含受害者登录信息的一次跨域请求**。

### `POST`类型的`CSRF`

这种类型的`CSRF`利用起来通常使用的是**一个自动提交的表单**，如：

```html
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
```

访问该页面后，表单会自动提交，相当于**模拟用户完成了一次`POST`操作**。

`POST`类型的攻击通常比`GET`要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许`POST`上面。

### 链接类型的`CSRF`

链接类型的`CSRF`并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是**在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击**，例如：

```html
<a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">重磅消息<a/>
```

由于之前用户登录了信任的网站`A`，并且保存登录状态，只要用户主动访问上面的这个`PHP`页面，则表示攻击成功。

## `CSRF`的特点

- 攻击一般发起在**第三方网站**，而不是被攻击的网站。**被攻击的网站无法防止攻击发生**。
- 攻击利用受害者在被攻击网站的登录凭证，**冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者**并不能获取到受害者的登录凭证，仅仅是“冒用”**。
- 跨站请求可以用各种方式：**图片`URL`、超链接、`CORS`、`Form`提交等等。**部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

`CSRF`通常是跨域的，**因为外域通常更容易被攻击者掌控。**但是如果本域下有容易被利用的功能，**比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险**。

## 防护策略

`CSRF`通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对`CSRF`的防护能力来提升安全性。

上文中讲了`CSRF`的两个特点：

- `CSRF`（通常）**发生在第三方域名**。
- `CSRF`攻击者**不能获取到`Cookie`等信息，只是使用**。

针对这两点，我们可以专门制定防护策略，如下：

- 阻止不明外域的访问
  - 同源检测
  - `Samesite Cookie`
- 提交时要求附加本域才能获取的信息
  - `CSRF Token`
  - 双重`Cookie`验证

### 同源检测

在`HTTP`协议中，每一个异步请求都会携带两个`Header`，用于标记来源域名：

- `Origin Header`
- `Referer Header`

这两个`Header`在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过**解析这两个`Header`中的域名，确定请求的来源域**。

#### 使用`Origin`头确定来源域名

在部分与`CSRF`有关的请求中，请求的`Header`中会携带`Origin`字段。字段内包含请求的域名（不包含`path`及`query`）。**如果`Origin`存在，那么直接使用`Origin`中的字段确认来源域名就可以。但是`Origin`在以下两种情况下并不存在**：

- **`IE11`同源策略：** `IE 11` 不会在跨站`CORS`请求上添加`Origin`标头，`Referer`头将仍然是唯一的标识。最根本原因是因为`IE 11`对同源的定义和其他浏览器有不同。
- **`302`重定向：** **在`302`重定向之后`Origin`不包含在重定向的请求中，因为`Origin`可能会被认为是其他来源的敏感信息。**对于`302`重定向的情况来说都是定向到新的服务器上的`URL`，因此浏览器不想将`Origin`泄漏到新的服务器上。

#### 使用`Referer`确定来源域名

[参考](http://www.ruanyifeng.com/blog/2019/06/http-referer.html)

根据`HTTP`协议，在`HTTP`头中有一个字段叫`Referer`，记录了该`HTTP`请求的来源地址。 对于`Ajax`请求，图片和`script`等资源请求，`Referer`为发起请求的页面地址。对于页面跳转，`Referer`为打开页面历史记录的前一个页面地址。因此我们使用`Referer`中链接的`Origin`部分可以得知**请求的来源域名**。

这种方法并非万无一失，`Referer`的值是**由浏览器提供的**，虽然`HTTP`协议上有明确的要求，但是每个浏览器对于`Referer`的具体实现可能有差别，并不能保证**浏览器自身没有安全漏洞**。使用验证 `Referer` 值的方法，就是**把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。**在部分情况下，攻击者**可以隐藏，甚至修改自己请求的`Referer`。**

`2014`年，`W3C`的`Web`应用安全工作组发布了`Referrer Policy`草案，对浏览器该如何发送`Referer`做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的`Referer`策略了。新版的`Referrer Policy`规定了五种`Referer`策略：`No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL`。之前就存在的三种策略：`never`、`default`和`always`，在新标准里换了个名称。他们的对应关系如下：

| 策略名称                   | 属性值（新）                     | 属性值（旧） |
| :------------------------- | :------------------------------- | :----------- |
| No Referrer                | no-Referrer                      | never        |
| No Referrer When Downgrade | no-Referrer-when-downgrade       | default      |
| Origin Only                | (same or strict) origin          | origin       |
| Origin When Cross Origin   | (strict) origin-when-crossorigin | -            |
| Unsafe URL                 | unsafe-url                       | always       |

根据上面的表格因此需要把`Referrer Policy`的策略设置成`same-origin`，对于同源的链接和引用，会发送`Referer`，`referer`值为`Host`不带`Path`；跨域访问则不携带`Referer`。例如：`aaa.com`引用`bbb.com`的资源，不会发送`Referer`。

设置`Referrer Policy`的方法有三种：

1. 在`CSP`设置；
2. 页面头部增加`meta`标签；
3. `a`标签增加`referrerpolicy`属性；

另外在以下情况下`Referer`没有或者不可信：

1. `IE6、7`下使用`window.location.href=url`进行界面的跳转，会丢失`Referer`。
2. `IE6、7`下使用`window.open`，也会缺失`Referer`。
3. `HTTPS`页面跳转到`HTTP`页面，所有浏览器`Referer`都丢失。
4. 点击`Flash`上到达另外一个网站的时候，`Referer`的情况就比较杂乱，不太可信。

#### 无法确认来源域名情况

如果`Origin`和`Referer`都不存在，直接进行阻止，特别是如果在没有使用随机`CSRF Token`（参考下方）作为第二次检查。

#### 如何阻止外域请求

通过`Header`的验证，我们可以知道发起请求的来源域名，这些来源域名可能是**网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名**。我们已经知道了请求域名是否是来自不可信的域名，我们直接阻止掉这些的请求，就能防御`CSRF`攻击了吗？

情形一，`GET`请求：

当一个请求是**页面请求（比如网站的主页），而来源是搜索引擎的链接（例如百度的搜索结果）**，也会被当成疑似`CSRF`攻击。所以在判断的时候**需要过滤掉页面请求情况**，通常`Header`符合以下情况：

```http
Accept: text/html
Method: GET
```

但相应的，**页面请求**就暴露在了`CSRF`的攻击范围之中。如果你的网站中，在页面的`GET`请求中**对当前用户做了什么操作的话，防范就失效了**。例如，获取用户信息等。这种严格来说**并不一定**存在`CSRF`攻击的风险，但仍然有很多网站经常把主文档`GET`请求**挂上参数来实现产品功能**，但是这样做**对于自身来说是存在安全风险的。**

情形二，本域攻击：

`CSRF`大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含**链接、图片**等，统称`UGC`），那么它可以**直接在本域发起攻击**，这种情况下同源策略无法达到防护的作用。

综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。

### `CSRF Token`

前面讲到CSRF的另一个特征是，攻击者**无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。**而CSRF攻击之所以能够成功，是因为服务器**误把攻击者发送的请求当成了用户自己的请求。**那么我们可以**要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。**

#### `CSRF Token`防护策略的三个步骤：

1. 将`CSRF Token`输出到页面中：首先，用户打开页面的时候，服务器需要给这个用户生成一个`Token`，该`Token`通过加密算法对数据进行加密，一般`Token`都包括随机字符串和时间戳的组合，显然**在提交时`Token`不能再放在`Cookie`中了，否则又会被攻击者冒用。**因此，为了安全起见`Token`最好还是存在服务器的`Session`中，之后在每次页面加载时，使用`JS`遍历整个`DOM`树，对于`DOM`中所有的`a`和`form`标签后加入`Token`。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的`HTML`代码，这种方法就没有作用，还需要程序员在编码时手动添加`Token`。

2. 页面提交的请求携带这个`Token`：对于`GET`请求，`Token`将附在请求地址之后，这样`URL`就变成`http://url/?csrftoken=tokenvalue`。 而对于`POST`请求来说，要在`form`的最后加上：

   ```html
     <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>
   ```

   这样，就把`Token`**以参数的形式加入请求**了。

3. 服务器验证`Token`是否正确：当用户从客户端得到了`Token`，再次提交给服务器的时候，服务器需要判断`Token`的有效性，验证过程是先解密`Token`，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个`Token`就是有效的。这种方法要比之前检查`Referer`或者`Origin`要安全一些，`Token`可以在产生并放于`Session`之中，然后在每次请求时把`Token`从`Session`中拿出，与请求中的`Token`进行比对，但这种方法的比较麻烦的在于如何把`Token`以参数的形式加入请求。

### 双重`Cookie`验证

在会话中存储`CSRF Token`比较繁琐，而且不能在通用的拦截上统一处理所有的接口。那么另一种防御措施是使用**双重提交`Cookie`**。利用`CSRF`攻击不能获取到用户`Cookie`的特点，我们可以要求`Ajax`和表单请求携带一个`Cookie`中的值。

双重`Cookie`采用以下流程：

- 在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如`csrfcookie=v8g9e4ksfhw`）。
- 在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例`POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）。
- 后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。

此方法相对于`CSRF Token`就简单了许多。可以直接通过前后端拦截的的方法**自动化实现**。**后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储`Token`**。当然，此方法并没有大规模应用，其在大型网站上的安全性还是没有CSRF Token高，原因我们举例进行说明：

由于任何跨域都会导致**前端无法获取`Cookie`中的字段**（包括子域名之间），于是发生了如下情况：

- 如果用户访问的网站为`www.a.com`，而后端的`api`域名为`api.a.com`。那么在`www.a.com`下，前端拿不到`api.a.com`的`Cookie`，也就无法完成双重`Cookie`认证。
- 于是这个认证`Cookie`必须被种在`a.com`下，这样每个子域都可以访问。
- 任何一个子域都可以修改`a.com`下的`Cookie`。
- 某个子域名存在漏洞被`XSS`攻击（例如`upload.a.com`）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了`a.com`下的`Cookie`。
- 攻击者可以直接使用自己配置的`Cookie`，对XSS中招的用户再向`www.a.com`下，发起`CSRF`攻击。

**用双重Cookie防御CSRF的优点：**

- 无需使用`Session`，适用面更广，易于实施。
- `Token`储存于客户端中，不会给服务器带来压力。
- 相对于`Token`，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。

**缺点：**

- `Cookie`中增加了额外的字段。
- 如果有其他漏洞（例如`XSS`），攻击者可以注入`Cookie`，那么该防御方式失效。
- **难以做到子域名的隔离。**
- 为了确保`Cookie`传输安全，采用这种防御方式的最好确保用整站`HTTPS`的方式，如果还没切`HTTPS`的使用这种方式也会有风险。

### `Samesite Cookie` 属性

防止`CSRF`攻击的办法已经有上面的预防措施。为了从源头上解决这个问题，`Google`起草了一份草案来改进`HTTP`协议，那就是**为`Set-Cookie`响应头新增`Samesite`属性，它用来标明这个 `Cookie`是个“同站 `Cookie`”，同站`Cookie`只能作为第一方`Cookie`，不能作为第三方`Cookie`**，`Samesite`有两个属性值，分别是 `Strict` 和 `Lax`，下面分别讲解：

**Samesite=Strict**

这种称为严格模式，表明这个 `Cookie` 在任何情况下都不可能作为第三方 `Cookie`，绝无例外。比如说 `b.com` 设置了如下 `Cookie`：

```html
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```

我们在 `a.com`下发起对 `b.com`的任意请求，`foo` 这个 `Cookie` 都不会被包含在 `Cookie` 请求头中，但 `bar` 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 `Cookie` 被设置成了 `Samesite=Strict`，那么用户**从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 `Cookie`，其它网站发起的对淘宝的任意请求都不会带上那个 `Cookie`。**

**Samesite=Lax**

这种称为宽松模式，比 `Strict` 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个`GET`请求，则这个`Cookie`可以作为第三方`Cookie`。比如说 `b.com`设置了如下`Cookie`：

```html
Set-Cookie: foo=1; Samesite=Strict
Set-Cookie: bar=2; Samesite=Lax
Set-Cookie: baz=3
```

当用户从 `a.com`点击链接进入 `b.com` 时，`foo` 这个 `Cookie`不会被包含在 `Cookie` 请求头中，但 `bar`和 `baz` 会，也就是说**用户在不同网站之间通过链接跳转是不受影响**了。但假如这个请求是从 `a.com`发起的对 `b.com` 的异步请求，或者**页面跳转是通过表单的 `post` 提交触发的，则`bar`也不会发送**。

#### 我们应该如何使用SamesiteCookie

如果SamesiteCookie被设置为Strict，**浏览器在任何跨域请求中都不会携带Cookie，新标签重新打开也不携带，所以说CSRF攻击基本没有机会**。但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的Cookie都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。**对于用户来讲，可能体验不会很好。**如果SamesiteCookie被设置为Lax，那么其他网站通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。另外一个问题是**Samesite的兼容性不是很好，现阶段除了从新版Chrome和Firefox支持以外，Safari以及iOS Safari都还不支持，现阶段看来暂时还不能普及。**而且，SamesiteCookie目前有一个致命的缺陷：**不支持子域。**例如，种在topic.a.com下的Cookie，并不能使用a.com下种植的SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用SamesiteCookie在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。总之，SamesiteCookie是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。

## 防止网站被利用

前面所说的，都是被攻击的网站如何做好防护。而非防止攻击的发生，`CSRF`的攻击可以来自：

- **攻击者自己的网站。**
- **有文件上传漏洞的网站。**
- **第三方论坛等用户内容。**
- **被攻击网站自己的评论功能等。**

对于来自黑客自己的网站，我们无法防护。但对其他情况，那么如何防止自己的网站被利用成为攻击的源头呢？

> 主要防止的是站外CSRF和站内CSRF攻击。

- 严格管理自己的涉及**用户数据操作的接口**，防止其能够通过非法跨域请求成功；
- 严格管理所有的**上传接口**，防止任何预期之外的上传内容（例如`HTML`）。
- 添加`Header`  `X-Content-Type-Options: nosniff` 防止黑客上传`HTML`内容的资源（例如图片）被解析为网页。
- 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接，这是为了防止发起站内`CSRF`攻击。
- 当前用户**打开其他用户填写的链接时，需告知风险**（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。

## 总结

简单总结一下上文的防护策略：

- CSRF自动防御策略：**同源检测（Origin 和 Referer 验证）**。
- CSRF主动防御措施：**CSRF Token验证** 或者 **双重Cookie验证** 以及配合**Samesite Cookie**。
- 保证页面的幂等性，后端接口不要在GET页面中做用户操作。

为了更好的防御CSRF，最佳实践应该是结合上面总结的防御措施方式中的优缺点来综合考虑，结合当前Web应用程序自身的情况做合适的选择，才能更好的预防CSRF的发生。

# 3.说一说`XSS`和`CSRF`的区别？

[用大白话谈谈XSS与CSRF](https://segmentfault.com/a/1190000007059639)

通常来说CSRF是由XSS实现的，所以CSRF时常也被称为XSRF[用XSS的方式实现伪造请求]（但实现的方式绝不止一种，还可以直接通过命令行模式（命令行敲命令来发起请求）直接伪造请求[只要通过合法验证即可]）。
XSS**更偏向于代码实现**（即写一段拥有跨站请求功能的JavaScript脚本注入到一条帖子里，然后有用户访问了这个帖子，这就算是中了XSS攻击了），CSRF**更偏向于一个攻击结果**，只要发起了冒牌请求那么就算是CSRF了。

**XSS更偏向于方法论，CSRF更偏向于一种形式**，只要是伪造用户发起的请求，都可成为CSRF攻击。

# 4.前端加密

## 加密算法

不同于哈希(后面会提到)，加密（`Encrypt`）是将目标文本转换成具有不同长度的、**可逆的密文**。也就是说加密算法是可逆的，而且其加密后生成的密文长度和明文本身的长度有关。所以**如果被保护数据在以后需要被还原成明文，则需要使用加密。**

在加密算法中又分为对称加密（`symmetric encryption`）和非对称加密（`asymmetric encryption`）。

### 对称加密

对称加密采用了对称密码编码技术，它的特点是文件加密和解密使用相同的密钥加密，也就是**加密和解密都是用同一个密钥**，这种方法在密码学中叫做对称加密算法.

前端使用对称加密的问题：因为前端的透明性，**对于登录密码等敏感信息,就不要使用`JavaScript`来进行对称加密。** 因为别人可以从前端得到密匙后，可以直接对信息进行解密。

### 非对称加密

非对称加密算法需要两个密钥：公钥（`publickey`）和私钥（`privatekey`）。   公钥与私钥是一对，**如果用公钥对数据进行加密，只有用对应的私钥才能解密；如果用私钥对数据进行加密，那么只有用对应的公钥才能解密。** 因为加密和解密使用的是**两个不同的密钥**，所以这种算法叫作非对称加密算法。

非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它方公开；得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公钥加密后的任何信息。

## 哈希加密算法

**哈希（Hash）是将目标文本转换成具有固定长度的字符串（或叫做消息摘要）。** 当输入发生改变时，产生的哈希值也是完全不同的。从数学角度上讲，一个哈希算法是一个多对一的映射关系，对于目标文本 T，算法 H 可以将其唯一映射为 R，并且对于所有的 T，R 具有相同的长度，所以 H 不存在逆映射，也就是说**哈希算法是不可逆的。**

基于哈希算法的特性，其适用于该场景：被保护数据仅仅用作比较验证且不需要还原成明文形式。**比较常用的哈希算法是 MD5 和 SHA1 。**

现在，对于简单的哈希算法的攻击方法主要有：寻找碰撞法和穷举法。所以，为了保证数据的安全，可以**在哈希算法的基础上进一步的加密，常见的方法有：加盐、慢哈希、密钥哈希、XOR 等。**

### 加盐

加盐加密是一种对系统登录口令的加密方式，它实现的方式是**将每一个口令同一个叫做“盐”（`salt`）的 `n` 位随机数相关联**。

使用`salt`加密，它的基本想法是这样的：

- 用户注册时，在密码上撒一些盐。生成一种味道，记住味道。
- 用户再次登陆时，在输入的密码上撒盐，闻一闻，判断是否和原来的味道相同，相同就让你吃饭。

由于验证密码时和最初散列密码时使用相同的盐值，所以**`salt`存储在数据库**。并且**这个值是由系统随机产生的**，而非硬编码。这就保证了**所要保护对象的机密性**。

#### 注册时

- 用户注册，系统随机产生`salt`值。

- 将`salt`值和密码连接起来，生产`hash`值。

- 将`hash`值和`salt`值分别存储在数据库中。

  ![img](https://github.com/NoAlligator/pico/blob/main/img/1690efb5388875bf~tplv-t2oaga2asx-watermark.awebp?raw=true)

#### 登陆时

- 系统根据用户名找到与之对应的密码`hash`。
- 将用户输入密码和`salt`值进行散列。
- 判断生成的`hash`值是否和数据库中`hash`相同。

![img](https://github.com/NoAlligator/pico/blob/main/img/1690efc4dc5d6c0f~tplv-t2oaga2asx-watermark.awebp?raw=true)

#### 正确的加盐方式

- 盐值应该使用加密的安全伪随机数生成器（ `Cryptographically Secure Pseudo-Random Number Generator`，`CSPRNG` ）产生，比如 `C` 语言的 `rand()` 函数，这样生成的随机数高度随机、完全不可预测；
- 盐值混入目标文本中，一起使用**标准的加密函数进行加密**；
- 盐值要**足够长**（经验表明：盐值至少要跟哈希函数的输出一样长）且永不重复；
- 盐值最好**由服务端提供**，前端取值使用。

## 慢哈希函数

顾名思义，慢哈希函数是将哈希函数变得非常慢，使得攻击方法也变得很慢，慢到足以令攻击者放弃，而往往由此带来的延迟也不会引起用户的注意。降低攻击效率用到了密钥扩展（ `key stretching`）的技术，而密钥扩展的实现使用了一种 `CPU` 密集型哈希函数（ `CPU-intensive hash function`）。

密钥扩展：如果想在一个 `Web` 应用中使用密钥扩展，则需要设定较低的迭代次数来降低额外的计算成本。我们一般直接选择使用标准的算法来完成，比如 `PBKDF2` 或 `bcrypt` 。`PHP`、斯坦福大学的 `JavaScript` 加密库都包含了 `PBKDF2` 的实现，浏览器中则可以考虑使用 `JavaScript` 完成，否则这部分工作应该由服务端进行计算。

## 密匙哈希

密钥哈希是**将密钥添加到哈希加密**，这样**只有知道密钥的人才可以进行验证**。目前有两种实现方式：使用 `ASE` 算法对哈希值加密、使用密钥哈希算法 `HMAC` 将密钥包含到哈希字符串中。为了保证密钥的安全，需要将其存储在外部系统（比如一个物理上隔离的服务端）。即使选择了密钥哈希，在其基础上进行加盐或者密钥扩展处理也是很有必要。目前密钥哈希用于服务端比较多，例如来应对常见的 `SQL` 注入攻击。

## XOR

`XOR` 运算有一个特性：**如果对一个值连续做两次 `XOR`，会返回这个值本身。这也是其可以用于信息加密的根本。**

目标文本 `message`，`key` 是密钥，第一次执行 `XOR` 会得到加密文本；在加密文本上再用 `key` 做一次 `XOR` 就会还原目标文本 `message`。为了保证 `XOR` 的安全，需要满足以下两点：

- `key` 的长度大于等于 `message `；
- `key` 必须是一次性的，且每次都要随机产生。

下面以登录密码加密为例介绍下 `XOR` 的使用：

第一步：使用 `MD5` 算法，计算密码的哈希；

```
const message = md5(password);
```

第二步：生成一个随机 `key` 值；

第三步：进行 `XOR` 运算，求出加密后的 message。

```javascript
function getXOR(message, key) {
    const arr = [];
    //假设 key 是32位的
    for (let i = 0; i < 32; i++) {
        const  m = parseInt(message.substr(i, 1), 16);
        const k = parseInt(key.substr(i, 1), 16);
        arr.push((m ^ k).toString(16));
    }
    return arr.join('');
}
```

如上所示，使用 `XOR` 和一次性的密钥 `key` 对密码进行加密处理，只要 `key` 没有泄露，目标文本就不会被破解。

## 如何选择加密方式？

- 选择经过验证的成熟算法，如 `PBKDF2` 等 ；
- `crypt` 的安全版本；
- 避免使用自己设计的加密算法。

## 结合验证码进行前端加密

前端先将密码哈希，然后**和用户输入的验证码进行哈希**，得到的结果作为密码字段发送给服务器。服务器先确认验证码正确，然后再进行密码验证，否则直接返回验证码错误信息。这种实践保证了密码在传输过程中的资料安全，即使攻击者拿到了数据也无法重放。图形化验证码更是增加了难度。另一方面该实践大大增加了撞库的成本。

前端加密一定程度保障了传输过程中的资料安全，那么会不会有对两端（客户端和服务器）有安全帮助呢？

有帮助，使用一些前端加密手段，可以增加拖库后的数据破解难度（每次尝试校验前必须通过验证码校验）。但是验证码方法不具有这样的功能，因为数据库存的仍是明文密码哈希后的结果，那么攻击者可以绕过前端加密，可以直接暴力破解。

