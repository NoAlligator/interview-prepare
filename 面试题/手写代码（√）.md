## 1.æ‰‹å†™`call`ã€`apply`ã€`bind`âˆš

```javascript
//call
Function.prototype.__call__ = function (that, ...args) {
    if (typeof this !== 'function') throw new TypeError('__call__ must be invoked by a function')
    const context = that || window
    const symbol = Symbol()
    context[symbol] = this
    const ret = context[symbol](...args)
    Reflect.deleteProperty(context, symbol)
    return ret
}
//apply
Function.prototype.__apply__ = function (that, args) {
    if (typeof this !== 'function') throw new TypeError('__apply__ must be invoked by a function')
    const context = that || window
    const symbol = Symbol()
    context[symbol] = this
    const ret = context[symbol](...args)
    Reflect.deleteProperty(context, symbol)
    return ret
}
```

```javascript
//bind
Function.prototype.__bind__ = function (that, args) {
    if (typeof this !== 'function') throw new TypeError('__bind__ must be invoked by a function')
    const _this = this
    return function (...argsNew) {
        if (this instanceof Function) {
            return new _this(...args, ...argsNew)
        } else {
            return _this.apply(that, [...args, ...argsNew])
        }
    }
}

//æ­£ç¡®ç‰ˆæœ¬
Function.prototype.__bind__ = function (context = window, ...args_front) {
    if (typeof this !== 'function') throw new TypeError('You can not use call() at a non-function')
    const fSelf = this
    const fEmpty = function () {
    }
    const fBound = function (...args_back) {
        if (this instanceof fEmpty) {
            Object.setPrototypeOf(this, fSelf.prototype)
            return fSelf.apply(this, ...args_front.concat(args_back))
        }
        return fSelf.apply(context, ...args_front.concat(args_back))
    }
    fEmpty.prototype = fSelf.prototype
    fBound.prototype = new fEmpty()
    return fBound
}

//æµ‹è¯•
function A(name, age) {
    console.log(name)
    console.log(age)
    console.log(this)
}
let obj = {
    value: "foo"
}
console.log(new (A.bind(obj, 'ycp'))(21) instanceof A)
console.log(A.bind(obj, 'ycp')(21))
```

## 2.æ‰‹å†™å®šé•¿ã€ä¸å®šé•¿æŸ¯é‡ŒåŒ–âˆš

```javascript
//å®šé•¿æŸ¯é‡ŒåŒ–
function curry(fn) {
    return function curried(...args) {
        if (fn.length > args.length) {
            return function (...argsNew) {
                return curried.call(this, ...[...args, ...argsNew])
            }
        } else {
            return fn.call(this, ...args)
        }
    }
}

//ç®€åŒ–ç‰ˆ
const currySimple = (fn, ...args) =>
args.length < fn.length ? (...argNew) => currySimple(fn, ...[...args, ...argNew]) : fn(...args)
```

```javascript
//ä¸å®šé•¿æŸ¯é‡ŒåŒ–
function curryInfinity(fn) {
    return function curried(...args) {
        if (args.length === 0) {
            return fn.call(this, ...args)
        } else {
            return function (...argsNew) {
                if (argsNew.length === 0) return fn.call(this, ...args)
                return curried.call(this, ...[...args, ...argsNew])
            }
        }
    }
}
```

## 3.æ‰‹å†™é˜²æŠ–âˆš

å‡å°‘é«˜é¢‘è§¦å‘äº‹ä»¶ä¸­ä¸å¿…è¦çš„é¢‘ç¹è¯·æ±‚æˆ–è€…é¢‘ç¹è®¡ç®—ã€‚

- ç”¨æˆ·è¾“å…¥ä¹‹åçš„æœ¬åœ°è¿‡æ»¤ï¼Œè¿‡æ»¤çš„æ•°æ®æ¯”è¾ƒé‡ï¼Œéœ€è¦é˜²æŠ–ã€‚
- é¢‘ç¹è§¦å‘çš„äº‹ä»¶ï¼Œä¾‹å¦‚çª—å£resizeï¼Œè§†åœºæ™¯ä½¿ç”¨é˜²æŠ–è¿˜æ˜¯èŠ‚æµã€‚

```javascript
//éç«‹å³æ‰§è¡Œç‰ˆ
function debounce(fn, delay = 500) {
    let timer
    return function (...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.call(this, ...args)
        }, delay)
    }
}
```

```javascript
//ç«‹å³æ‰§è¡Œç‰ˆ
function debounceImmediate(fn, delay = 500, immediate = true) {
    let timer
    return function (...args) {
        if (timer) clearTimeout(timer)
        if (immediate) {
            if (!timer) fn.call(this, ...args)
            timer = setTimeout(() => {
                timer = null    //æ¢å¤æ‰§è¡Œæƒ
            }, delay)
        } else {
            timer = setTimeout(() => {
                fn.call(this, ...args)
            }, delay)
        }
    }
}
```

## 4.æ‰‹å†™èŠ‚æµâˆš

ç¨€é‡Šé«˜é¢‘è§¦å‘çš„äº‹ä»¶

- ç”¨æˆ·è¾“å…¥è¿‡ç¨‹ä¸­çš„æœç´¢ï¼Œå¯ä»¥åŠ ä¸€å±‚èŠ‚æµã€‚
- é¢‘ç¹è§¦å‘çš„äº‹ä»¶ï¼Œæ¯”å¦‚resizeï¼Œå¦‚æœresizeäº‹ä»¶å¤„ç†å‡½æ•°å¾ˆé‡çš„è¯å¯ä»¥è€ƒè™‘åˆ©ç”¨èŠ‚æµç¨€é‡Šè§¦å‘é¢‘ç‡ï¼›
- å®ç°è§„å¾‹è®¡ç®—ã€è¯·æ±‚ï¼Œä¾‹å¦‚åŸ‹ç‚¹ä¸ŠæŠ¥ã€‚

```javascript
//æ—¶é—´æˆ³ï¼Œç«‹å³æ‰§è¡Œï¼Œæœ€åä¸æ‰§è¡Œ
function throttleBefore(fc, delay = 500) {
    let prev = 0;
    return function (params) {
        let now = Date.now();
        let that = this;
        if (now - prev > delay) {
            fc.call(that, params);
            prev = now;
        }
    }
}
```

```javascript
//å®šæ—¶å™¨ï¼Œå»¶åæ‰§è¡Œï¼Œæœ€åæ‰§è¡Œ
function throttleAfter(fc, delay = 500) {
    let timer = null;
    return function (params) {
        let that = this;
        if (!timer) {
            timer = setTimeout(function () {
                timer = null;
                fc.call(that, params);
            }, delay)
        }
    }
}
```

```javascript
//å®šæ—¶å™¨+æ—¶é—´æˆ³ï¼Œç«‹å³æ‰§è¡Œï¼Œå»¶åæ‰§è¡Œï¼Œæœ€åå†æ‰§è¡Œ
function throttle(fc, delay = 500) {
    let timer = null;   //æ–°å¢è®¡æ—¶å™¨
    let prev = 0;
    return function (params) {
        let that = this;
        let now = Date.now();
        clearTimeout(timer);    //é¢‘ç¹ç‚¹å‡»çš„æ—¶å€™æ¯ä¸€æ¬¡éƒ½ä¼šæ¸…é™¤è®¡æ—¶å™¨

        if (now - prev >= delay) { //åˆ°è¾¾æ—¶é—´åæ¢å¤æ‰§è¡Œ
            fc.call(that, params);
            prev = now;
        } else {
            timer = setTimeout(function () {
                fc.call(that, params);
            }, delay)
        }
    }
}

```

## 5.æ‰‹å†™æ·±æ‹·è´âˆš

```javascript
const deepCloneBetter = (target, map = new Map()) => {

    const isReference = () => target && (typeof target === 'object' || typeof target === 'function')
    const getTag = () => Object.prototype.toString.call(target).split(' ')[1].slice(0, -1).toLowerCase()

    if (!isReference(target)) return target        //åŸºæœ¬ç±»å‹ç›´æ¥è¿”å›

    if (map.has(target)) return map.get(target)    //æŸ¥åˆ°å¾ªç¯å¼•ç”¨ï¼Œç›´æ¥è¿”å›

    // ä»¥ä¸‹åˆ†ä¸ºä¸¤ç±»ï¼šå¯ä»¥å†è¿›è¡Œéå†æ·±å…‹éš† ï¼† æ— éœ€è¿›è¡Œéå†æ·±å…‹éš†çš„
    // æ— éœ€æ·±å…‹éš†çš„ä½¿ç”¨getTypeofè·å–ç±»å‹åä½¿ç”¨switchè¿›è¡Œåˆ†æµåˆ›å»ºå¯¹è±¡å‰¯æœ¬
    // éœ€è¦ç»§ç»­æ·±å…‹éš†çš„æ ¹æ®ç±»å‹å†è¿›è¡Œæ·±å…‹éš†

    //ä»¥ä¸‹å¯¹å¼•ç”¨ç±»å‹è¿›è¡Œå¤„ç†

    if (getTag(target) === 'map') {
        const cloneTarget = new Map()
        map.set(target, cloneTarget)
        Object.entries(target).forEach(([key, value]) => void cloneTarget.set(key, deepCloneBetter(value)))
    }

    if (getTag(target) === 'set') {
        const cloneTarget = new Set()
        map.set(target, cloneTarget)
        target.forEach((ele) => void cloneTarget.add(deepCloneBetter(ele)))
    }

    if (getTag(target) === 'object') {
        const cloneTarget = {}
        map.set(target, cloneTarget)
        Object.entries(target).forEach(([key, value]) => void (cloneTarget[key] = deepCloneBetter(value, map)))
    }

    if (getTag(target) === 'array') {
        const cloneTarget = []
        map.set(target, cloneTarget)
        target.forEach((ele, index) => void (cloneTarget[index] = deepCloneBetter(ele, map)))
    }

    return target
}
```

## 6.æ‰‹å†™äº‹ä»¶æ€»çº¿ï¼ˆå‘å¸ƒ-è®¢é˜…ï¼‰âˆš

```javascript
// ä¸å¸¦é˜Ÿåˆ—çš„äº‹ä»¶æ€»çº¿
class EventEmitter {
    constructor() {
        this.events = this.events || new Map()
    }

    $on(type, fn) {
        if (!this.events.has(type)) {
            this.events.set(type, fn)
        }
    }

    $emit(type, ...args) {
        if (!this.events.has(type)) return void 0
        this.events.get(type).call(this, ...args)
    }

    $off(type) {
        this.events.has(type) && this.events.delete(type)
    }

    $once(type, fn) {
        this.$on(type, (...args) => {
            fn.call(this, ...args)
            this.$off(type)
        })
    }
}
```

```js
// å¸¦é˜Ÿåˆ—çš„äº‹ä»¶æ€»çº¿
class EventEmitter {
    constructor() {
        this.events = new Map()
    }

    $on(type, fn) {
        let set = this.events.get(type)
        if (!set) {
            set = new Set()
            this.events.set(type, set)
            set.add((...args) => fn(...args))
        } else {
            set.add((...args) => fn(...args))
        }
    }

    $once(type, fn) {
        let set = this.events.get(type)
        if (!set) {
            let set = new Set()
            let callback = (...args) => {
                fn(...args)
                set.delete(callback)
            }
            set.add(callback)
            this.events.set(type, set)
        } else {
            let callback = (...args) => {
                fn(...args)
                set.delete(callback)
            }
            set.add(callback)
        }
    }

    $emit(type, ...args) {
        let set = this.events.get(type)
        if (!set) return void 0
        set.forEach(callback => callback(...args))
    }

    $off(type) {
        this.events.has(type) && this.events.delete(type)
    }
}
```



## 7.æ‰‹å†™`instanceof`âˆš

```javascript
function myInstanceof(left, right) {
    const prototype = right.prototype
    let prototypeLine = Object.getPrototypeOf(left)
    while (prototypeLine !== null) {
        if (prototypeLine === prototype) return true
        prototypeLine = Object.getPrototypeOf(prototypeLine)
    }
    return false
}
```

## 8.æ‰‹å†™`new`âˆš

```javascript
const _new = (Con, ...args) => {
    if (typeof Con !== 'function') throw new TypeError('Con must be of a constructor function')
    const obj = Object.create(Con.prototype)
    const ret = Con.call(obj, ...args)
    return ret instanceof Object ? ret : obj
}
```

## 9.æ‰‹å†™`Object.create()`âˆš

```javascript
Object.prototype.__create__ = (o) => {
    function F() {}
    F.prototype = o
    return new F()
}
```

## 10.æ‰‹å†™`Promise`ï¼ˆç¬¦åˆ`Promise A+`è§„èŒƒï¼‰âˆš

```javascript
class MyPromise {
    static PENDING = 'pending'
    static REJECTED = 'rejected'
    static FULLFILLED = 'fullfilled'
    status = MyPromise.PENDING
    value = undefined
    reason = undefined
    //askï¼šthis.onFullfilledCallbacksæ˜¯åœ¨åšä»€ä¹ˆäº‹æƒ…?
    //answerï¼šåœ¨promiseè½å®šåå°†ä¹‹å‰ï¼ˆæœªèƒ½ç«‹å³è½å®šè€Œå­˜å‚¨åœ¨å›è°ƒæ•°ç»„ä¸­çš„å›è°ƒå‡½æ•°ï¼‰è¿›è¡Œè°ƒç”¨ã€‚
    //ä¹Ÿå°±æ˜¯å¼‚æ­¥ç»“æœæœ‰äº†è¿”å›å€¼ä¹‹åï¼Œå¼€å§‹è°ƒç”¨å›è°ƒå‡½æ•°çš„åŸç†
    onFullfilledCallbacks = []
    onRejectedCallbacks = []
    constructor(cb) {
      //askï¼šä¸ºä»€ä¹ˆè¦ç¡®å®šthis.status === MyPromise.PENDING?
      //answerï¼šå› ä¸ºè¦ç¡®ä¿ä¸æ˜¯è½å®šçŠ¶æ€ï¼Œæ‰èƒ½æ›´æ”¹çŠ¶æ€
      const resolve = value => {
        if (this.status === MyPromise.PENDING) {
          this.status = MyPromise.FULLFILLED
          this.value = value
          this.onFullfilledCallbacks.forEach(cb => cb(this.value))
        }
      }
      const reject = reason => {
        if (this.status === MyPromise.PENDING) {
          this.status = MyPromise.REJECTED
          this.reason = reason
          this.onRejectedCallbacks.forEach(cb => cb(this.reason))
        }
      }
      try {
        cb(resolve, reject)
      } catch (e) {
        //é˜²æ­¢è°ƒç”¨å¤±è´¥
        reject(e)
      }
    }

    then(onFullfilled, onRejected) {
      if (this.status === MyPromise.FULLFILLED) {
        const promise2 = new MyPromise((resolve, reject) => {
          //è¿™é‡Œä½¿ç”¨çš„æ˜¯å®ä»»åŠ¡è¿›è¡Œæ¨¡æ‹Ÿ
          queueMicrotask(() => {
            try {
              if (typeof onFullfilled !== 'function') {
                resolve(this.value)
              } else {
                const x = onFullfilled(this.value)
                this.resolvePromise(promise2, x, resolve, reject)
              }
            } catch (e) {
              reject(e)
            }
          })
        })
        return promise2
      }
    if (this.status === MyPromise.REJECTED) {
        const promise2 = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try {
                    if (typeof onRejected !== 'function') {
                        resolve(this.value)
                    } else {
                        const x = onRejected(this.value)
                        this.resolvePromise(promise2, x, resolve, reject)
                    }
                } catch (e) {
                    reject(e)
                }
            })
        })
        return promise2
    }
    if (this.status === MyPromise.PENDING) {
        const promise2 = new MyPromise((resolve, reject) => {
            this.onFullfilledCallbacks.push(() => {
                queueMicrotask(() => {
                    try {
                        if (typeof onFullfilled !== 'function') {
                            resolve(this.value)
                        } else {
                            const x = onFullfilled(this.value)
                            this.resolvePromise(promise2, x, resolve, reject)
                        }
                    } catch (e) {
                        reject(e)
                    }
                })
            })
            this.onRejectedCallbacks.push(() => {
                queueMicrotask(() => {
                    try {
                        if (typeof onRejected !== 'function') {
                            resolve(this.reason)
                        } else {
                            const x = onRejected(this.value)
                            this.resolvePromise(promise2, x, resolve, reject)
                        }
                    } catch (e) {
                        reject(e)
                    }
                })
            })
        })
        return promise2
    }
}

catch(onRejected) {
    return this.then(null, onRejected)
}

finally(onFinally) {
    return this.then(value => MyPromise.resolve(onFinally()).then(() => value),
                     reason => MyPromise.resolve(onFinally()).then(() => {
        throw reason
    })
                    )
}

resolvePromise(promise, x, resolve, reject) {
    if (x === promise) return reject(new TypeError('The promise and the return value are the same'))
    if (typeof x === 'object' || typeof x === 'function') {
        if (x === null) return resolve(x) //nullå¯èƒ½ä½œä¸ºobjectè¿›å…¥ï¼Œæ‰€ä»¥è¦ç›´æ¥è¿”å›
        let then
        //é˜²æ­¢thenå–å€¼å¤±è´¥
        try {
            then = x.then
        } catch (e) {
            reject(e)
        }
        if (typeof then === 'function') {
            let called = false //é˜²æ­¢resolveè¢«thenableå›è°ƒå‡½æ•°å†…éƒ¨å¤šæ¬¡è°ƒç”¨
            try {
                then.call(x, value => {
                    if (called) return
                    called = true
                    this.resolvePromise(promise, value, resolve, reject)
                }, reason => {
                    if (called) return
                    called = true
                    reject(promise, reason, resolve, reject)
                })
            } catch (e) {
                if (called) return
                reject(e)
            }
        } else {
            resolve(x)
        }
    } else {
        resolve(x)
    }
}

deferred() {
    const res = {}
    res.promise = new MyPromise((resolve, reject) => {
        res.resolve = resolve
        res.reject = reject
    })
    return res
}

static resolve(tar) {
    if (tar instanceof MyPromise) {
        return tar
    }
    return new MyPromise((resolve, reject) => {
        if (tar && tar.then && typeof tar.then === 'function') {
            queueMicrotask(() => tar.then(resolve, reject))
        } else {
            resolve(tar)
        }
    })
}

static reject(reason) {
    return new MyPromise((resolve, reject) => reject(reason))
}

static all(...promises) {
    return new MyPromise((resolve, reject) => {
        let count = 0
        const resPromise = []
        const length = promises.length
        if (length === 0) return resolve(resPromise)
        promises.forEach((promise, index) => {
            (promise instanceof MyPromise ? promise : MyPromise.resolve(promise)).then(value => {
                count++
                resPromise[index] = value
                if (count === length) resolve(resPromise)
            }, reason => {
                reject(reason)
            })
        })
    })
}

static allSettled(...promises) {
    return new MyPromise((resolve, reject) => {
        let count = 0
        const resPromise = []
        const length = promises.length
        if (length === 0) return resolve(resPromise)
        promises.forEach((promise, index) => {
            (promise instanceof MyPromise ? promise : MyPromise.resolve(promise)).then(value => {
                count++
                resPromise[index] = {
                    status: MyPromise.FULLFILLED, value
                }
                if (count === length) resolve(resPromise)
            }, reason => {
                count++
                resPromise[index] = {
                    status: MyPromise.REJECTED, reason
                }
                if (count === length) resolve(resPromise)
            })
        })
    })
}

static race(...promises) {
    return new MyPromise((resolve, reject) => {
        const length = promises.length
        for (let i = length; i < length; i++) {
            (promises[i] instanceof MyPromise ? promises[i] : MyPromise.resolve(promises[i])).then(value => {
                return resolve(value)
            }, reason => {
                return reject(reason)
            })
        }
    })
}

}

queueMicrotask(() => {
    console.log('timer')
})
new MyPromise(res => res('promise'))
    .then(value => {
    console.log(value)
})

```

## 11.æ‰‹å†™`Ajax`ï¼ˆåŸºäº`Promise`ï¼‰ï¼Ÿâˆš

> `XMLHttpRequest`ç›¸å…³çš„`API`

```javascript
const {response, responseText, status, statuText, readyState, responseType, responseURL, responseXML, upload} = xhr

xhr.abort() 		//ä¸­æ­¢
xhr.open()			//å¼€å¯
xhr.send()			//å‘é€
xhr.onreadystatechange = handler //è¯·æ±‚çŠ¶æ€æ”¹å˜

xhr.onload = handler		//è¯·æ±‚æˆåŠŸ
xhr.onabort = handler		//è¯·æ±‚ä¸­æ­¢ï¼ˆä¸»åŠ¨ï¼‰
xhr.onerror = handler		//è¯·æ±‚å¤±è´¥
xhr.onloadend = handler		//è¯·æ±‚ç»“æŸ
xhr.onloadstart = handler	//æ¥æ”¶åˆ°å“åº”æ•°æ®
xhr.onprogress = handler	//è¯·æ±‚è¿›åº¦
xhr.ontimeout = handler		//è¯·æ±‚è¶…æ—¶

xhr.upload.onprogress		//ä¸Šä¼ è¿›åº¦
xhr.upload.onerror			//ä¸Šä¼ é”™è¯¯
xhr.upload.onabort			//ä¸Šä¼ å–æ¶ˆ
xhr.upload.onload			//ä¸Šä¼ æˆåŠŸ
xhr.upload.ontimeout		//ä¸Šä¼ è¶…æ—¶
xhr.upload.onloadstart		//ä¸Šä¼ å¼€å§‹
xhr.upload.loadend			//ä¸Šä¼ ç»“æŸ
xhr.timeout = num
xhr.withCredentials
xhr.getAllResponseHeaders()
xhr.getResponseHeader(key)
```

> ##### ç®€æ˜“å®ç°ä»£ç 
>

```javascript
const xhr = new XMLHttpRequest()
xhr.open('POST', 'http://localhost:3000')
xhr.setRequestHeader('Content-Type', 'application.json')
xhr.timeout = 3000
xhr.withCredentials = true
xhr.onload = () => {
  const {status, responseText, responseType} = xhr
  const data = responseType === 'json' ? {} : JSON.parse(responseText)
  const headers = xhr.getAllResponseHeaders()
  if(status >= 200 && status < 300) {
    console.log({
      data,
      status,
      headers,
      statusText: xhr.statusText,
      request: xhr
    })
  } else {
    console.log({
      data,
      status,
      headers
    })
  }
}
```

> ##### å®Œæ•´å®ç°ä»£ç 
>

```javascript
function http({method = 'GET', url, headers = {}, data = {}, params = {}, timeout, withCredentials, cancelToken}) {
    return new Promise((resolve, reject) => {
        try {
            //é…ç½®è¯·æ±‚æ–¹æ³•
            method = method.toUpperCase();
            //é…ç½®è¯·æ±‚å‚æ•°ï¼Œæ‹¼æ¥åˆ°urlåé¢
            params = qs.stringify(params) //è®¾ç½®è¯·æ±‚å‚æ•°
            url = `${url}${params.length ? `${params}` : ''}`

            //åˆ¤æ–­è¯·æ±‚ç±»å‹
            if (headers['Content-Type']?.includes('application/json')) { //æ ¹æ®è®¾ç½®çš„Content-Typeæ ¼å¼åŒ–è¯·æ±‚ä½“æ•°æ®
                headers['Content-Type'] = 'application/json'
                data = JSON.stringify(data)
            } else if (headers['Content-Type']?.includes('application/x-www-form-urlencoded')) {
                headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8'
                data = qs.stringify(data)
            } else {
                headers['Content-Type'] = 'text/plain'
            }

            //åˆ›å»ºè¯·æ±‚
            const xhr = new XMLHttpRequest()

            //é…ç½®è¯·æ±‚ä¸­æ­¢çš„å¯¹è±¡
            if (cancelToken && (cancelToken !== 'object' || cancelToken === null)) return console.log(`cancelToken must be a object`)
            //ç»™äºˆä¸­æ­¢è¯·æ±‚æ§åˆ¶æƒ
            void cancelToken && (cancelToken.cancel = xhr.abort)

            //å¼€å¯xhrè¯·æ±‚
            xhr.open(method, url)

            //è®¾ç½®æ˜¯å¦æºå¸¦cookie
            xhr.withCredentials = withCredentials
            
            //è®¾ç½®è¯·æ±‚å¤´
            headers.forEach((k, v) => xhr.setRequestHeader(k, v))

            /*
            * è®¾ç½®xhräº‹ä»¶å¤„ç†å‡½æ•°ï¼Œå¤„ç†å¯¹åº”çš„PromiseçŠ¶æ€
            * */

            //è®¾ç½®è¶…æ—¶æ—¶é—´å’Œå¤„ç†å‡½æ•°
            xhr.timeout = timeout
            xhr.ontimeout = () => {
                reject('timout')
            }

            //è®¾ç½®è¯·æ±‚ä¸­æ–­å¤„ç†å‡½æ•°
            xhr.onabort = () => {
                reject('abort')
            }

            //å¤„ç†è¯·æ±‚é”™è¯¯
            xhr.onerror = () => {
                reject('error')
            }

            //å¤„ç†è¯·æ±‚æˆåŠŸ
            xhr.onload = () => {
                const {status, responseText} = xhr
                const headers = xhr.getAllResponseHeaders()
                if (status >= 200 && status < 300) {
                    resolve({
                        data: JSON.parse(responseText),
                        status,
                        statusText: this.statusText,
                        headers
                    })
                } else {
                    reject({
                        data: JSON.stringify(responseText),
                        status,
                        headers
                    })
                }
            }

            //æ ¹æ®è¯·æ±‚æ–¹æ³•å†³å®šæ˜¯å¦å‘é€è¯·æ±‚ä½“
            if (method === 'GET' || method === 'DELETE' || method === 'OPTIONS' || method === 'HEAD') {
                xhr.send()
            } else {
                xhr.send(data)
            }

        } catch (e) {
            reject(e)
        }
    })
}
```

> ##### ä¼˜åŒ–ç©ºé—´
>

[å‚è€ƒï¼šå®ç°`axios`æ‹¦æˆªå™¨çš„æ€è·¯](https://segmentfault.com/q/1010000020521552)

- è¿›ä¸€æ­¥æ ¡éªŒè¯·æ±‚æ–¹æ³•`method`çš„åˆæ³•æ€§ã€‚
- å¯ä»¥åˆ©ç”¨`Promise`è¿›ä¸€æ­¥æ·»åŠ æ‹¦æˆªå™¨ï¼ˆåˆ›å»ºä¸€ä¸ª`Promise.resolve`ç”¨ä»¥ç»™æ‹¦æˆªå™¨æä¾›å¤„ç†æœºä¼šï¼Œç»´æŠ¤ä¸€ä¸ª`interceptor`å¯¹è±¡ï¼Œé‡Œé¢çš„å±æ€§æœ‰`request`å’Œ`response`ï¼Œå…¶ä¸­`request`ä¸­å­˜çš„æ˜¯`ajax`è¯·æ±‚çš„å¤„ç†å‡½æ•°`(resolve, reject)`ï¼Œ`response`å­˜å‚¨çš„æ˜¯`ajax`ç›¸åº”çš„å¤„ç†å‡½æ•°`(resolve, reject)`ï¼‰ã€‚
- ä¸°å¯Œè¯·æ±‚æ•°æ®ç±»å‹çš„åˆ¤æ–­ï¼Œæ¨¡ä»¿`axios`å®ç°å¯¹`data`ç±»å‹çš„è‡ªåŠ¨åˆ¤æ–­è€Œéä¾èµ–`Content-Type`ã€‚
- ä¼˜åŒ–é”™è¯¯å¤„ç†ã€‚
- ä¼˜åŒ–é»˜è®¤å€¼ã€‚
- æ ¹æ®`xhr.responseType`è‡ªåŠ¨åŒ–å¤„ç†åç«¯è¿”å›å†…å®¹ã€‚

## 12.åŒå‘æ•°æ®ç»‘å®šâˆš

```javascript
function v_model(tar, property, node) {
    Object.defineProperty(tar, property, {
        enumerable: true,
        configurable: true,
        get() {
            console.log('rendering')
        },
        set(newVal) {
            console.log('update')
            node.value = newVal
        }
    })
    node.addEventListener('keyup', () => {
        tar[property] = node.value
    })
}
```

## 13.æ‰‹å†™æ•°ç»„æ•°ç»„å»é‡âˆš

[JavaScript æ•°ç»„é«˜æ€§èƒ½å»é‡ åƒä¸‡çº§æ•°æ®å»é‡æ•ˆç‡æµ‹è¯• é«˜æ•ˆå»é‡è¯¦è§£](https://blog.csdn.net/rudy_zhou/article/details/103971730)

[jsä¸–ç•Œ-æ•°ç»„å»é‡åˆ°åº•æœ€å¿«çš„æ˜¯è°ï¼Ÿ](https://zhuanlan.zhihu.com/p/93791402)

> `æ™®é€šç‰ˆ`

```javascript
const filter = iterator => {
    //æ–¹å¼ä¸€ï¼Œå†…å±‚å¾ªç¯ä½¿ç”¨includesï¼Œæ•ˆç‡å¥½ï¼ˆ100000,19999 -> 3208msï¼‰
    //const has = arr.includes(tar) 

    //æ–¹å¼äºŒï¼ŒåŒé‡forå¾ªç¯ï¼Œæ•ˆç‡å·®ï¼ˆ100000,19999 -> 9475msï¼‰
    const has = (arr, tar) => {
        for (let i = arr.length; i--;) {
            if (Object.is(arr[i], tar)) return true
        }
    }

    iterator = Array.from(iterator)
    const tar = []

    for (let i = 0; i < iterator.length; i++) {
        if (!has(tar, iterator[i])) tar.push(iterator[i])
    }
    return tar
}
```

> `ES6`

```javascript
//æ–¹å¼ä¸‰ï¼Œreduce
const filter = iterator =>
Array
.from(iterator)
.reduce((pre, cur) => pre.includes(cur) ? pre : pre.concat(cur), [])

//æ–¹å¼å››ï¼Œfilterï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯é”™çš„ï¼Œå› ä¸ºindexOf()ä½¿ç”¨äº†ä¸¥æ ¼ç›¸ç­‰æ¯”è¾ƒç¬¦
//æ•ˆç‡ä¸€èˆ¬ï¼ˆ100000,19999 -> 3493msï¼‰
const filter = arr =>
arr
.filter((value, index) => arr.indexOf(value) === index)
```

> `sort first`

```javascript
const filter = iterator => {
    const tar = []
    iterator = Array.from(iterator).sort((a, b) => a - b)

    //æ–¹å¼äº”ï¼Œsort + reduce æ•ˆç‡å¥½ï¼ˆ100000,19999 -> 39msï¼‰
    //    iterator.reduce((prev, cur) => {
    //        if (!Object.is(cur, prev)) tar.push(cur)
    //        return cur
    //    }, Symbol('initialValue'))

    //æ–¹å¼å…­ sort + for æ•ˆç‡å¥½ï¼ˆ100000,19999 -> 38msï¼‰
    tar.push(iterator[0])
    for (let i = 0; i < iterator.length; i++) {
        if(!Object.is(iterator[i], iterator[i + 1])) tar.push(iterator[i + 1])
    }
    return tar
}
```

> `Map` `Set`

```js
//æ•ˆç‡æ— æ•Œï¼Œæœ€ç®€æ´ï¼ˆ100000,19999 -> 155msï¼‰
new Set([...iterator]).values()
```

## 14.æ‰‹å†™`setTimeout`è½®è¯¢âˆš

```javascript
function __setInterval__(fn, delay, ...args) {
    const _this = this
    let timer
    const _run = () => setTimeout(async function __self__() {
        const ret = await fn.call(_this, ...args)
        console.log(ret)
        timer = setTimeout(__self__, delay)
    }, delay)
    timer = _run()
    return {
        terminate: () => void (clearTimeout(timer) || (timer = null)),
        pause: () => clearTimeout(timer),
        run: () => timer = _run()
    }
}
```

## 15.æ‰‹å†™`async`ã€`await`ï¼ˆå®ç°`co`ï¼‰âˆš

```javascript
//å‡½æ•°å®ç°
const co = (gen, ...argsOfGen) => {
    const ctx = this
    return new Promise((resolve, reject) => {
        if(typeof gen === 'function') gen = gen.call(ctx, ...argsOfGen)
        if(!gen || typeof gen.next !== 'function') return resolve(gen)

        const onFullfilled = (data) => {
            let ret
            try {
                ret = gen.next(data)
            } catch(e) {
                reject(e)
            }
            return next(ret)
        }

        const onRejected = (reason) => {
            let ret
            try {
                ret = gen.throw(reason)
            } catch(e) {
                reject(e)
            }
            return next(ret)
        }

        const next = (ret) => {
            if(ret.done) return resolve(ret.value)
            if(typeof ret.value.then === 'function') return ret.value.then(onFullfilled, onRejected)
            return reject(new TypeError('only support yield Promise'))
        }
        onFullfilled()
    })
}
```

```javascript
//æµ‹è¯•
function* gen() {
    let a = yield new Promise((res) => {
        setTimeout(() => {
            res(1)
        }, 1000)
    })
    console.log(a)
    let b = yield new Promise((res) => {
        setTimeout(() => {
            res(2)
        }, 2000)
    })
    console.log(b)
}
co(gen)
```

## 17.`rem`æ‰‹å†™å®ç°âˆš

```javascript
import debounce from './debounce'
const remSet = (baseSize) => {
    const html = document.documentElement
    const {width} = html.getBoundingClientRect()
    const rem = width / baseSize
    html.style.fontSize = `${rem}px`
}
debounce(addEventListener, 50)("resize", remSet)
```

## 18.æ‰‹å†™`flat`å®ç°âˆš

```javascript
//ES6
const flat =
    (arr, dep = Infinity) =>
        Array.isArray(arr) && arr.reduce((prev, cur) =>
                Array.isArray(cur) && dep > 0 ?
                    [...prev, ...flat(cur, dep - 1)] : [...prev, cur], [])
console.log(flat([1, 2, [3, [4]]], 1))
```

```javascript
//Generator
const flatGen = function* (arr, dep) {
    if (dep < 0) {
        yield arr
    } else {
        let {length} = arr
        for (let i = 0; i < length; i++) {
            const item = arr[i]
            if (Array.isArray(item)) {
                yield* flatGen(item, dep - 1)
            } else {
                yield item
            }
        }
    }
}
console.log([...flatGen([1, 2, [3, [4]]], 1)])
```

```js
//éé€’å½’ç‰ˆæœ¬
const flat = function (arr) {
    const queue = [...arr]
    const res = []
    while (queue.length) {
        const cur = queue.shift()
        if (Array.isArray(cur)) {
            queue.unshift(...cur)
        } else {
            res.push(cur)
        }
    }
    return res
}
```



## 19.æ‰‹å†™ç®€å•è·¯ç”±âˆš

```javascript
// ç®€æ˜“è·¯ç”±å®ç°çš„åŠŸèƒ½ï¼Œæ ¹æ®è·¯ç”±è°ƒç”¨å›è°ƒå‡½æ•°ï¼Œè¿›è¡Œé¡µé¢çš„å˜åŒ–
class Router {
    routes = new Map()
    currentHash = ''

    constructor() {
        this.freshRoute = this.freshRoute.bind(this);
        window.addEventListener('load', this.freshRoute, false);
        window.addEventListener('hashchange', this.freshRoute, false);
    }

    storeRoute(path, cb) {
        this.routes.set(path, cb || (function () {}));
    }

    freshRoute() {
        const routes = this.routes
        this.currentHash = location.hash.slice(1) || '/';
        routes.has(this.currentHash) && routes.get(this.currentHash)();
    }
}

```

## 20.æ‰‹å†™æ—¥æœŸå¤„ç†âˆš

```javascript
Date.prototype.format = function(fmt) {
     var regOptions = {
        "Y{4}" : this.getFullYear(),						//å¹´ä»½ 
        "q{1}" : Math.floor((this.getMonth() + 3) / 3), 	//å­£åº¦
        "M{2}" : this.getMonth() + 1,   					//æœˆä»½
        "d{2}" : this.getDate(),          					//æ—¥ 
        "h{2}" : this.getHours(),         					//å°æ—¶ 
        "m{2}" : this.getMinutes(),       					//åˆ† 
        "s{2}" : this.getSeconds(),       					//ç§’  
        "S{3}"  : this.getMilliseconds()   					//æ¯«ç§’ 
    }; 
    Object.keys(regOptions).forEach((reg)=>{
        fmt = fmt.replaceAll(new RegExp(`(?:${reg})`, 'g'), regOptions[reg])
    })
    return fmt;
}       

new Date().format("ç°åœ¨æ˜¯åŒ—äº¬æ—¶é—´YYYYå¹´MMæœˆddæ—¥ï¼Œhhæ—¶mmåˆ†ssç§’, ç¬¬qå­£åº¦");
```

## 21.æ‰‹å†™å­—ç¬¦ä¸²æ¨¡æ¿âˆš

```javascript
//éå¸¸ç®€å•çš„æ›¿æ¢
const beard = (str, obj) => {
    let ret
    const arr = []
    let regex = new RegExp(/\${\s*(?<prop>\w+)\s*}/, 'g')
    regex = new RegExp(regex, '')
    arr.reverse()	//ä»å­—ç¬¦ä¸²å³ä¾§å¼€å§‹æ›¿æ¢ï¼Œä¸ä¼šå½±å“å­—ç¬¦ä¸²å·¦ä¾§ç´¢å¼•
        .forEach(({1: prop, index: startIndex, 0: matched}) => {
        str = str.slice(0, startIndex) 
            	+ obj[prop] 
            	+ str.slice(startIndex + matched.length)
    })
    return str
}
console.log(beard('My name is ${ name }, My age is ${ age }', {
    name: 'ycp',
    age: 21
}))
function render(template, context) {
    const _fn = new Function("context", `
    const arr = [];
    with(context){
      arr.push('${
        template
            .replace(/{{(.*?)}}/g, "',$1,'") // å°† å˜é‡}} æ›¿æ¢æˆ ,å˜é‡,
    }')
      return arr.join('')
    }
  `);
    return _fn(context);
}

console.log(render(
    '{{company}}---{{group.name}}---{{group.jobs[0]}}---{{group["jobs"][1]}}',
    {
        group: {
            name: "å¤©çŒ«",
            jobs: ["å‰ç«¯", "åç«¯", "äº§å“"]
        },
        company: 'é˜¿é‡Œå·´å·´'
    }
))
```

## 22.åŠ¨æ€å‘½åç©ºé—´ç®¡ç†å™¨ Ã—

```javascript
const useNamespace = () => {
	const MyApp = {}
	MyApp.namespace = (name) => {
        const parts = name.split('.')
        let current = MyApp
        for(let part in parts) {
            if(!current[part]) {
                current[part] = {}
            }
            current = current[part]
        }
    }
    return MyApp.namespace
}
const namespace = useNamespace
namespace('name')
namespace('name.lastname')

```

## 23.æ‰‹å†™è´å¡å°”æ›²çº¿Ã—

[å‚è€ƒ](https://juejin.cn/post/6844903666361565191)

> ### né˜¶è´å¡å°”æ›²çº¿å…¬å¼

![B(t) = \sum_{i=0}^{n}C_n^{i}P_i(1-t)^{n-i}t^i,t\in[0,1]](https://juejin.cn/equation?tex=B(t)%20%3D%20%5Csum_%7Bi%3D0%7D%5E%7Bn%7DC_n%5E%7Bi%7DP_i(1-t)%5E%7Bn-i%7Dt%5Ei%2Ct%5Cin%5B0%2C1%5D)

> ### ä¸‰é˜¶è´å¡å°”æ›²çº¿å…¬å¼

$$
ï…•{B}_{3}(t)\, =\, {(1-t)}^{3}{P}_{0}+3t{(1-t)}^{2}{P}_{1}+3{t}^{2}{(1-t)}{P}_{1}+{t}^{3}{P}_{2},\, t\in [0,\, 1]
$$

> ### é”šå®šèµ·ç‚¹`[0, 0]`å’Œç»ˆç‚¹`[1, 1]`çš„ä¸‰é˜¶è´å¡å°”

![B_{3, x}(t) = 3t(1 - t)^2x_1 + 3t^2(1 - t)x_2 + t^3 , t\in[0, 1]](https://juejin.cn/equation?tex=B_%7B3%2C%20x%7D(t)%20%3D%203t(1%20-%20t)%5E2x_1%20%2B%203t%5E2(1%20-%20t)x_2%20%2B%20t%5E3%20%2C%20t%5Cin%5B0%2C%201%5D)

![B_{3, y}(t) = 3t(1 - t)^2y_1 + 3t^2(1 - t)y_2 + t^3 , t\in[0, 1]](https://juejin.cn/equation?tex=B_%7B3%2C%20y%7D(t)%20%3D%203t(1%20-%20t)%5E2y_1%20%2B%203t%5E2(1%20-%20t)y_2%20%2B%20t%5E3%20%2C%20t%5Cin%5B0%2C%201%5D)

```javascript
class Bezier {
	constructor([[x1, y1], [x2, y2]] = [[0, 0], [0, 0]], precision = 100) {
		this.controlPoints = [[x1, y1], [x2, y2]]
        this.precision = precision
	}
    
	calcCoord(t) {
		if(t > 1|| t < 0) return 
        const _t = 1 - t
        const [[x1, y1], [x2, y2]] = this.controlPoints
		const px = t * (3 * (1 - t) * (_t * x1 + t * x2) + t * t)
        const py = t * (3 * (1 - t) * (_t * y1 + t * y2) + t * t)
        // ç»“æœåªä¿ç•™ä¸‰ä½æœ‰æ•ˆæ•°å­—
        return [parseFloat(px.toFixed(3)), parseFloat(py.toFixed(3))]
    }
    
    updatePrecision(precision) {
        this.precision = precision
        if(this.coords) this.updateCoordsArray()
    }
    
    updateControlPoints([[x1, y1], [x2, y2]]) {
        this.controlPoints = [[x1, y1], [x2, y2]]
        if(this.coords) this.updateCoordsArray()
    }
    
    updateCoordsArray() {
        const {precision} = this
        const step = 1 / (precision + 1);
        const result = [];
        for (let t = 0; t <= precision + 1; t++) {
            result.push(this.calcCoord(t * step));
        }
        this.coords = result;
    }
    
    getCoords() {
        if(!this.coords) this.updateCoordsArray() 
        return this.coords
    }
    
    calcAxis(x) {
        if (x >= 1) return 1;
        if (x <= 0) return 0;
        let startX = 0;
        for (let i = 0; i < this.coords.length; i++) {
            if (this.coords[i][0] >= x) {
                startX = i;
                break;
            }
        }
        const axis1 = this.coords[startX];
        const axis2 = this.coords[startX - 1];
        const k = (axis2[1] - axis1[1]) / (axis2[0] - axis1[0]);
        const b = axis1[1] - k * axis1[0];
        // ç»“æœä¹Ÿåªä¿ç•™ä¸‰ä½æœ‰æ•ˆæ•°å­—
        return parseFloat((k * x + b).toFixed(3));
    }

}
```

## 24.æ‰‹å†™`Object.assign()`âˆš

```javascript
//Object.assign()å®ç°æ ¸å¿ƒåŠŸèƒ½ç‚¹ï¼Œå°†åç»§å¯¹è±¡çš„ï¼ˆè‡ªèº«å¯æšä¸¾å±æ€§ï¼‰è¿½åŠ åˆ°æºå¯¹è±¡ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°ï¼‰
Object.prototype.__assign__ = (target, ...args) => {
    //nullå’Œundfinedä¼šæŠ¥é”™
    if(typeof target === null || typeof target === undefined) throw new TypeError('Cannot convert undefined or null to object at Function.assign')
    //åŸºæœ¬ç±»å‹è¿›è¡ŒåŒ…è£…
    if(!(target instanceof Object)) return Object(target)
    args.forEach(obj => {
        Object
            .keys(obj).concat(Object.getOwnPropertySymbols(obj))
            .forEach((key) => void (target[key] = obj[key]))
    })
}

//æµ‹è¯•
let obj = {}
let test = {
    [Symbol()]: 'symbol1',
    name: 'ycp',
    [Symbol()]: 'symbol2'
}
Object.defineProperty(test, 'hidden', {
    enumerable: false
})
Object.__assign__(obj, test)
Object.__assign__(obj, {
    name: 'other'
})
console.log(obj)

```

## 25.æ‰‹å†™`class`æ··å…¥Ã—

```javascript
function mix(...mixins) {
    class Mix {
        constructor() {
            mixins.forEach(mixin => {
                //ç›—ç”¨å®ä¾‹å±æ€§
                copyProperties(this, new mixin())
            })
        }
    }

    const copyProperties = (target, source) => {
        for (let key of Reflect.ownKeys(source)) {
            if (key !== 'constructor'/*å‰”é™¤åŸå‹ä¸Šçš„constructor*/
                && key !== 'prototype' /*å‰”é™¤ç±»ä¸Šçš„prototypeå±æ€§*/
                && key !== 'name'/*å‰”é™¤ç±»çš„åå­—*/) {
                const desc = Object.getOwnPropertyDescriptor(source, key)
                Object.defineProperty(target, key, desc)
            }
        }
    }
    
    mixins.forEach(mixin => {
        //å¤åˆ¶é™æ€å±æ€§
        copyProperties(Mix, mixin)
        //å¤åˆ¶åŸå‹å±æ€§
        copyProperties(Mix.prototype, mixin.prototype)
    })
    
    return Mix
}
```

## 26.æ‰‹å†™æœ‰å¹¶è¡Œé™åˆ¶çš„`Promise`âˆš

```javascript
class PromiseSchedule {
    maxTask = 2
    runningTask = 0
    queue = new Set()

    constructor(maxTask) {
        this.maxTask = maxTask
    }

    add(PromiseProducer, onFulfilled = (() => {
    }), onRejected = (() => {
    })) {
        const proxyPromiseProducer = () => {
            this.runningTask += 1
            this.queue.delete(proxyPromiseProducer)
            PromiseProducer().then(onFulfilled, onRejected).finally(() => {
                this.runningTask -= 1
                this.run()
            })
        }
        this.queue.add(proxyPromiseProducer)
    }

    canRun() {
        return !(this.queue.size === 0 || this.maxTask - this.runningTask <= 0)
    }

    run() {
        if (!this.canRun()) return
        while (this.runningTask < this.maxTask) {
            [...this.queue.values()][0]()
        }
    }
}

const pp = () => new Promise((resolved, rejected) => {
    setTimeout(() => {
        resolved('ycp')
    }, 1000)
})

const fullfilled = value => {
    console.log(value)
}
const rejected = reason => {
    console.log(reason)
}

let ps = new PromiseSchedule(4)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.run()
```

## 27.æ‰‹å†™ç®€æ˜“çš„æœ‰é™çŠ¶æ€æœºÃ—

[ğŸ”—æ¨¡ä»¿javascript-state-machineåº“](https://github.com/jakesgordon/javascript-state-machine)

```javascript
class StateMachine {
    constructor({init, transitions = [], methods}) {
        Object.defineProperties(this, {
            state: {
                enumerable: false,
                get() {
                    return this.__state__
                }
            },
            __state__: {
                writable: true,
                value: init
            },
            __transitions__: {
                value: transitions,
                writable: true
            },
            states: {
                value: transitions.reduce((prev, {from, to}) => {    //ä¿å­˜æ‰€æœ‰çŠ¶æ€
                    if (!prev.includes(from)) prev.push(from)
                    if (!prev.includes(to)) prev.push(to)
                    return prev
                }, []),
                writable: true
            },
            methods: {
                value: methods,
                writable: true
            }
        })  //è®¾ç½®è®¿é—®æƒé™ï¼Œé˜²æ­¢ç¯¡æ”¹
        this.bindMethods(methods) //æ ¹æ®methodsç»‘å®šçŠ¶æ€è½¬ç§»è§¦å‘å‡½æ•°
    }

    //ä¹Ÿå¯ä»¥é€šè¿‡Proxyç»™çŠ¶æ€ç»‘å®šå¤„ç†å‡½æ•°ï¼ˆonLeaveã€onEnterï¼‰

    //è¿™é‡Œç»™çŠ¶æ€çš„åˆ‡æ¢çŠ¶æ€äº‹ä»¶æœ¬èº«ç»‘å®šäº†å‡½æ•°
    bindMethods(methods) {
        const instance = this
        return Object.entries(methods).forEach(([name, callback]) => {
            const {from, to} = instance.getTransition(name)
            if (from === undefined || to === undefined) return
            //è¿™é‡Œé»˜è®¤çŠ¶æ€åˆ‡æ¢ä¹‹åæ‰§è¡ŒåŒåçŠ¶æ€å›è°ƒï¼Œå…¶å®å¯ä»¥åˆ©ç”¨AOPè¿›ä¸€æ­¥ä¼˜åŒ–è¿™ä¸ªå‡½æ•°ï¼Œæ”¯æŒï¼ˆonBeforeã€onAfterï¼‰
            instance[name] = function (...argsFroEventSelf) {
                if (from === instance.state) {
                    instance.changeState(to)
                    return callback.call(instance, ...argsFroEventSelf)
                }
                return instance.error(instance.state, to)
            }
        })
    }

    getTransition(name) {
        return this.__transitions__.find(({name: _name}) => _name === name)
    }

    changeState(to) {
        return this.__state__ = to
    }

    //ä»¥ä¸‹æ˜¯å¯¹å¤–æš´éœ²çš„api

    is(state) {
        return this.state === state
    }

    can(to) {
        return this.transitions(to).some(({to: _to}) => _to === to)
    }

    cannot(to) {
        return !this.can(to)
    }

    transitions() {     //å…è®¸çš„çŠ¶æ€è½¬ç§»
        const from = this.state
        return this.__transitions__.filter(({from: _from}) => from === _from)
    }

    allTransitions() {
        return this.__transitions__
    }

    allStates() {
        return this.states
    }

    error(from, to) {
        throw new Error(`from ${from} to ${to} is not defined!`)
    }


}

// *ä¼˜åŒ–ç©ºé—´ï¼š
// *1.åˆ©ç”¨AOPæ ¹æ®ä¼ å…¥çš„methodsæ¥ä¿®é¥°çŠ¶æ€åˆ‡æ¢å‡½æ•°ï¼ˆonBeforeTransition -> onAfterTransition -> çŠ¶æ€ä¿®æ”¹ -> onmTransitionï¼‰
// *2.åˆ©ç”¨ä»£ç†Proxyç»™çŠ¶æ€æ·»åŠ æ‹¦æˆªå™¨ï¼Œæ£€æµ‹çŠ¶æ€å˜æ›´çš„æ—¶å€™æ‰§è¡Œç›¸åº”çš„å‡½æ•°ï¼Œä¾‹å¦‚ï¼ˆå›ºæ€ -> æ¶²æ€ï¼Œä¼šè§¦å‘ï¼šonLeaveStateã€onEnterStateï¼‰
// *3.ä¼ å…¥å‚æ•°çš„æ ¡éªŒ
// *4.å®ç°å¼‚æ­¥çš„æ”¯æŒ

const stateMachine = new StateMachine({
    init: "å›ºæ€",
    transitions: [
        {name: "melt", from: "å›ºæ€", to: "æ¶²æ€"},
        {name: "freeze", from: "æ¶²æ€", to: "å›ºæ€"},
        {name: "vaporize", from: "æ¶²æ€", to: "æ°”æ€"},
        {name: "condense", from: "æ°”æ€", to: "æ¶²æ€"},
        {name: "sublimation", from: "å›ºæ€", to: "æ°”æ€"},
        {name: "condensate", from: "æ°”æ€", to: "å›ºæ€"}
    ],
    methods: {
        melt: function () {
            console.log("I melted");
        },
        freeze: function () {
            console.log("I froze");
        },
        vaporize: function () {
            console.log("I vaporized");
        },
        condense: function () {
            console.log("I condensed");
        },
        sublimation: function () {
            console.log("I sublimated");
        },
        condensate: function () {
            console.log("I condensate");
        }
    }
})
console.log(stateMachine.state)
stateMachine.melt()
console.log(stateMachine.state)
stateMachine.freeze()
console.log(stateMachine.state)

```

## 28.æ‰‹å†™å®ç°`JSAOP`âˆš

```javascript
//æ±¡æŸ“å…¨å±€çš„æ–¹å¼
Function.prototype.after = function(afterFunc) {
    const self = this
    return function(...args) {
        self.call(this, ...args)
        afterFunc.call(this, ...args)
    }
}
Function.prototype.before = function(beforeFunc) {
    const self = this
    return function(...args) {
        beforeFunc.call(this, ...args)
        self.call(this, ...args)
    }
}
Function.prototype.between = function(betweenFunc) {
    const self = this
    return function(...args) {
        betweenFunc.call(this, ...args)
        self.call(this, ...args)
        betweenFunc.call(this, ...args)
    }
}
Function.prototype.error = function(errorFunc) {
    const self = this
    return function(...args) {
        try {
            self.call(this, ...args)   
        } catch(e) {
            console.log(e)
            errorFunc.call(this, ...args)
        }
    }
}
Function.prototype.noerror = function(noerrorFunc) {
    const self = this
    return function(...args) {
        const noerror = true
        try {
            self.call(this, ...args)   
        } catch(flag) {
            noerror = false
        } finally {
            if(noerror) noerrorFunc.call('')
        }
    }
}
//ä¼ é€’å‚æ•°
Function.prototype.after = function(afterFunc) {
    const self = this
    return function(...args) {
        self.call(this, ...args)
        afterFunc.call(this, ...args)
    }
}
const logic1 = function(params) {
    params.name = 'ycp'
}
const logic2 = function(params) {
    console.log(params.name)
}
logic1.after(logic2)({})
```

```javascript
//ä¸æ±¡æŸ“å…¨å±€çš„æ–¹å¼
function after(origin, afterFunc) {
    return function(...args) {
        origin.call(this, ...args)
        afterFunc(this, ...args)
    }
}
const logic1 = function(params) {
    params.name = 'ycp'
}
const logic2 = function(params) {
    console.log(params.name)
}
after(logic1, logic2)({})

function afterChain(origin, ...fns) {
    if(fns.length === 0) return origin
    const popFn = fns.shift()
    const modifiedFn = function(...args) {
        origin.call(this, ...args)
        popFn.call(this, ...args)
    }
    return afterChain(modifiedFn, ...fns)
}
const logic1 = function(params) {
    console.log(1)
}
const logic2 = function(params) {
    console.log(2)
}
const logic3 = function(params) {
    console.log(3)
}
afterChain(logic1, logic2, logic3)()
```

## 29.ä½¿ç”¨`generator`æ‰‹å†™ä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨çŠ¶æ€æœºÃ—

```javascript
const calcStrategies = {
    '+': function (init, opValue) {
        return init + opValue
    },
    '-': function (init, opValue) {
        return init - opValue
    },
    'x': function (init, opValue) {
        return init * opValue
    },
    '/': function (init, opValue) {
        return init / opValue
    }
}

function* calc() {
    let value = null
    //const numbers = []
    const symbols = []
    let state = 'init'
    while (true) {
        const input = yield value
        if (state === 'init' && typeof input === 'number') {
            //numbers.push(input)
            value = input
            state = 'waitingSymbol'
        }
        if (state === 'waitingSymbol' && calcStrategies[input] !== undefined) {
            symbols.push(input)
            state = 'waitingNumber'
        }
        if (state === 'waitingNumber' && typeof input === 'number') {
            //numbers.push(input)
            value = calcStrategies[symbols.slice(-1)](value, input)
            state = 'waitingSymbol'
        }
        if (input === 'reset') {
            //numbers.splice(0)
            symbols.splice(0)
            state = 'waitingNumber'
        }
    }
}

const iter = calc()
let equation = ''
const executeNext = (value) => {
    console.log(equation)
    console.log(iter.next(value))
    return executeNext
}
executeNext()(1)('+')(2)('-')(1)('/')(0.5)
```

## 30.æ‰‹å†™äº‹ä»¶å§”æ‰˜âˆš

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <ul>
            <li id="1">
                <h1>Title</h1>
                <div>Content</div>
            </li>
            <li id="2">
                <h1>Title</h1>
                <div>Content</div>
            </li>
            <li id="3">
                <h1>Title</h1>
                <div>Content</div>
            </li>
        </ul>
        <script>
            const ul = document.querySelector('ul')
            ul.onclick = e => {
                //å®é™…è§¦å‘äº‹ä»¶çš„DOMå…ƒç´ 
                const trigger = e.target
                //æˆ‘ä»¬å¸Œæœ›å§”æ‰˜çš„å…·ä½“ç›®æ ‡DOMå…ƒç´ 
                const targetEle = e.target.closest('li')
                console.log(trigger)
                console.log(targetEle.id)
            }
        </script>
    </body>
</html>
```



## 31.ä½¿ç”¨`DFS`æ ¹æ®æ•°æ®åˆ›å»º`DOM`âˆš

```javascript
const data = [
    {
        title: 'a', id: 1,
        children: [{
            title: 'b', id: 2, children: [{
                title: 'b1', id: 5
            }, {
                title: 'b2', id: 6
            }]
        }, {
            title: 'c', id: 3
        }]
    },
    {
        title: 'd', id: 4,
        children: [{
            title: 'e', id: 5
        }, {
            title: 'f', id: 6
        }]
    }
];
```

```javascript
function dfsCreateDOM(nsData) {
    const fragment = document.createDocumentFragment()
    nsData.forEach(nData => {
        const div = document.createElement('div')
        div.setAttribute('title', nData.title)
        if (nData.children && nData.children.length) 			div.appendChild(dfsJSX(nData.children))
        fragment.appendChild(div)
    })
    return fragment
}
const fragment = dfsCreateDOM(data)
console.log(fragment)
```

## 32.ä½¿ç”¨æ·±åº¦ä¼˜å…ˆéå†éå†`DOM`æ ‘âˆš

```javascript
//é€’å½’æ³•
function dfsRecursion(node) {
  let ret = []
  if (!node) return []
  ret.push(node)
  const {children} = node
  if (children?.length) {
    Array.from(children).forEach(node => {
      ret.push(...dfsRecursion(node))
    })
  }
  return ret
}
//éé€’å½’æ³•
function dfs(root) {
  const ret = []
  const inner = node => {
    const {children} = node
    ret.push(node)
    if (children.length) [...children].forEach(inner)
  }
  inner(root)
  return ret
}
```

## 33.ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†éå†`DOM`æ ‘âˆš

```javascript
//éé€’å½’ç‰ˆæœ¬
function bfs(root) {
    const queue = [root];
    let pointer = 0;
    const ret = [];
    while (pointer < queue.length) {
        const dom = queue[pointer++];
        ret.push(dom);
        if (dom.children.length) queue.push(...dom.children);
    }
    return ret;
}

//é€’å½’ç‰ˆæœ¬
function bfsRecursion(root) {
    const queue = [root];
    const ret = [];
    let pointer = 0;
    const bfs = () => {
        const dom = queue[pointer++]
        if (!dom) return
        ret.push(dom)
        if (dom.children.length) queue.push(...dom.children)
        bfs()
    }
    bfs()
    return ret
}
```

## 34.åˆ†ç¦»å°æ•°å’Œæ•´æ•°å¹¶ä¿ç•™æŒ‡å®šä½æ•°çš„å°æ•°âˆš

```js
const splitNumber = (number, fixed) => {
    let trunc = String(Math.trunc(number))
    let fract = (number - trunc).toFixed(fixed).slice(2)
    return [trunc, fract]
}
```

## 35.JSONPâˆš

```js
function jsonp(url, data, callbackName) {
    let {body} = document
    // åˆ›å»ºDOM
    let script = document.createElement('script')
    // æ‹¼æ¥å­—ç¬¦ä¸²
    const params = Object.entries(data)
    const {length} = params
    let tail = ''
    if (length) {
        tail = params.reduce((str, [k, v], index) => {
            let cur = `${encodeURIComponent(k)}=${encodeURIComponent(v)}`
            return index === length - 1 ? str + cur + '&' : str + cur
        }, '?')
    }
    script.setAttribute('src', url + tail)
    // è®¾ç½®å…¨å±€å‡½æ•°
    return new Promise((resolve, reject) => {
        window[callbackName] = (data) => {
            resolve(data)
            body.removeChild(data)
            Reflect.deleteProperty(window, callbackName)
        }
        body.appendChild(script)
    })
}
```

## 36.Arrayä¸Šçš„éå†æ•°ç»„çš„é«˜é˜¶å‡½æ•°å®ç°âˆš

```js
  Array.prototype.__forEach__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        cb.call(thisArg, this[i], i, this)
      } else {
        cb(this[i], i, this)
      }
    }
  }

  let a = [1, 2, 3, 4]
  console.log("a:", a)
  let context = {}
  a.__forEach__((value, index, array) => {
    // console.log(this === context)
    // console.log(value, index, array)
  }, context)
  a.__forEach__(function (value, index, array) {
    // console.log(this === context)
    // console.log(value, index, array)
  }, context)


  Array.prototype.__map__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    const newArr = []
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        newArr[i] = cb.call(thisArg, this[i], i, this)
      } else {
        newArr[i] = cb(this[i], i, this)
      }
    }
    return newArr
  }
  // console.log(a.__map__((x) => x * 2))

  Array.prototype.__some__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return true
      } else {
        if (cb(this[i], i, this)) return true
      }
    }
    return false
  }
  // console.log(a.__some__(x => x === 2))
  // console.log(a.__some__(x => x === 9))


  Array.prototype.__every__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        if (!cb.call(thisArg, this[i], i, this)) return false
      } else {
        if (!cb(this[i], i, this)) return false
      }
    }
    return true
  }

  // console.log(a.__every__(x => x <= 4))
  // console.log(a.__every__(x => x > 5))

  Array.prototype.__filter__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    const newArr = []
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) newArr.push(this[i])
      } else {
        if (cb(this[i], i, this)) newArr.push(this[i])
      }
    }
    return newArr
  }
  // console.log(a.__filter__(x => x >= 2))
  // console.log(a.__filter__(x => x >= 5))

  Array.prototype.__find__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return this[i]
      } else {
        if (cb(this[i], i, this)) return this[i]
      }
    }
    return undefined
  }
  // console.log(a.__find__(x => x >= 3))


  Array.prototype.__findIndex__ = function (cb, thisArg = null) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //åˆ¤æ–­ç±»å‹
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return i
      } else {
        if (cb(this[i], i, this)) return i
      }
    }
    return undefined
  }
  // console.log(a.__findIndex__(x => x >= 3))

  Array.prototype.reduce = function (cb, accumulator) {
    //éå†
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    let i
    if (accumulator === undefined) {
      accumulator = this[0]
      i = 1
    } else {
      i = 0
    }
    for (; i < this.length; i++) {
      accumulator = cb(accumulator, this[i], i, this)
    }
    return accumulator
  }

  console.log(a.reduce((prev, value, index) => prev + value, 0))

```

## 37.è§‚å¯Ÿè€…æ¨¡å¼Ã—

```js
class Subject{
    constructor(name){
        this.name = name
        this.observers = []
        this.state = 'XXXX'
    }
    // è¢«è§‚å¯Ÿè€…è¦æä¾›ä¸€ä¸ªæ¥å—è§‚å¯Ÿè€…çš„æ–¹æ³•
    attach(observer){
        this.observers.push(observer)
    }

    // æ”¹å˜è¢«è§‚å¯Ÿç€çš„çŠ¶æ€
    setState(newState){
        this.state = newState
        this.observers.forEach(o=>{
            o.update(newState)
        })
    }
}

class Observer{
    constructor(name){
        this.name = name
    }

    update(newState){
        console.log(`${this.name}say:${newState}`)
    }
}

// è¢«è§‚å¯Ÿè€… ç¯
let sub = new Subject('ç¯')
let mm = new Observer('å°æ˜')
let jj = new Observer('å°å¥')

// è®¢é˜… è§‚å¯Ÿè€…
sub.attach(mm)
sub.attach(jj)

sub.setState('ç¯äº®äº†æ¥ç”µäº†')
```

## 38.ç»„åˆå‡½æ•°âˆš

```js
function compose(...fns) {
    if (!fn.length) return (v) => v
    if (fn.length === 1) return fn[0]
    return fns.reduce((prev, cur) => ((...args) => prev(cur(...args))))
}
```

## 39.Object.is()âˆš

```js
Object.is = function (x, y) {
  if (x === y) {
      //å¤„ç†+0/-0
    return x !== 0 || 1 / x === 1 / y;
  }
    //å¤„ç†NaN
  return x !== x && y !== y;
}
```

## 40.å­—ç¬¦ä¸²ä¸­å‡ºç°æœ€å¤šæ¬¡çš„å­—ç¬¦å’Œä¸ªæ•°Ã—

```js
let str = "abcabcabcbbccccc";
let num = 0;
let char = '';

 // ä½¿å…¶æŒ‰ç…§ä¸€å®šçš„æ¬¡åºæ’åˆ—
str = str.split('').sort().join('');
// "aaabbbbbcccccccc"

// å®šä¹‰æ­£åˆ™è¡¨è¾¾å¼
let re = /(?<repeat>w)\k<repeat>+/g;
str.replace(re,($0,$1) => {
    if(num < $0.length){
        num = $0.length;
        char = $1;        
    }
});
console.log(`å­—ç¬¦æœ€å¤šçš„æ˜¯${char}ï¼Œå‡ºç°äº†${num}æ¬¡`);
```

## 41.åˆ¤æ–­æ»‘åŠ¨å†…å®¹æ»‘åŠ¨åˆ°äº†åº•éƒ¨Ã—

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #container {
            height: 100px;
            width: 50px;
            border: 2px solid red;
            overflow-y: scroll;
        }
        #son {
            height: 200px;
            background-color: yellow;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="son">
        </div>
    </div>
    <script>
        let container = document.querySelector('#container')
        console.log(container)
        container.addEventListener('scroll', function (event) {
            if (Math.ceil(event.target.scrollTop + event.target.clientHeight) === event.target.scrollHeight) {
                container.children[0].style.backgroundColor = 'green'
            } else {
                container.children[0].style.backgroundColor = 'yellow'
            }
        })
    </script>
</body>
</html>
```

# å¤§æ•°ç›¸åŠ 

```javascript
const bigIntAdd = (a, b) => {
    [a, b] = [[...a], [...b]]
    let [longer, shorter] = [a.length > b.length ? a : b, a.length > b.length ? b : a];
    shorter = [...Array.from({ length: longer.length - shorter.length }).fill('0'), ...shorter];
    return longer.reduceRight(([count, shift], value, index) => {
        const cur = Number(value) + Number(shorter[index]) + (shift ? 1 : 0);
        if (cur >= 10) return [(cur - 10) + count, true]
        return [cur + count, false]
    }, ['', false])[0]
}

// TEST
let bigA = '123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789'
let bigB = '123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789'
let hack = bigIntAdd(bigA, bigB)
let origin = String(BigInt(bigA) + BigInt(bigB))
console.log(hack === origin)
```

```javascript
const bigIntAddBetter = (left, right) => {
    [left, right] = [[...left], [...right]]
    const [leftLen, rightLen] = [left.length, right.length]
    let [longerArr, shorterArr] = [leftLen > rightLen ? left : right, leftLen > rightLen ? right : left];
    shorterArr = [...Array.from({ length: longerArr.length - shorterArr.length }).fill('0'), ...shorterArr];

    let index = longerArr.length - 1;
    let carryFlag = false;
    let sum = '';
    let count = 0
    while (index >= 0) {
        console.log(++count)
        // æ²¡æœ‰è¿›ä½å¹¶ä¸”è®¡ç®—åˆ°äº†ä¸´ç•Œç‚¹
        if (!carryFlag && index < (leftLen - rightLen)) {
            return longerArr.slice(0, index + 1).join('') + sum;
        }
        const [left, right] = [longerArr[index], shorterArr[index]];
        const temp = Number(left) + Number(right) + (carryFlag ? 1 : 0);
        if (temp >= 10) {
            carryFlag = true;
            sum = (temp - 10) + sum;
        } else {
            carryFlag = false;
            sum = temp + sum;
        }
        index--;
    }
    return sum
}

console.log(Number(bigIntAdd('1000000009800', '200')) === 1000000009800 + 200);
```

```javascript
const bigAddWithDecimal = (left, right) => {
    let [leftInt, leftDec = ''] = left.toString().split('.');
    let [rightInt, rightDec = ''] = right.toString().split('.');

    const maxDecimalBit = Math.max(leftDec.length, rightDec.length)
    if (maxDecimalBit === 0) return (BigInt(leftInt) + BigInt(rightInt)).toString()
    leftDec = leftDec.toString().padEnd(maxDecimalBit, '0')
    rightDec = rightDec.toString().padEnd(maxDecimalBit, '0')

    const _leftInt = leftInt + leftDec
    const _rightInt = rightInt + rightDec
    const sum = (BigInt(_leftInt) + BigInt(_rightInt)).toString()
    const twoPart = [sum.slice(0, -maxDecimalBit), sum.slice(-maxDecimalBit)]
    twoPart[0] = twoPart[0].length ? twoPart[0] : '0'
    return twoPart.join('.')
}
```

