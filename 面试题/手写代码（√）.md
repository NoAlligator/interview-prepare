## 1.手写`call`、`apply`、`bind`√

```javascript
//call
Function.prototype.__call__ = function (that, ...args) {
    if (typeof this !== 'function') throw new TypeError('__call__ must be invoked by a function')
    const context = that || window
    const symbol = Symbol()
    context[symbol] = this
    const ret = context[symbol](...args)
    Reflect.deleteProperty(context, symbol)
    return ret
}
//apply
Function.prototype.__apply__ = function (that, args) {
    if (typeof this !== 'function') throw new TypeError('__apply__ must be invoked by a function')
    const context = that || window
    const symbol = Symbol()
    context[symbol] = this
    const ret = context[symbol](...args)
    Reflect.deleteProperty(context, symbol)
    return ret
}
```

```javascript
//bind
Function.prototype.__bind__ = function (that, args) {
    if (typeof this !== 'function') throw new TypeError('__bind__ must be invoked by a function')
    const _this = this
    return function (...argsNew) {
        if (this instanceof Function) {
            return new _this(...args, ...argsNew)
        } else {
            return _this.apply(that, [...args, ...argsNew])
        }
    }
}

//正确版本
Function.prototype.__bind__ = function (context = window, ...args_front) {
    if (typeof this !== 'function') throw new TypeError('You can not use call() at a non-function')
    const fSelf = this
    const fEmpty = function () {
    }
    const fBound = function (...args_back) {
        if (this instanceof fEmpty) {
            Object.setPrototypeOf(this, fSelf.prototype)
            return fSelf.apply(this, ...args_front.concat(args_back))
        }
        return fSelf.apply(context, ...args_front.concat(args_back))
    }
    fEmpty.prototype = fSelf.prototype
    fBound.prototype = new fEmpty()
    return fBound
}

//测试
function A(name, age) {
    console.log(name)
    console.log(age)
    console.log(this)
}
let obj = {
    value: "foo"
}
console.log(new (A.bind(obj, 'ycp'))(21) instanceof A)
console.log(A.bind(obj, 'ycp')(21))
```

## 2.手写定长、不定长柯里化√

```javascript
//定长柯里化
function curry(fn) {
    return function curried(...args) {
        if (fn.length > args.length) {
            return function (...argsNew) {
                return curried.call(this, ...[...args, ...argsNew])
            }
        } else {
            return fn.call(this, ...args)
        }
    }
}

//简化版
const currySimple = (fn, ...args) =>
args.length < fn.length ? (...argNew) => currySimple(fn, ...[...args, ...argNew]) : fn(...args)
```

```javascript
//不定长柯里化
function curryInfinity(fn) {
    return function curried(...args) {
        if (args.length === 0) {
            return fn.call(this, ...args)
        } else {
            return function (...argsNew) {
                if (argsNew.length === 0) return fn.call(this, ...args)
                return curried.call(this, ...[...args, ...argsNew])
            }
        }
    }
}
```

## 3.手写防抖√

减少高频触发事件中不必要的频繁请求或者频繁计算。

- 用户输入之后的本地过滤，过滤的数据比较重，需要防抖。
- 频繁触发的事件，例如窗口resize，视场景使用防抖还是节流。

```javascript
//非立即执行版
function debounce(fn, delay = 500) {
    let timer
    return function (...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.call(this, ...args)
        }, delay)
    }
}
```

```javascript
//立即执行版
function debounceImmediate(fn, delay = 500, immediate = true) {
    let timer
    return function (...args) {
        if (timer) clearTimeout(timer)
        if (immediate) {
            if (!timer) fn.call(this, ...args)
            timer = setTimeout(() => {
                timer = null    //恢复执行权
            }, delay)
        } else {
            timer = setTimeout(() => {
                fn.call(this, ...args)
            }, delay)
        }
    }
}
```

## 4.手写节流√

稀释高频触发的事件

- 用户输入过程中的搜索，可以加一层节流。
- 频繁触发的事件，比如resize，如果resize事件处理函数很重的话可以考虑利用节流稀释触发频率；
- 实现规律计算、请求，例如埋点上报。

```javascript
//时间戳，立即执行，最后不执行
function throttleBefore(fc, delay = 500) {
    let prev = 0;
    return function (params) {
        let now = Date.now();
        let that = this;
        if (now - prev > delay) {
            fc.call(that, params);
            prev = now;
        }
    }
}
```

```javascript
//定时器，延后执行，最后执行
function throttleAfter(fc, delay = 500) {
    let timer = null;
    return function (params) {
        let that = this;
        if (!timer) {
            timer = setTimeout(function () {
                timer = null;
                fc.call(that, params);
            }, delay)
        }
    }
}
```

```javascript
//定时器+时间戳，立即执行，延后执行，最后再执行
function throttle(fc, delay = 500) {
    let timer = null;   //新增计时器
    let prev = 0;
    return function (params) {
        let that = this;
        let now = Date.now();
        clearTimeout(timer);    //频繁点击的时候每一次都会清除计时器

        if (now - prev >= delay) { //到达时间后恢复执行
            fc.call(that, params);
            prev = now;
        } else {
            timer = setTimeout(function () {
                fc.call(that, params);
            }, delay)
        }
    }
}

```

## 5.手写深拷贝√

```javascript
const deepCloneBetter = (target, map = new Map()) => {

    const isReference = () => target && (typeof target === 'object' || typeof target === 'function')
    const getTag = () => Object.prototype.toString.call(target).split(' ')[1].slice(0, -1).toLowerCase()

    if (!isReference(target)) return target        //基本类型直接返回

    if (map.has(target)) return map.get(target)    //查到循环引用，直接返回

    // 以下分为两类：可以再进行遍历深克隆 ＆ 无需进行遍历深克隆的
    // 无需深克隆的使用getTypeof获取类型后使用switch进行分流创建对象副本
    // 需要继续深克隆的根据类型再进行深克隆

    //以下对引用类型进行处理

    if (getTag(target) === 'map') {
        const cloneTarget = new Map()
        map.set(target, cloneTarget)
        Object.entries(target).forEach(([key, value]) => void cloneTarget.set(key, deepCloneBetter(value)))
    }

    if (getTag(target) === 'set') {
        const cloneTarget = new Set()
        map.set(target, cloneTarget)
        target.forEach((ele) => void cloneTarget.add(deepCloneBetter(ele)))
    }

    if (getTag(target) === 'object') {
        const cloneTarget = {}
        map.set(target, cloneTarget)
        Object.entries(target).forEach(([key, value]) => void (cloneTarget[key] = deepCloneBetter(value, map)))
    }

    if (getTag(target) === 'array') {
        const cloneTarget = []
        map.set(target, cloneTarget)
        target.forEach((ele, index) => void (cloneTarget[index] = deepCloneBetter(ele, map)))
    }

    return target
}
```

## 6.手写事件总线（发布-订阅）√

```javascript
// 不带队列的事件总线
class EventEmitter {
    constructor() {
        this.events = this.events || new Map()
    }

    $on(type, fn) {
        if (!this.events.has(type)) {
            this.events.set(type, fn)
        }
    }

    $emit(type, ...args) {
        if (!this.events.has(type)) return void 0
        this.events.get(type).call(this, ...args)
    }

    $off(type) {
        this.events.has(type) && this.events.delete(type)
    }

    $once(type, fn) {
        this.$on(type, (...args) => {
            fn.call(this, ...args)
            this.$off(type)
        })
    }
}
```

```js
// 带队列的事件总线
class EventEmitter {
    constructor() {
        this.events = new Map()
    }

    $on(type, fn) {
        let set = this.events.get(type)
        if (!set) {
            set = new Set()
            this.events.set(type, set)
            set.add((...args) => fn(...args))
        } else {
            set.add((...args) => fn(...args))
        }
    }

    $once(type, fn) {
        let set = this.events.get(type)
        if (!set) {
            let set = new Set()
            let callback = (...args) => {
                fn(...args)
                set.delete(callback)
            }
            set.add(callback)
            this.events.set(type, set)
        } else {
            let callback = (...args) => {
                fn(...args)
                set.delete(callback)
            }
            set.add(callback)
        }
    }

    $emit(type, ...args) {
        let set = this.events.get(type)
        if (!set) return void 0
        set.forEach(callback => callback(...args))
    }

    $off(type) {
        this.events.has(type) && this.events.delete(type)
    }
}
```



## 7.手写`instanceof`√

```javascript
function myInstanceof(left, right) {
    const prototype = right.prototype
    let prototypeLine = Object.getPrototypeOf(left)
    while (prototypeLine !== null) {
        if (prototypeLine === prototype) return true
        prototypeLine = Object.getPrototypeOf(prototypeLine)
    }
    return false
}
```

## 8.手写`new`√

```javascript
const _new = (Con, ...args) => {
    if (typeof Con !== 'function') throw new TypeError('Con must be of a constructor function')
    const obj = Object.create(Con.prototype)
    const ret = Con.call(obj, ...args)
    return ret instanceof Object ? ret : obj
}
```

## 9.手写`Object.create()`√

```javascript
Object.prototype.__create__ = (o) => {
    function F() {}
    F.prototype = o
    return new F()
}
```

## 10.手写`Promise`（符合`Promise A+`规范）√

```javascript
class MyPromise {
    static PENDING = 'pending'
    static REJECTED = 'rejected'
    static FULLFILLED = 'fullfilled'
    status = MyPromise.PENDING
    value = undefined
    reason = undefined
    //ask：this.onFullfilledCallbacks是在做什么事情?
    //answer：在promise落定后将之前（未能立即落定而存储在回调数组中的回调函数）进行调用。
    //也就是异步结果有了返回值之后，开始调用回调函数的原理
    onFullfilledCallbacks = []
    onRejectedCallbacks = []
    constructor(cb) {
      //ask：为什么要确定this.status === MyPromise.PENDING?
      //answer：因为要确保不是落定状态，才能更改状态
      const resolve = value => {
        if (this.status === MyPromise.PENDING) {
          this.status = MyPromise.FULLFILLED
          this.value = value
          this.onFullfilledCallbacks.forEach(cb => cb(this.value))
        }
      }
      const reject = reason => {
        if (this.status === MyPromise.PENDING) {
          this.status = MyPromise.REJECTED
          this.reason = reason
          this.onRejectedCallbacks.forEach(cb => cb(this.reason))
        }
      }
      try {
        cb(resolve, reject)
      } catch (e) {
        //防止调用失败
        reject(e)
      }
    }

    then(onFullfilled, onRejected) {
      if (this.status === MyPromise.FULLFILLED) {
        const promise2 = new MyPromise((resolve, reject) => {
          //这里使用的是宏任务进行模拟
          queueMicrotask(() => {
            try {
              if (typeof onFullfilled !== 'function') {
                resolve(this.value)
              } else {
                const x = onFullfilled(this.value)
                this.resolvePromise(promise2, x, resolve, reject)
              }
            } catch (e) {
              reject(e)
            }
          })
        })
        return promise2
      }
    if (this.status === MyPromise.REJECTED) {
        const promise2 = new MyPromise((resolve, reject) => {
            queueMicrotask(() => {
                try {
                    if (typeof onRejected !== 'function') {
                        resolve(this.value)
                    } else {
                        const x = onRejected(this.value)
                        this.resolvePromise(promise2, x, resolve, reject)
                    }
                } catch (e) {
                    reject(e)
                }
            })
        })
        return promise2
    }
    if (this.status === MyPromise.PENDING) {
        const promise2 = new MyPromise((resolve, reject) => {
            this.onFullfilledCallbacks.push(() => {
                queueMicrotask(() => {
                    try {
                        if (typeof onFullfilled !== 'function') {
                            resolve(this.value)
                        } else {
                            const x = onFullfilled(this.value)
                            this.resolvePromise(promise2, x, resolve, reject)
                        }
                    } catch (e) {
                        reject(e)
                    }
                })
            })
            this.onRejectedCallbacks.push(() => {
                queueMicrotask(() => {
                    try {
                        if (typeof onRejected !== 'function') {
                            resolve(this.reason)
                        } else {
                            const x = onRejected(this.value)
                            this.resolvePromise(promise2, x, resolve, reject)
                        }
                    } catch (e) {
                        reject(e)
                    }
                })
            })
        })
        return promise2
    }
}

catch(onRejected) {
    return this.then(null, onRejected)
}

finally(onFinally) {
    return this.then(value => MyPromise.resolve(onFinally()).then(() => value),
                     reason => MyPromise.resolve(onFinally()).then(() => {
        throw reason
    })
                    )
}

resolvePromise(promise, x, resolve, reject) {
    if (x === promise) return reject(new TypeError('The promise and the return value are the same'))
    if (typeof x === 'object' || typeof x === 'function') {
        if (x === null) return resolve(x) //null可能作为object进入，所以要直接返回
        let then
        //防止then取值失败
        try {
            then = x.then
        } catch (e) {
            reject(e)
        }
        if (typeof then === 'function') {
            let called = false //防止resolve被thenable回调函数内部多次调用
            try {
                then.call(x, value => {
                    if (called) return
                    called = true
                    this.resolvePromise(promise, value, resolve, reject)
                }, reason => {
                    if (called) return
                    called = true
                    reject(promise, reason, resolve, reject)
                })
            } catch (e) {
                if (called) return
                reject(e)
            }
        } else {
            resolve(x)
        }
    } else {
        resolve(x)
    }
}

deferred() {
    const res = {}
    res.promise = new MyPromise((resolve, reject) => {
        res.resolve = resolve
        res.reject = reject
    })
    return res
}

static resolve(tar) {
    if (tar instanceof MyPromise) {
        return tar
    }
    return new MyPromise((resolve, reject) => {
        if (tar && tar.then && typeof tar.then === 'function') {
            queueMicrotask(() => tar.then(resolve, reject))
        } else {
            resolve(tar)
        }
    })
}

static reject(reason) {
    return new MyPromise((resolve, reject) => reject(reason))
}

static all(...promises) {
    return new MyPromise((resolve, reject) => {
        let count = 0
        const resPromise = []
        const length = promises.length
        if (length === 0) return resolve(resPromise)
        promises.forEach((promise, index) => {
            (promise instanceof MyPromise ? promise : MyPromise.resolve(promise)).then(value => {
                count++
                resPromise[index] = value
                if (count === length) resolve(resPromise)
            }, reason => {
                reject(reason)
            })
        })
    })
}

static allSettled(...promises) {
    return new MyPromise((resolve, reject) => {
        let count = 0
        const resPromise = []
        const length = promises.length
        if (length === 0) return resolve(resPromise)
        promises.forEach((promise, index) => {
            (promise instanceof MyPromise ? promise : MyPromise.resolve(promise)).then(value => {
                count++
                resPromise[index] = {
                    status: MyPromise.FULLFILLED, value
                }
                if (count === length) resolve(resPromise)
            }, reason => {
                count++
                resPromise[index] = {
                    status: MyPromise.REJECTED, reason
                }
                if (count === length) resolve(resPromise)
            })
        })
    })
}

static race(...promises) {
    return new MyPromise((resolve, reject) => {
        const length = promises.length
        for (let i = length; i < length; i++) {
            (promises[i] instanceof MyPromise ? promises[i] : MyPromise.resolve(promises[i])).then(value => {
                return resolve(value)
            }, reason => {
                return reject(reason)
            })
        }
    })
}

}

queueMicrotask(() => {
    console.log('timer')
})
new MyPromise(res => res('promise'))
    .then(value => {
    console.log(value)
})

```

## 11.手写`Ajax`（基于`Promise`）？√

> `XMLHttpRequest`相关的`API`

```javascript
const {response, responseText, status, statuText, readyState, responseType, responseURL, responseXML, upload} = xhr

xhr.abort() 		//中止
xhr.open()			//开启
xhr.send()			//发送
xhr.onreadystatechange = handler //请求状态改变

xhr.onload = handler		//请求成功
xhr.onabort = handler		//请求中止（主动）
xhr.onerror = handler		//请求失败
xhr.onloadend = handler		//请求结束
xhr.onloadstart = handler	//接收到响应数据
xhr.onprogress = handler	//请求进度
xhr.ontimeout = handler		//请求超时

xhr.upload.onprogress		//上传进度
xhr.upload.onerror			//上传错误
xhr.upload.onabort			//上传取消
xhr.upload.onload			//上传成功
xhr.upload.ontimeout		//上传超时
xhr.upload.onloadstart		//上传开始
xhr.upload.loadend			//上传结束
xhr.timeout = num
xhr.withCredentials
xhr.getAllResponseHeaders()
xhr.getResponseHeader(key)
```

> ##### 简易实现代码
>

```javascript
const xhr = new XMLHttpRequest()
xhr.open('POST', 'http://localhost:3000')
xhr.setRequestHeader('Content-Type', 'application.json')
xhr.timeout = 3000
xhr.withCredentials = true
xhr.onload = () => {
  const {status, responseText, responseType} = xhr
  const data = responseType === 'json' ? {} : JSON.parse(responseText)
  const headers = xhr.getAllResponseHeaders()
  if(status >= 200 && status < 300) {
    console.log({
      data,
      status,
      headers,
      statusText: xhr.statusText,
      request: xhr
    })
  } else {
    console.log({
      data,
      status,
      headers
    })
  }
}
```

> ##### 完整实现代码
>

```javascript
function http({method = 'GET', url, headers = {}, data = {}, params = {}, timeout, withCredentials, cancelToken}) {
    return new Promise((resolve, reject) => {
        try {
            //配置请求方法
            method = method.toUpperCase();
            //配置请求参数，拼接到url后面
            params = qs.stringify(params) //设置请求参数
            url = `${url}${params.length ? `${params}` : ''}`

            //判断请求类型
            if (headers['Content-Type']?.includes('application/json')) { //根据设置的Content-Type格式化请求体数据
                headers['Content-Type'] = 'application/json'
                data = JSON.stringify(data)
            } else if (headers['Content-Type']?.includes('application/x-www-form-urlencoded')) {
                headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=utf-8'
                data = qs.stringify(data)
            } else {
                headers['Content-Type'] = 'text/plain'
            }

            //创建请求
            const xhr = new XMLHttpRequest()

            //配置请求中止的对象
            if (cancelToken && (cancelToken !== 'object' || cancelToken === null)) return console.log(`cancelToken must be a object`)
            //给予中止请求控制权
            void cancelToken && (cancelToken.cancel = xhr.abort)

            //开启xhr请求
            xhr.open(method, url)

            //设置是否携带cookie
            xhr.withCredentials = withCredentials
            
            //设置请求头
            headers.forEach((k, v) => xhr.setRequestHeader(k, v))

            /*
            * 设置xhr事件处理函数，处理对应的Promise状态
            * */

            //设置超时时间和处理函数
            xhr.timeout = timeout
            xhr.ontimeout = () => {
                reject('timout')
            }

            //设置请求中断处理函数
            xhr.onabort = () => {
                reject('abort')
            }

            //处理请求错误
            xhr.onerror = () => {
                reject('error')
            }

            //处理请求成功
            xhr.onload = () => {
                const {status, responseText} = xhr
                const headers = xhr.getAllResponseHeaders()
                if (status >= 200 && status < 300) {
                    resolve({
                        data: JSON.parse(responseText),
                        status,
                        statusText: this.statusText,
                        headers
                    })
                } else {
                    reject({
                        data: JSON.stringify(responseText),
                        status,
                        headers
                    })
                }
            }

            //根据请求方法决定是否发送请求体
            if (method === 'GET' || method === 'DELETE' || method === 'OPTIONS' || method === 'HEAD') {
                xhr.send()
            } else {
                xhr.send(data)
            }

        } catch (e) {
            reject(e)
        }
    })
}
```

> ##### 优化空间
>

[参考：实现`axios`拦截器的思路](https://segmentfault.com/q/1010000020521552)

- 进一步校验请求方法`method`的合法性。
- 可以利用`Promise`进一步添加拦截器（创建一个`Promise.resolve`用以给拦截器提供处理机会，维护一个`interceptor`对象，里面的属性有`request`和`response`，其中`request`中存的是`ajax`请求的处理函数`(resolve, reject)`，`response`存储的是`ajax`相应的处理函数`(resolve, reject)`）。
- 丰富请求数据类型的判断，模仿`axios`实现对`data`类型的自动判断而非依赖`Content-Type`。
- 优化错误处理。
- 优化默认值。
- 根据`xhr.responseType`自动化处理后端返回内容。

## 12.双向数据绑定√

```javascript
function v_model(tar, property, node) {
    Object.defineProperty(tar, property, {
        enumerable: true,
        configurable: true,
        get() {
            console.log('rendering')
        },
        set(newVal) {
            console.log('update')
            node.value = newVal
        }
    })
    node.addEventListener('keyup', () => {
        tar[property] = node.value
    })
}
```

## 13.手写数组数组去重√

[JavaScript 数组高性能去重 千万级数据去重效率测试 高效去重详解](https://blog.csdn.net/rudy_zhou/article/details/103971730)

[js世界-数组去重到底最快的是谁？](https://zhuanlan.zhihu.com/p/93791402)

> `普通版`

```javascript
const filter = iterator => {
    //方式一，内层循环使用includes，效率好（100000,19999 -> 3208ms）
    //const has = arr.includes(tar) 

    //方式二，双重for循环，效率差（100000,19999 -> 9475ms）
    const has = (arr, tar) => {
        for (let i = arr.length; i--;) {
            if (Object.is(arr[i], tar)) return true
        }
    }

    iterator = Array.from(iterator)
    const tar = []

    for (let i = 0; i < iterator.length; i++) {
        if (!has(tar, iterator[i])) tar.push(iterator[i])
    }
    return tar
}
```

> `ES6`

```javascript
//方式三，reduce
const filter = iterator =>
Array
.from(iterator)
.reduce((pre, cur) => pre.includes(cur) ? pre : pre.concat(cur), [])

//方式四，filter，这个方法是错的，因为indexOf()使用了严格相等比较符
//效率一般（100000,19999 -> 3493ms）
const filter = arr =>
arr
.filter((value, index) => arr.indexOf(value) === index)
```

> `sort first`

```javascript
const filter = iterator => {
    const tar = []
    iterator = Array.from(iterator).sort((a, b) => a - b)

    //方式五，sort + reduce 效率好（100000,19999 -> 39ms）
    //    iterator.reduce((prev, cur) => {
    //        if (!Object.is(cur, prev)) tar.push(cur)
    //        return cur
    //    }, Symbol('initialValue'))

    //方式六 sort + for 效率好（100000,19999 -> 38ms）
    tar.push(iterator[0])
    for (let i = 0; i < iterator.length; i++) {
        if(!Object.is(iterator[i], iterator[i + 1])) tar.push(iterator[i + 1])
    }
    return tar
}
```

> `Map` `Set`

```js
//效率无敌，最简洁（100000,19999 -> 155ms）
new Set([...iterator]).values()
```

## 14.手写`setTimeout`轮询√

```javascript
function __setInterval__(fn, delay, ...args) {
    const _this = this
    let timer
    const _run = () => setTimeout(async function __self__() {
        const ret = await fn.call(_this, ...args)
        console.log(ret)
        timer = setTimeout(__self__, delay)
    }, delay)
    timer = _run()
    return {
        terminate: () => void (clearTimeout(timer) || (timer = null)),
        pause: () => clearTimeout(timer),
        run: () => timer = _run()
    }
}
```

## 15.手写`async`、`await`（实现`co`）√

```javascript
//函数实现
const co = (gen, ...argsOfGen) => {
    const ctx = this
    return new Promise((resolve, reject) => {
        if(typeof gen === 'function') gen = gen.call(ctx, ...argsOfGen)
        if(!gen || typeof gen.next !== 'function') return resolve(gen)

        const onFullfilled = (data) => {
            let ret
            try {
                ret = gen.next(data)
            } catch(e) {
                reject(e)
            }
            return next(ret)
        }

        const onRejected = (reason) => {
            let ret
            try {
                ret = gen.throw(reason)
            } catch(e) {
                reject(e)
            }
            return next(ret)
        }

        const next = (ret) => {
            if(ret.done) return resolve(ret.value)
            if(typeof ret.value.then === 'function') return ret.value.then(onFullfilled, onRejected)
            return reject(new TypeError('only support yield Promise'))
        }
        onFullfilled()
    })
}
```

```javascript
//测试
function* gen() {
    let a = yield new Promise((res) => {
        setTimeout(() => {
            res(1)
        }, 1000)
    })
    console.log(a)
    let b = yield new Promise((res) => {
        setTimeout(() => {
            res(2)
        }, 2000)
    })
    console.log(b)
}
co(gen)
```

## 17.`rem`手写实现√

```javascript
import debounce from './debounce'
const remSet = (baseSize) => {
    const html = document.documentElement
    const {width} = html.getBoundingClientRect()
    const rem = width / baseSize
    html.style.fontSize = `${rem}px`
}
debounce(addEventListener, 50)("resize", remSet)
```

## 18.手写`flat`实现√

```javascript
//ES6
const flat =
    (arr, dep = Infinity) =>
        Array.isArray(arr) && arr.reduce((prev, cur) =>
                Array.isArray(cur) && dep > 0 ?
                    [...prev, ...flat(cur, dep - 1)] : [...prev, cur], [])
console.log(flat([1, 2, [3, [4]]], 1))
```

```javascript
//Generator
const flatGen = function* (arr, dep) {
    if (dep < 0) {
        yield arr
    } else {
        let {length} = arr
        for (let i = 0; i < length; i++) {
            const item = arr[i]
            if (Array.isArray(item)) {
                yield* flatGen(item, dep - 1)
            } else {
                yield item
            }
        }
    }
}
console.log([...flatGen([1, 2, [3, [4]]], 1)])
```

```js
//非递归版本
const flat = function (arr) {
    const queue = [...arr]
    const res = []
    while (queue.length) {
        const cur = queue.shift()
        if (Array.isArray(cur)) {
            queue.unshift(...cur)
        } else {
            res.push(cur)
        }
    }
    return res
}
```



## 19.手写简单路由√

```javascript
// 简易路由实现的功能，根据路由调用回调函数，进行页面的变化
class Router {
    routes = new Map()
    currentHash = ''

    constructor() {
        this.freshRoute = this.freshRoute.bind(this);
        window.addEventListener('load', this.freshRoute, false);
        window.addEventListener('hashchange', this.freshRoute, false);
    }

    storeRoute(path, cb) {
        this.routes.set(path, cb || (function () {}));
    }

    freshRoute() {
        const routes = this.routes
        this.currentHash = location.hash.slice(1) || '/';
        routes.has(this.currentHash) && routes.get(this.currentHash)();
    }
}

```

## 20.手写日期处理√

```javascript
Date.prototype.format = function(fmt) {
     var regOptions = {
        "Y{4}" : this.getFullYear(),						//年份 
        "q{1}" : Math.floor((this.getMonth() + 3) / 3), 	//季度
        "M{2}" : this.getMonth() + 1,   					//月份
        "d{2}" : this.getDate(),          					//日 
        "h{2}" : this.getHours(),         					//小时 
        "m{2}" : this.getMinutes(),       					//分 
        "s{2}" : this.getSeconds(),       					//秒  
        "S{3}"  : this.getMilliseconds()   					//毫秒 
    }; 
    Object.keys(regOptions).forEach((reg)=>{
        fmt = fmt.replaceAll(new RegExp(`(?:${reg})`, 'g'), regOptions[reg])
    })
    return fmt;
}       

new Date().format("现在是北京时间YYYY年MM月dd日，hh时mm分ss秒, 第q季度");
```

## 21.手写字符串模板√

```javascript
//非常简单的替换
const beard = (str, obj) => {
    let ret
    const arr = []
    let regex = new RegExp(/\${\s*(?<prop>\w+)\s*}/, 'g')
    regex = new RegExp(regex, '')
    arr.reverse()	//从字符串右侧开始替换，不会影响字符串左侧索引
        .forEach(({1: prop, index: startIndex, 0: matched}) => {
        str = str.slice(0, startIndex) 
            	+ obj[prop] 
            	+ str.slice(startIndex + matched.length)
    })
    return str
}
console.log(beard('My name is ${ name }, My age is ${ age }', {
    name: 'ycp',
    age: 21
}))
function render(template, context) {
    const _fn = new Function("context", `
    const arr = [];
    with(context){
      arr.push('${
        template
            .replace(/{{(.*?)}}/g, "',$1,'") // 将 变量}} 替换成 ,变量,
    }')
      return arr.join('')
    }
  `);
    return _fn(context);
}

console.log(render(
    '{{company}}---{{group.name}}---{{group.jobs[0]}}---{{group["jobs"][1]}}',
    {
        group: {
            name: "天猫",
            jobs: ["前端", "后端", "产品"]
        },
        company: '阿里巴巴'
    }
))
```

## 22.动态命名空间管理器 ×

```javascript
const useNamespace = () => {
	const MyApp = {}
	MyApp.namespace = (name) => {
        const parts = name.split('.')
        let current = MyApp
        for(let part in parts) {
            if(!current[part]) {
                current[part] = {}
            }
            current = current[part]
        }
    }
    return MyApp.namespace
}
const namespace = useNamespace
namespace('name')
namespace('name.lastname')

```

## 23.手写贝塞尔曲线×

[参考](https://juejin.cn/post/6844903666361565191)

> ### n阶贝塞尔曲线公式

![B(t) = \sum_{i=0}^{n}C_n^{i}P_i(1-t)^{n-i}t^i,t\in[0,1]](https://juejin.cn/equation?tex=B(t)%20%3D%20%5Csum_%7Bi%3D0%7D%5E%7Bn%7DC_n%5E%7Bi%7DP_i(1-t)%5E%7Bn-i%7Dt%5Ei%2Ct%5Cin%5B0%2C1%5D)

> ### 三阶贝塞尔曲线公式

$$
{B}_{3}(t)\, =\, {(1-t)}^{3}{P}_{0}+3t{(1-t)}^{2}{P}_{1}+3{t}^{2}{(1-t)}{P}_{1}+{t}^{3}{P}_{2},\, t\in [0,\, 1]
$$

> ### 锚定起点`[0, 0]`和终点`[1, 1]`的三阶贝塞尔

![B_{3, x}(t) = 3t(1 - t)^2x_1 + 3t^2(1 - t)x_2 + t^3 , t\in[0, 1]](https://juejin.cn/equation?tex=B_%7B3%2C%20x%7D(t)%20%3D%203t(1%20-%20t)%5E2x_1%20%2B%203t%5E2(1%20-%20t)x_2%20%2B%20t%5E3%20%2C%20t%5Cin%5B0%2C%201%5D)

![B_{3, y}(t) = 3t(1 - t)^2y_1 + 3t^2(1 - t)y_2 + t^3 , t\in[0, 1]](https://juejin.cn/equation?tex=B_%7B3%2C%20y%7D(t)%20%3D%203t(1%20-%20t)%5E2y_1%20%2B%203t%5E2(1%20-%20t)y_2%20%2B%20t%5E3%20%2C%20t%5Cin%5B0%2C%201%5D)

```javascript
class Bezier {
	constructor([[x1, y1], [x2, y2]] = [[0, 0], [0, 0]], precision = 100) {
		this.controlPoints = [[x1, y1], [x2, y2]]
        this.precision = precision
	}
    
	calcCoord(t) {
		if(t > 1|| t < 0) return 
        const _t = 1 - t
        const [[x1, y1], [x2, y2]] = this.controlPoints
		const px = t * (3 * (1 - t) * (_t * x1 + t * x2) + t * t)
        const py = t * (3 * (1 - t) * (_t * y1 + t * y2) + t * t)
        // 结果只保留三位有效数字
        return [parseFloat(px.toFixed(3)), parseFloat(py.toFixed(3))]
    }
    
    updatePrecision(precision) {
        this.precision = precision
        if(this.coords) this.updateCoordsArray()
    }
    
    updateControlPoints([[x1, y1], [x2, y2]]) {
        this.controlPoints = [[x1, y1], [x2, y2]]
        if(this.coords) this.updateCoordsArray()
    }
    
    updateCoordsArray() {
        const {precision} = this
        const step = 1 / (precision + 1);
        const result = [];
        for (let t = 0; t <= precision + 1; t++) {
            result.push(this.calcCoord(t * step));
        }
        this.coords = result;
    }
    
    getCoords() {
        if(!this.coords) this.updateCoordsArray() 
        return this.coords
    }
    
    calcAxis(x) {
        if (x >= 1) return 1;
        if (x <= 0) return 0;
        let startX = 0;
        for (let i = 0; i < this.coords.length; i++) {
            if (this.coords[i][0] >= x) {
                startX = i;
                break;
            }
        }
        const axis1 = this.coords[startX];
        const axis2 = this.coords[startX - 1];
        const k = (axis2[1] - axis1[1]) / (axis2[0] - axis1[0]);
        const b = axis1[1] - k * axis1[0];
        // 结果也只保留三位有效数字
        return parseFloat((k * x + b).toFixed(3));
    }

}
```

## 24.手写`Object.assign()`√

```javascript
//Object.assign()实现核心功能点，将后继对象的（自身可枚举属性）追加到源对象（第一个参数）
Object.prototype.__assign__ = (target, ...args) => {
    //null和undfined会报错
    if(typeof target === null || typeof target === undefined) throw new TypeError('Cannot convert undefined or null to object at Function.assign')
    //基本类型进行包装
    if(!(target instanceof Object)) return Object(target)
    args.forEach(obj => {
        Object
            .keys(obj).concat(Object.getOwnPropertySymbols(obj))
            .forEach((key) => void (target[key] = obj[key]))
    })
}

//测试
let obj = {}
let test = {
    [Symbol()]: 'symbol1',
    name: 'ycp',
    [Symbol()]: 'symbol2'
}
Object.defineProperty(test, 'hidden', {
    enumerable: false
})
Object.__assign__(obj, test)
Object.__assign__(obj, {
    name: 'other'
})
console.log(obj)

```

## 25.手写`class`混入×

```javascript
function mix(...mixins) {
    class Mix {
        constructor() {
            mixins.forEach(mixin => {
                //盗用实例属性
                copyProperties(this, new mixin())
            })
        }
    }

    const copyProperties = (target, source) => {
        for (let key of Reflect.ownKeys(source)) {
            if (key !== 'constructor'/*剔除原型上的constructor*/
                && key !== 'prototype' /*剔除类上的prototype属性*/
                && key !== 'name'/*剔除类的名字*/) {
                const desc = Object.getOwnPropertyDescriptor(source, key)
                Object.defineProperty(target, key, desc)
            }
        }
    }
    
    mixins.forEach(mixin => {
        //复制静态属性
        copyProperties(Mix, mixin)
        //复制原型属性
        copyProperties(Mix.prototype, mixin.prototype)
    })
    
    return Mix
}
```

## 26.手写有并行限制的`Promise`√

```javascript
class PromiseSchedule {
    maxTask = 2
    runningTask = 0
    queue = new Set()

    constructor(maxTask) {
        this.maxTask = maxTask
    }

    add(PromiseProducer, onFulfilled = (() => {
    }), onRejected = (() => {
    })) {
        const proxyPromiseProducer = () => {
            this.runningTask += 1
            this.queue.delete(proxyPromiseProducer)
            PromiseProducer().then(onFulfilled, onRejected).finally(() => {
                this.runningTask -= 1
                this.run()
            })
        }
        this.queue.add(proxyPromiseProducer)
    }

    canRun() {
        return !(this.queue.size === 0 || this.maxTask - this.runningTask <= 0)
    }

    run() {
        if (!this.canRun()) return
        while (this.runningTask < this.maxTask) {
            [...this.queue.values()][0]()
        }
    }
}

const pp = () => new Promise((resolved, rejected) => {
    setTimeout(() => {
        resolved('ycp')
    }, 1000)
})

const fullfilled = value => {
    console.log(value)
}
const rejected = reason => {
    console.log(reason)
}

let ps = new PromiseSchedule(4)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.add(pp, fullfilled, rejected)
ps.run()
```

## 27.手写简易的有限状态机×

[🔗模仿javascript-state-machine库](https://github.com/jakesgordon/javascript-state-machine)

```javascript
class StateMachine {
    constructor({init, transitions = [], methods}) {
        Object.defineProperties(this, {
            state: {
                enumerable: false,
                get() {
                    return this.__state__
                }
            },
            __state__: {
                writable: true,
                value: init
            },
            __transitions__: {
                value: transitions,
                writable: true
            },
            states: {
                value: transitions.reduce((prev, {from, to}) => {    //保存所有状态
                    if (!prev.includes(from)) prev.push(from)
                    if (!prev.includes(to)) prev.push(to)
                    return prev
                }, []),
                writable: true
            },
            methods: {
                value: methods,
                writable: true
            }
        })  //设置访问权限，防止篡改
        this.bindMethods(methods) //根据methods绑定状态转移触发函数
    }

    //也可以通过Proxy给状态绑定处理函数（onLeave、onEnter）

    //这里给状态的切换状态事件本身绑定了函数
    bindMethods(methods) {
        const instance = this
        return Object.entries(methods).forEach(([name, callback]) => {
            const {from, to} = instance.getTransition(name)
            if (from === undefined || to === undefined) return
            //这里默认状态切换之后执行同名状态回调，其实可以利用AOP进一步优化这个函数，支持（onBefore、onAfter）
            instance[name] = function (...argsFroEventSelf) {
                if (from === instance.state) {
                    instance.changeState(to)
                    return callback.call(instance, ...argsFroEventSelf)
                }
                return instance.error(instance.state, to)
            }
        })
    }

    getTransition(name) {
        return this.__transitions__.find(({name: _name}) => _name === name)
    }

    changeState(to) {
        return this.__state__ = to
    }

    //以下是对外暴露的api

    is(state) {
        return this.state === state
    }

    can(to) {
        return this.transitions(to).some(({to: _to}) => _to === to)
    }

    cannot(to) {
        return !this.can(to)
    }

    transitions() {     //允许的状态转移
        const from = this.state
        return this.__transitions__.filter(({from: _from}) => from === _from)
    }

    allTransitions() {
        return this.__transitions__
    }

    allStates() {
        return this.states
    }

    error(from, to) {
        throw new Error(`from ${from} to ${to} is not defined!`)
    }


}

// *优化空间：
// *1.利用AOP根据传入的methods来修饰状态切换函数（onBeforeTransition -> onAfterTransition -> 状态修改 -> onmTransition）
// *2.利用代理Proxy给状态添加拦截器，检测状态变更的时候执行相应的函数，例如（固态 -> 液态，会触发：onLeaveState、onEnterState）
// *3.传入参数的校验
// *4.实现异步的支持

const stateMachine = new StateMachine({
    init: "固态",
    transitions: [
        {name: "melt", from: "固态", to: "液态"},
        {name: "freeze", from: "液态", to: "固态"},
        {name: "vaporize", from: "液态", to: "气态"},
        {name: "condense", from: "气态", to: "液态"},
        {name: "sublimation", from: "固态", to: "气态"},
        {name: "condensate", from: "气态", to: "固态"}
    ],
    methods: {
        melt: function () {
            console.log("I melted");
        },
        freeze: function () {
            console.log("I froze");
        },
        vaporize: function () {
            console.log("I vaporized");
        },
        condense: function () {
            console.log("I condensed");
        },
        sublimation: function () {
            console.log("I sublimated");
        },
        condensate: function () {
            console.log("I condensate");
        }
    }
})
console.log(stateMachine.state)
stateMachine.melt()
console.log(stateMachine.state)
stateMachine.freeze()
console.log(stateMachine.state)

```

## 28.手写实现`JSAOP`√

```javascript
//污染全局的方式
Function.prototype.after = function(afterFunc) {
    const self = this
    return function(...args) {
        self.call(this, ...args)
        afterFunc.call(this, ...args)
    }
}
Function.prototype.before = function(beforeFunc) {
    const self = this
    return function(...args) {
        beforeFunc.call(this, ...args)
        self.call(this, ...args)
    }
}
Function.prototype.between = function(betweenFunc) {
    const self = this
    return function(...args) {
        betweenFunc.call(this, ...args)
        self.call(this, ...args)
        betweenFunc.call(this, ...args)
    }
}
Function.prototype.error = function(errorFunc) {
    const self = this
    return function(...args) {
        try {
            self.call(this, ...args)   
        } catch(e) {
            console.log(e)
            errorFunc.call(this, ...args)
        }
    }
}
Function.prototype.noerror = function(noerrorFunc) {
    const self = this
    return function(...args) {
        const noerror = true
        try {
            self.call(this, ...args)   
        } catch(flag) {
            noerror = false
        } finally {
            if(noerror) noerrorFunc.call('')
        }
    }
}
//传递参数
Function.prototype.after = function(afterFunc) {
    const self = this
    return function(...args) {
        self.call(this, ...args)
        afterFunc.call(this, ...args)
    }
}
const logic1 = function(params) {
    params.name = 'ycp'
}
const logic2 = function(params) {
    console.log(params.name)
}
logic1.after(logic2)({})
```

```javascript
//不污染全局的方式
function after(origin, afterFunc) {
    return function(...args) {
        origin.call(this, ...args)
        afterFunc(this, ...args)
    }
}
const logic1 = function(params) {
    params.name = 'ycp'
}
const logic2 = function(params) {
    console.log(params.name)
}
after(logic1, logic2)({})

function afterChain(origin, ...fns) {
    if(fns.length === 0) return origin
    const popFn = fns.shift()
    const modifiedFn = function(...args) {
        origin.call(this, ...args)
        popFn.call(this, ...args)
    }
    return afterChain(modifiedFn, ...fns)
}
const logic1 = function(params) {
    console.log(1)
}
const logic2 = function(params) {
    console.log(2)
}
const logic3 = function(params) {
    console.log(3)
}
afterChain(logic1, logic2, logic3)()
```

## 29.使用`generator`手写一个简单的计算器状态机×

```javascript
const calcStrategies = {
    '+': function (init, opValue) {
        return init + opValue
    },
    '-': function (init, opValue) {
        return init - opValue
    },
    'x': function (init, opValue) {
        return init * opValue
    },
    '/': function (init, opValue) {
        return init / opValue
    }
}

function* calc() {
    let value = null
    //const numbers = []
    const symbols = []
    let state = 'init'
    while (true) {
        const input = yield value
        if (state === 'init' && typeof input === 'number') {
            //numbers.push(input)
            value = input
            state = 'waitingSymbol'
        }
        if (state === 'waitingSymbol' && calcStrategies[input] !== undefined) {
            symbols.push(input)
            state = 'waitingNumber'
        }
        if (state === 'waitingNumber' && typeof input === 'number') {
            //numbers.push(input)
            value = calcStrategies[symbols.slice(-1)](value, input)
            state = 'waitingSymbol'
        }
        if (input === 'reset') {
            //numbers.splice(0)
            symbols.splice(0)
            state = 'waitingNumber'
        }
    }
}

const iter = calc()
let equation = ''
const executeNext = (value) => {
    console.log(equation)
    console.log(iter.next(value))
    return executeNext
}
executeNext()(1)('+')(2)('-')(1)('/')(0.5)
```

## 30.手写事件委托√

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
        <ul>
            <li id="1">
                <h1>Title</h1>
                <div>Content</div>
            </li>
            <li id="2">
                <h1>Title</h1>
                <div>Content</div>
            </li>
            <li id="3">
                <h1>Title</h1>
                <div>Content</div>
            </li>
        </ul>
        <script>
            const ul = document.querySelector('ul')
            ul.onclick = e => {
                //实际触发事件的DOM元素
                const trigger = e.target
                //我们希望委托的具体目标DOM元素
                const targetEle = e.target.closest('li')
                console.log(trigger)
                console.log(targetEle.id)
            }
        </script>
    </body>
</html>
```



## 31.使用`DFS`根据数据创建`DOM`√

```javascript
const data = [
    {
        title: 'a', id: 1,
        children: [{
            title: 'b', id: 2, children: [{
                title: 'b1', id: 5
            }, {
                title: 'b2', id: 6
            }]
        }, {
            title: 'c', id: 3
        }]
    },
    {
        title: 'd', id: 4,
        children: [{
            title: 'e', id: 5
        }, {
            title: 'f', id: 6
        }]
    }
];
```

```javascript
function dfsCreateDOM(nsData) {
    const fragment = document.createDocumentFragment()
    nsData.forEach(nData => {
        const div = document.createElement('div')
        div.setAttribute('title', nData.title)
        if (nData.children && nData.children.length) 			div.appendChild(dfsJSX(nData.children))
        fragment.appendChild(div)
    })
    return fragment
}
const fragment = dfsCreateDOM(data)
console.log(fragment)
```

## 32.使用深度优先遍历遍历`DOM`树√

```javascript
//递归法
function dfsRecursion(node) {
  let ret = []
  if (!node) return []
  ret.push(node)
  const {children} = node
  if (children?.length) {
    Array.from(children).forEach(node => {
      ret.push(...dfsRecursion(node))
    })
  }
  return ret
}
//非递归法
function dfs(root) {
  const ret = []
  const inner = node => {
    const {children} = node
    ret.push(node)
    if (children.length) [...children].forEach(inner)
  }
  inner(root)
  return ret
}
```

## 33.使用广度优先遍历遍历`DOM`树√

```javascript
//非递归版本
function bfs(root) {
    const queue = [root];
    let pointer = 0;
    const ret = [];
    while (pointer < queue.length) {
        const dom = queue[pointer++];
        ret.push(dom);
        if (dom.children.length) queue.push(...dom.children);
    }
    return ret;
}

//递归版本
function bfsRecursion(root) {
    const queue = [root];
    const ret = [];
    let pointer = 0;
    const bfs = () => {
        const dom = queue[pointer++]
        if (!dom) return
        ret.push(dom)
        if (dom.children.length) queue.push(...dom.children)
        bfs()
    }
    bfs()
    return ret
}
```

## 34.分离小数和整数并保留指定位数的小数√

```js
const splitNumber = (number, fixed) => {
    let trunc = String(Math.trunc(number))
    let fract = (number - trunc).toFixed(fixed).slice(2)
    return [trunc, fract]
}
```

## 35.JSONP√

```js
function jsonp(url, data, callbackName) {
    let {body} = document
    // 创建DOM
    let script = document.createElement('script')
    // 拼接字符串
    const params = Object.entries(data)
    const {length} = params
    let tail = ''
    if (length) {
        tail = params.reduce((str, [k, v], index) => {
            let cur = `${encodeURIComponent(k)}=${encodeURIComponent(v)}`
            return index === length - 1 ? str + cur + '&' : str + cur
        }, '?')
    }
    script.setAttribute('src', url + tail)
    // 设置全局函数
    return new Promise((resolve, reject) => {
        window[callbackName] = (data) => {
            resolve(data)
            body.removeChild(data)
            Reflect.deleteProperty(window, callbackName)
        }
        body.appendChild(script)
    })
}
```

## 36.Array上的遍历数组的高阶函数实现√

```js
  Array.prototype.__forEach__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        cb.call(thisArg, this[i], i, this)
      } else {
        cb(this[i], i, this)
      }
    }
  }

  let a = [1, 2, 3, 4]
  console.log("a:", a)
  let context = {}
  a.__forEach__((value, index, array) => {
    // console.log(this === context)
    // console.log(value, index, array)
  }, context)
  a.__forEach__(function (value, index, array) {
    // console.log(this === context)
    // console.log(value, index, array)
  }, context)


  Array.prototype.__map__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    const newArr = []
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        newArr[i] = cb.call(thisArg, this[i], i, this)
      } else {
        newArr[i] = cb(this[i], i, this)
      }
    }
    return newArr
  }
  // console.log(a.__map__((x) => x * 2))

  Array.prototype.__some__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return true
      } else {
        if (cb(this[i], i, this)) return true
      }
    }
    return false
  }
  // console.log(a.__some__(x => x === 2))
  // console.log(a.__some__(x => x === 9))


  Array.prototype.__every__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        if (!cb.call(thisArg, this[i], i, this)) return false
      } else {
        if (!cb(this[i], i, this)) return false
      }
    }
    return true
  }

  // console.log(a.__every__(x => x <= 4))
  // console.log(a.__every__(x => x > 5))

  Array.prototype.__filter__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    const newArr = []
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) newArr.push(this[i])
      } else {
        if (cb(this[i], i, this)) newArr.push(this[i])
      }
    }
    return newArr
  }
  // console.log(a.__filter__(x => x >= 2))
  // console.log(a.__filter__(x => x >= 5))

  Array.prototype.__find__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return this[i]
      } else {
        if (cb(this[i], i, this)) return this[i]
      }
    }
    return undefined
  }
  // console.log(a.__find__(x => x >= 3))


  Array.prototype.__findIndex__ = function (cb, thisArg = null) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    for (let i = 0; i < this.length; i++) {
      //判断类型
      if (cb.prototype) {
        if (cb.call(thisArg, this[i], i, this)) return i
      } else {
        if (cb(this[i], i, this)) return i
      }
    }
    return undefined
  }
  // console.log(a.__findIndex__(x => x >= 3))

  Array.prototype.reduce = function (cb, accumulator) {
    //遍历
    if (typeof cb !== 'function') throw new TypeError('wrong callback type')
    let i
    if (accumulator === undefined) {
      accumulator = this[0]
      i = 1
    } else {
      i = 0
    }
    for (; i < this.length; i++) {
      accumulator = cb(accumulator, this[i], i, this)
    }
    return accumulator
  }

  console.log(a.reduce((prev, value, index) => prev + value, 0))

```

## 37.观察者模式×

```js
class Subject{
    constructor(name){
        this.name = name
        this.observers = []
        this.state = 'XXXX'
    }
    // 被观察者要提供一个接受观察者的方法
    attach(observer){
        this.observers.push(observer)
    }

    // 改变被观察着的状态
    setState(newState){
        this.state = newState
        this.observers.forEach(o=>{
            o.update(newState)
        })
    }
}

class Observer{
    constructor(name){
        this.name = name
    }

    update(newState){
        console.log(`${this.name}say:${newState}`)
    }
}

// 被观察者 灯
let sub = new Subject('灯')
let mm = new Observer('小明')
let jj = new Observer('小健')

// 订阅 观察者
sub.attach(mm)
sub.attach(jj)

sub.setState('灯亮了来电了')
```

## 38.组合函数√

```js
function compose(...fns) {
    if (!fn.length) return (v) => v
    if (fn.length === 1) return fn[0]
    return fns.reduce((prev, cur) => ((...args) => prev(cur(...args))))
}
```

## 39.Object.is()√

```js
Object.is = function (x, y) {
  if (x === y) {
      //处理+0/-0
    return x !== 0 || 1 / x === 1 / y;
  }
    //处理NaN
  return x !== x && y !== y;
}
```

## 40.字符串中出现最多次的字符和个数×

```js
let str = "abcabcabcbbccccc";
let num = 0;
let char = '';

 // 使其按照一定的次序排列
str = str.split('').sort().join('');
// "aaabbbbbcccccccc"

// 定义正则表达式
let re = /(?<repeat>w)\k<repeat>+/g;
str.replace(re,($0,$1) => {
    if(num < $0.length){
        num = $0.length;
        char = $1;        
    }
});
console.log(`字符最多的是${char}，出现了${num}次`);
```

## 41.判断滑动内容滑动到了底部×

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        #container {
            height: 100px;
            width: 50px;
            border: 2px solid red;
            overflow-y: scroll;
        }
        #son {
            height: 200px;
            background-color: yellow;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="son">
        </div>
    </div>
    <script>
        let container = document.querySelector('#container')
        console.log(container)
        container.addEventListener('scroll', function (event) {
            if (Math.ceil(event.target.scrollTop + event.target.clientHeight) === event.target.scrollHeight) {
                container.children[0].style.backgroundColor = 'green'
            } else {
                container.children[0].style.backgroundColor = 'yellow'
            }
        })
    </script>
</body>
</html>
```

# 大数相加

```javascript
const bigIntAdd = (a, b) => {
    [a, b] = [[...a], [...b]]
    let [longer, shorter] = [a.length > b.length ? a : b, a.length > b.length ? b : a];
    shorter = [...Array.from({ length: longer.length - shorter.length }).fill('0'), ...shorter];
    return longer.reduceRight(([count, shift], value, index) => {
        const cur = Number(value) + Number(shorter[index]) + (shift ? 1 : 0);
        if (cur >= 10) return [(cur - 10) + count, true]
        return [cur + count, false]
    }, ['', false])[0]
}

// TEST
let bigA = '123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789'
let bigB = '123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789123456789'
let hack = bigIntAdd(bigA, bigB)
let origin = String(BigInt(bigA) + BigInt(bigB))
console.log(hack === origin)
```

```javascript
const bigIntAddBetter = (left, right) => {
    [left, right] = [[...left], [...right]]
    const [leftLen, rightLen] = [left.length, right.length]
    let [longerArr, shorterArr] = [leftLen > rightLen ? left : right, leftLen > rightLen ? right : left];
    shorterArr = [...Array.from({ length: longerArr.length - shorterArr.length }).fill('0'), ...shorterArr];

    let index = longerArr.length - 1;
    let carryFlag = false;
    let sum = '';
    let count = 0
    while (index >= 0) {
        console.log(++count)
        // 没有进位并且计算到了临界点
        if (!carryFlag && index < (leftLen - rightLen)) {
            return longerArr.slice(0, index + 1).join('') + sum;
        }
        const [left, right] = [longerArr[index], shorterArr[index]];
        const temp = Number(left) + Number(right) + (carryFlag ? 1 : 0);
        if (temp >= 10) {
            carryFlag = true;
            sum = (temp - 10) + sum;
        } else {
            carryFlag = false;
            sum = temp + sum;
        }
        index--;
    }
    return sum
}

console.log(Number(bigIntAdd('1000000009800', '200')) === 1000000009800 + 200);
```

```javascript
const bigAddWithDecimal = (left, right) => {
    let [leftInt, leftDec = ''] = left.toString().split('.');
    let [rightInt, rightDec = ''] = right.toString().split('.');

    const maxDecimalBit = Math.max(leftDec.length, rightDec.length)
    if (maxDecimalBit === 0) return (BigInt(leftInt) + BigInt(rightInt)).toString()
    leftDec = leftDec.toString().padEnd(maxDecimalBit, '0')
    rightDec = rightDec.toString().padEnd(maxDecimalBit, '0')

    const _leftInt = leftInt + leftDec
    const _rightInt = rightInt + rightDec
    const sum = (BigInt(_leftInt) + BigInt(_rightInt)).toString()
    const twoPart = [sum.slice(0, -maxDecimalBit), sum.slice(-maxDecimalBit)]
    twoPart[0] = twoPart[0].length ? twoPart[0] : '0'
    return twoPart.join('.')
}
```

