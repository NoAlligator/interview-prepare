# 1.进程和线程有什么区别？

- 进程（Process）是**系统**进行资源分配和调度的基本单位，线程（Thread）是**CPU**调度和分派的基本单位；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程有**自己的独立地址空间**，线程**共享所属进程的地址空间**；
- 进程是**拥有系统资源的一个独立单位**，而线程**自己基本上不拥有系统资源**，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，**和其他线程共享本进程的相关资源如内存、I/O、CPU等**；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，**进程切换的开销远大于线程切换的开销**；
- **线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行**；
- **多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮**；

> 进程是系统调度的最小单位，线程是CPU调度的最小单位；
>
> 线程依赖于进程，一个进程至少有一个线程；
>
> 进程有自己的独立地址空间、线程共享所属进程的地址空间；
>
> 线程崩溃会影响其他线程，进程崩溃不会影响其他进程；
>
> 进程切换开销大于线程；
>
> 线程通信方便，进程之间通信要以进程间通信的方式进行；

# 2.同一进程中的线程可以共享哪些数据？

- **进程代码段**；
- **进程的公有数据（全局变量、静态变量...）**；
- 进程打开的文件描述符；
- **进程的当前目录**；
- 信号处理器/信号处理函数：对收到的信号的处理方式；
- 进程ID与进程组ID。

# 3.线程独占哪些资源？

- **线程ID**
- **一组寄存器的值**
- **线程自身的栈（堆是共享的）**
- 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；
- 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）

# 4.进程间通信方式

## 共享存储

因为两个进程的存储空间`不能相互访问`，所以操作系统就提供的一个内存空间让彼此都能访问，这就是共享存储的原理。内存中画出一块`共享存储区`，数据的形式、存放位置都是由进程控制，而不是操作系统（两个进程对共享空间的访问必须是互斥的，互斥访问通过操作系统提供的工具来实现）。

## 管道

- 管道是**半双工**的，数据只能**向一个方向流动**；需要双方通信时，需要**建立起两个管道**；
- **一个进程向管道中写的内容被管道另一端的进程读出**。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；
- 只能用于**父子进程或者兄弟进程**之间（具有亲缘关系的进程）
- 管道数据是以`字符流`（注意不是字节流）的形式写入管道，当管道写满时，写进程的`write()`系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的`read()`系统调用将被阻塞。
- 如果**没写满就不允许读**。如果都**没空就不允许写**。
- **数据一旦被读出，就从管道中被丢弃，这就意味着`读进程`最多只能有一个**。

> 半双工的，数据单向流动；一个进程负责写入，另有一个进程负责读，数据一旦被读出，就从管道中被丢弃，如果没写满就不允许读，如果没空就不允许写；只能用于父子进程和兄弟进程之间；以字节流的形式写入管道；

## 消息队列

消息队列亦称报文队列，也叫做信箱，是Linux的一种通信机制，这种通信机制传递的数据会被拆分为一个一个独立的数据块，也叫做消息体，消息体中可以定义类型与数据，克服了无格式承载字节流的缺陷。同管道类似，它有一个不足就是每个消息的最大长度是有上限的，整个消息队列也是长度限制的。

### 特点

- 与管道不同，消息队列的生命周期随内核，不会随进程销毁而销毁，需要我们显示的调用接口删除或使用命令删除。
- 消息队列可以**双向通信**。
- 克服了管道**只能承载无格式字节流**的缺点。

## 信号量

主要作为进程间以及同一进程不同线程之间的同步手段。

## 信号量

信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；

## 套接字

更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。

# 5.进程的几种状态

> （1）**运行**状态：进程正在处理机上运行

> （2）**就绪**状态：进程已经获得了除处理机之外的一切所需资源

> （3）**阻塞**状态：进程正在等待某一事件而暂停执行

> （4）**创建**状态：进程正在被创建，尚未转到就绪状态。

> （5）**结束**状态：进程正在从系统中消失，分为正常结束和异常退出。

# 6.内核态和用户态

> 根据**执行程序对资源和机器指令的使用权限**可以将处理器的状态分为**内核态和用户态**。

> **内核是一组程序模块，运行于内核态**，具有直接访问硬件设备和所有内存空间的权限，是仅有的**能够执行特权指令的程序**。

> 一般而言，内核具有以下功能：中断处理、时钟管理、原语、系统控制的数据结构及处理（进程管理、存储管理、设备管理）。

> 三种情况会发生用户态向内核态转换：（**其实这三种情况都算是通过中断机制发生**）

> > （1）**系统调用**（软中断）

> > （2）**中断**（外中断）

> > （3）**异常**（内中断）

# 7.中断

> 中断是指处理器接收到了来自**硬件或者软件的信号**，提示发生了某个事件，应该被注意，这种情况就称为中断。

> 中断分为内中断和外中断：

> > （1）外中断，也称中断，指来自**CPU执行指令以外的事件的发生**，如I/O结束中断、时钟中断。

> > （2）内中断，又称异常，指源自CPU执行指令内部的事件，如程序的非法操作码、地址越界、算术溢出、虚存系统的缺页以及专门的陷入指令等引起的事件。

# 8.死锁？死锁产生的原因，死锁的必要条件？怎么预防？怎么处理死锁？

> 死锁：**相互等待资源而产生的一种僵持状态**，如果没有外力的干预将一直持续这个状态。

> 产生原因：**系统资源不足、相互竞争资源、资源请求顺序不当**。

> 产生死锁的必要条件：

> > 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。**如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。**

> > 请求与保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

> > 不剥夺条件：指**进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。**

> > 循环与等待条件：存在一个**循环链，互相等待资源的释放** ；
> >
> > 预防死锁：破坏三个条件之一就可以，常见的方法有**有序资源分配法、银行家算法**。

> 处理死锁：因为互斥是不可改变的，所以只能破坏其他三个条件中的一个来解除死锁，方法：**剥夺资源、杀死其中一个线程**

